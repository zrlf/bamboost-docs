"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9321],{6328:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>f,frontMatter:()=>a,metadata:()=>d,toc:()=>p});var l=n(5893),i=n(1151),s=n(5552),r=n(8213);const a={title:"Common",hide_table_of_contents:!1,tags:["getting started"]},o=void 0,d={id:"api/common/common",title:"Common",description:"bamboost.common",source:"@site/docs/api/common/common.md",sourceDirName:"api/common",slug:"/api/common/",permalink:"/bamboost-docs/docs/api/common/",draft:!1,unlisted:!1,tags:[{label:"getting started",permalink:"/bamboost-docs/docs/tags/getting-started"}],version:"current",frontMatter:{title:"Common",hide_table_of_contents:!1,tags:["getting started"]},sidebar:"apiSidebar",next:{title:"File Handler",permalink:"/bamboost-docs/docs/api/common/file_handler"}},u={},p=[{value:"bamboost.common",id:"bamboostcommon",level:2}];function c(e){const t={h2:"h2",...(0,i.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.h2,{id:"bamboostcommon",children:"bamboost.common"}),"\n",(0,l.jsx)(s.ZP,{moduleName:"common"}),"\n",(0,l.jsx)(r.o,{})]})}function f(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},5552:(e,t,n)=>{n.d(t,{wT:()=>o,Yl:()=>d,ZP:()=>u});n(7294);const l=JSON.parse('{"accessors":{"description":null,"classes":{},"methods":{},"modules":{"fielddata":{"description":null,"classes":{"DataGroup":{"description":"This pointer points to the data directory. Item accessor returns the\\nindividual data fields. `meshes` is passed to here for access of linked\\nmeshes.","methods":{"datasets":{"signature":"def datasets(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"groups":{"signature":"def groups(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"keys":{"signature":"def keys(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}}}},"FieldData":{"description":"This pointer points to a specific data field. `meshes` is passed to here\\nfor access of linked meshes.","methods":{"at_step":{"signature":"def at_step(self, *steps: \\"int\\") -> \\"np.ndarray\\":\\n    ...","description":"Direct access to data at step. Does not require the virtual dataset. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"steps","type":"int","default":null,"description":null}],"return":{"type":"np.ndarray","description":":class:`np.ndarray`"}},"datasets":{"signature":"def datasets(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"groups":{"signature":"def groups(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"keys":{"signature":"def keys(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"regenerate_virtual_datasets":{"signature":"def regenerate_virtual_datasets(self) -> \\"None\\":\\n    ...","description":"Regenerate virtual dataset. Call this if the data has changed, thus the virtual datasets need to be updated to cover the actual data.","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}}}}},"methods":{"with_file_open":{"signature":"def with_file_open(mode: \\"str\\" = \\"r\\", driver=None, comm=None):\\n    ...","description":"Open the file (`self._file`) before function Close the file after the function call  Works on classes containing the member `_file` of type :class:`~bamboost.common.file_handler.FileHandler`","arguments":[{"name":"mode","type":"str","default":"r","description":null},{"name":"driver","type":null,"default":"None","description":null},{"name":"comm","type":null,"default":"None","description":null}],"return":{"type":null,"description":null}}},"modules":{}},"meshes":{"description":null,"classes":{"Mesh":{"description":"Pointer to a location in an hdf5 file. The constructor takes a\\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\\nThe base class represents a generic group in the file\\n\\nArgs:\\n    file_handler: file this belongs to\\n    path_to_data: infile path to object","methods":{"datasets":{"signature":"def datasets(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"get_tuple":{"signature":"def get_tuple(self) -> \\"Tuple[np.ndarray, np.ndarray]\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"Tuple[np.ndarray, np.ndarray]","description":null}},"groups":{"signature":"def groups(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"keys":{"signature":"def keys(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}}}},"MeshGroup":{"description":"Pointer to a location in an hdf5 file. The constructor takes a\\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\\nThe base class represents a generic group in the file\\n\\nArgs:\\n    file_handler: file this belongs to\\n    path_to_data: infile path to object","methods":{"datasets":{"signature":"def datasets(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"groups":{"signature":"def groups(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"keys":{"signature":"def keys(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}}}}},"methods":{"with_file_open":{"signature":"def with_file_open(mode: \\"str\\" = \\"r\\", driver=None, comm=None):\\n    ...","description":"Open the file (`self._file`) before function Close the file after the function call  Works on classes containing the member `_file` of type :class:`~bamboost.common.file_handler.FileHandler`","arguments":[{"name":"mode","type":"str","default":"r","description":null},{"name":"driver","type":null,"default":"None","description":null},{"name":"comm","type":null,"default":"None","description":null}],"return":{"type":null,"description":null}}},"modules":{}}}},"common":{"description":null,"classes":{},"methods":{},"modules":{"file_handler":{"description":null,"classes":{"FileHandler":{"description":"File handler for an hdf5 file with the purpose of handling opening and closing\\nof the file. We use the concept of composition to include an object of this type\\nin classes which need access to an hdf5 file (such as the hdf5pointer and Simulation.)\\n\\nArgs:\\n    file_name: the path to the file\\n\\nAttributes:\\n    file_object: the h5py file object (accessible if open)\\n    _lock: lock is kind of a stack. `open` increases the stack. `close` decreases\\n        the stack. file_object is only closed if the stack is at 0. Ensures consecutive\\n        method calls works. Would be a problem if the file is closed after each\\n        sub-operation.\\n    _mode: file mode\\n    _driver: file driver\\n    _comm: MPI communicator","methods":{"change_file_mode":{"signature":"def change_file_mode(self, mode: \\"str\\", driver=None, comm=None):\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"mode","type":"str","default":null,"description":null},{"name":"driver","type":null,"default":"None","description":null},{"name":"comm","type":null,"default":"None","description":null}],"return":{"type":null,"description":null}},"close":{"signature":"def close(self):\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":null,"description":null}},"open":{"signature":"def open(self, mode: \\"str\\" = \\"r\\", driver=None, comm=None):\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"mode","type":"str","default":"r","description":null},{"name":"driver","type":null,"default":"None","description":null},{"name":"comm","type":null,"default":"None","description":null}],"return":{"type":null,"description":null}}}}},"methods":{"capture_key_error":{"signature":"def capture_key_error(method):\\n    ...","description":null,"arguments":[{"name":"method","type":null,"default":null,"description":null}],"return":{"type":null,"description":null}},"open_h5file":{"signature":"def open_h5file(file: \\"str\\", mode, driver=None, comm=None):\\n    ...","description":"Open h5 file. Waiting if file is not available. ","arguments":[{"name":"file","type":"str","default":null,"description":"File to open"},{"name":"mode","type":null,"default":null,"description":"\'r\', \'a\', \'w\', ..."},{"name":"driver","type":null,"default":"None","description":"driver for h5.File"},{"name":"comm","type":null,"default":"None","description":"MPI communicator"}],"return":{"type":null,"description":null}},"with_file_open":{"signature":"def with_file_open(mode: \\"str\\" = \\"r\\", driver=None, comm=None):\\n    ...","description":"Open the file (`self._file`) before function Close the file after the function call  Works on classes containing the member `_file` of type :class:`~bamboost.common.file_handler.FileHandler`","arguments":[{"name":"mode","type":"str","default":"r","description":null},{"name":"driver","type":null,"default":"None","description":null},{"name":"comm","type":null,"default":"None","description":null}],"return":{"type":null,"description":null}},"wraps":{"signature":"def wraps(\\n    wrapped,\\n    assigned=(\\"__module__\\", \\"__name__\\", \\"__qualname__\\", \\"__doc__\\", \\"__annotations__\\"),\\n    updated=(\\"__dict__\\",),\\n):\\n    ...","description":"Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments. Default arguments are as for update_wrapper(). This is a convenience function to simplify applying partial() to update_wrapper().","arguments":[{"name":"wrapped","type":null,"default":null,"description":null},{"name":"assigned","type":null,"default":"(\'__module__\', \'__name__\', \'__qualname__\', \'__doc__\', \'__annotations__\')","description":null},{"name":"updated","type":null,"default":"(\'__dict__\',)","description":null}],"return":{"type":null,"description":null}}},"modules":{}},"git_utility":{"description":null,"classes":{"GitStateGetter":{"description":null,"methods":{"create_git_string":{"signature":"def create_git_string(self) -> str:\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"<class \'str\'>","description":null}}}}},"methods":{},"modules":{}},"hdf_pointer":{"description":null,"classes":{"BasePointer":{"description":"Pointer to a location in an hdf5 file. The constructor takes a\\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\\nThe base class represents a generic group in the file\\n\\nArgs:\\n    file_handler: file this belongs to\\n    path_to_data: infile path to object","methods":{}},"Dataset":{"description":"Pointer to a location in an hdf5 file. The constructor takes a\\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\\nThe base class represents a generic group in the file\\n\\nArgs:\\n    file_handler: file this belongs to\\n    path_to_data: infile path to object","methods":{}},"Group":{"description":"Pointer to a location in an hdf5 file. The constructor takes a\\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\\nThe base class represents a generic group in the file\\n\\nArgs:\\n    file_handler: file this belongs to\\n    path_to_data: infile path to object","methods":{"datasets":{"signature":"def datasets(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"groups":{"signature":"def groups(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"keys":{"signature":"def keys(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}}}},"MutableGroup":{"description":"Used for the `userdata` group.","methods":{"add_dataset":{"signature":"def add_dataset(\\n    self, name: \\"str\\", vector: \\"np.ndarray\\", attrs: \\"dict\\" = None\\n) -> \\"None\\":\\n    ...","description":"Add a dataset to the group. Error is thrown if attempting to overwrite with different shape than before. If same shape, data is overwritten (this is inherited from h5py -> require_dataset)","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"name","type":"str","default":null,"description":"Name for the dataset"},{"name":"vector","type":"np.ndarray","default":null,"description":"Data to write (max 2d)"},{"name":"attrs","type":"dict","default":"None","description":"Optional. Attributes of dataset."}],"return":{"type":"None","description":null}},"datasets":{"signature":"def datasets(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"groups":{"signature":"def groups(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"keys":{"signature":"def keys(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"require_group":{"signature":"def require_group(self, name: \\"str\\") -> \\"Group\\":\\n    ...","description":"Add a new group to the current group. If exists, return existing. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"name","type":"str","default":null,"description":null}],"return":{"type":"Group","description":":class:`~bamboost.hdf_pointer.Group`"}},"update_attrs":{"signature":"def update_attrs(self, attrs: \\"dict\\") -> \\"None\\":\\n    ...","description":"Update the attributes of the group. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"attrs","type":"dict","default":null,"description":"the dictionary to write as attributes"}],"return":{"type":"None","description":null}}}}},"methods":{"with_file_open":{"signature":"def with_file_open(mode: \\"str\\" = \\"r\\", driver=None, comm=None):\\n    ...","description":"Open the file (`self._file`) before function Close the file after the function call  Works on classes containing the member `_file` of type :class:`~bamboost.common.file_handler.FileHandler`","arguments":[{"name":"mode","type":"str","default":"r","description":null},{"name":"driver","type":null,"default":"None","description":null},{"name":"comm","type":null,"default":"None","description":null}],"return":{"type":null,"description":null}}},"modules":{}},"job":{"description":null,"classes":{"Job":{"description":null,"methods":{"create_bash_script_local":{"signature":"def create_bash_script_local(\\n    self, commands: list, path: str, uid: str, ntasks: int = 4\\n):\\n    ...","description":"Write bash script for local execution. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"commands","type":"<class \'list\'>","default":null,"description":null},{"name":"path","type":"<class \'str\'>","default":null,"description":null},{"name":"uid","type":"<class \'str\'>","default":null,"description":null},{"name":"ntasks","type":"<class \'int\'>","default":"4","description":null}],"return":{"type":null,"description":null}},"create_sbatch_script":{"signature":"def create_sbatch_script(\\n    self,\\n    commands: list,\\n    path: str,\\n    uid: str = None,\\n    nnodes: int = 1,\\n    ntasks: int = 4,\\n    ncpus: int = 1,\\n    time: str = \\"04:00:00\\",\\n    mem_per_cpu: int = 2048,\\n    tmp: int = 8000,\\n) -> None:\\n    ...","description":"Write sbatch script for new simulation. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"commands","type":"<class \'list\'>","default":null,"description":null},{"name":"path","type":"<class \'str\'>","default":null,"description":null},{"name":"uid","type":"<class \'str\'>","default":"None","description":null},{"name":"nnodes","type":"<class \'int\'>","default":"1","description":null},{"name":"ntasks","type":"<class \'int\'>","default":"4","description":null},{"name":"ncpus","type":"<class \'int\'>","default":"1","description":null},{"name":"time","type":"<class \'str\'>","default":"04:00:00","description":null},{"name":"mem_per_cpu","type":"<class \'int\'>","default":"2048","description":null},{"name":"tmp","type":"<class \'int\'>","default":"8000","description":null}],"return":{"type":"None","description":null}}}}},"methods":{},"modules":{}},"utilities":{"description":"Utility functions used by bamboost.","classes":{},"methods":{"flatten_dict":{"signature":"def flatten_dict(dictionary, parent_key=\\"\\", seperator=\\".\\"):\\n    ...","description":null,"arguments":[{"name":"dictionary","type":null,"default":null,"description":null},{"name":"parent_key","type":null,"default":"","description":null},{"name":"seperator","type":null,"default":".","description":null}],"return":{"type":null,"description":null}},"h5_tree":{"signature":"def h5_tree(val, pre=\\"\\"):\\n    ...","description":null,"arguments":[{"name":"val","type":null,"default":null,"description":null},{"name":"pre","type":null,"default":"","description":null}],"return":{"type":null,"description":null}},"tree":{"signature":"def tree(\\n    dir_path: pathlib.Path,\\n    level: int = -1,\\n    limit_to_directories: bool = False,\\n    length_limit: int = 1000,\\n):\\n    ...","description":"Given a directory Path object print a visual tree structure ","arguments":[{"name":"dir_path","type":"<class \'pathlib.Path\'>","default":null,"description":null},{"name":"level","type":"<class \'int\'>","default":"-1","description":null},{"name":"limit_to_directories","type":"<class \'bool\'>","default":"False","description":null},{"name":"length_limit","type":"<class \'int\'>","default":"1000","description":null}],"return":{"type":null,"description":null}},"unflatten_dict":{"signature":"def unflatten_dict(dictionary, seperator=\\".\\"):\\n    ...","description":null,"arguments":[{"name":"dictionary","type":null,"default":null,"description":null},{"name":"seperator","type":null,"default":".","description":null}],"return":{"type":null,"description":null}}},"modules":{}}}},"index":{"description":"Module to manage the database index and its ID\'s.","classes":{},"methods":{"clean":{"signature":"def clean() -> \\"None\\":\\n    ...","description":"Clean the database index from wrong paths. ","arguments":[],"return":{"type":"None","description":null}},"create_index":{"signature":"def create_index() -> \\"None\\":\\n    ...","description":"Create database index from known paths. ","arguments":[],"return":{"type":"None","description":null}},"find":{"signature":"def find(uid, root_dir) -> \\"list\\":\\n    ...","description":"Find the database with UID under given root_dir. ","arguments":[{"name":"uid","type":null,"default":null,"description":"UID to search for"},{"name":"root_dir","type":null,"default":null,"description":"root directory for search"}],"return":{"type":"list","description":null}},"get_index_dict":{"signature":"def get_index_dict() -> \\"dict\\":\\n    ...","description":"Returns a dictionary of all known databases. ","arguments":[],"return":{"type":"dict","description":null}},"get_known_paths":{"signature":"def get_known_paths() -> \\"list\\":\\n    ...","description":null,"arguments":[],"return":{"type":"list","description":null}},"get_path":{"signature":"def get_path(uid: \\"str\\") -> \\"str\\":\\n    ...","description":"Find the path of a database specified by its UID. ","arguments":[{"name":"uid","type":"str","default":null,"description":"the UID of the database"}],"return":{"type":"str","description":null}},"get_uid_from_path":{"signature":"def get_uid_from_path(path: \\"str\\") -> \\"str\\":\\n    ...","description":"Returns the UID found in the specified path. ","arguments":[{"name":"path","type":"str","default":null,"description":null}],"return":{"type":"str","description":null}},"record_database":{"signature":"def record_database(uid: \\"str\\", path: \\"str\\") -> \\"None\\":\\n    ...","description":"Record a database in `database_index.json` ","arguments":[{"name":"uid","type":"str","default":null,"description":"the uid of the database"},{"name":"path","type":"str","default":null,"description":"the path of the database"}],"return":{"type":"None","description":null}},"uid2":{"signature":"def uid2(uid) -> \\"str\\":\\n    ...","description":null,"arguments":[{"name":"uid","type":null,"default":null,"description":null}],"return":{"type":"str","description":null}}},"modules":{}},"manager":{"description":null,"classes":{"Manager":{"description":"View of database.\\n\\nArgs:\\n    path (`str`): path to the directory of the database. If doesn\'t exist,\\n        a new database will be created.\\n    comm (`MPI.Comm`): MPI communicator\\n    uid: UID of the database\\n\\nAttributes:\\n    FIX_DF: If False, the dataframe of the database is reconstructed every\\n        time it is accessed.\\n    fromUID: Access a database by its UID\\n    fromName: Access a database by its path/name","methods":{"create_simulation":{"signature":"def create_simulation(\\n    self,\\n    uid: \\"str\\" = None,\\n    parameters: \\"dict\\" = None,\\n    skip_duplicate_check: \\"bool\\" = False,\\n) -> \\"SimulationWriter\\":\\n    ...","description":"Get a writer object for a new simulation. This is written for paralell use as it is likely that this may be used in an executable, creating multiple runs for a parametric space, which may be run in paralell.","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"uid","type":"str","default":"None","description":"The name/uid for the simulation. If not specified, a random id will be assigned."},{"name":"parameters","type":"dict","default":"None","description":"Parameter dictionary. If provided, the parameters will be checked against the existing sims for duplication. Otherwise, they may be specified later with :func:`~bamboost.simulation.SimulationWriter.add_parameters`."},{"name":"skip_duplicate_check","type":"bool","default":"False","description":"if True, the duplicate check is skipped."}],"return":{"type":"SimulationWriter","description":"sim (:class:`~bamboost.simulation.SimulationWriter`)"}},"get_parameters":{"signature":"def get_parameters(self) -> \\"dict\\":\\n    ...","description":"Get the parameters used in this database. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"dict","description":"Dictionary of parameters with it\'s count, range, and type. Sorted by count."}},"get_view":{"signature":"def get_view(self) -> \\"pd.DataFrame\\":\\n    ...","description":"View of the database and its parametric space. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"pd.DataFrame","description":":class:`pd.DataFrame`"}},"global_fields_in_all":{"signature":"def global_fields_in_all(self) -> \\"list\\":\\n    ...","description":"Get a list of all global fields in all simulations. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"list","description":"List of global fields"}},"remove":{"signature":"def remove(self, uid: \\"str\\") -> \\"None\\":\\n    ...","description":"CAUTION, DELETING DATA. Remove the data of a simulation. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"uid","type":"str","default":null,"description":"uid"}],"return":{"type":"None","description":null}},"sim":{"signature":"def sim(self, uid, return_writer: \\"bool\\" = False) -> \\"Simulation\\":\\n    ...","description":"Get an existing simulation with uid. Same as accessing with `db[uid]` directly. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"uid","type":null,"default":null,"description":"unique identifier"},{"name":"return_writer","type":"bool","default":"False","description":"if true, return `SimulationWriter`, otherwise return `Simulation`"}],"return":{"type":"Simulation","description":":class:`~bamboost.simulation.Simulation`"}},"sims":{"signature":"def sims(\\n    self,\\n    select: \\"pd.Series\\" = None,\\n    sort: \\"str\\" = None,\\n    reverse: \\"bool\\" = False,\\n    exclude: \\"set\\" = None,\\n    return_writer: \\"bool\\" = False,\\n) -> \\"list\\":\\n    ...","description":"Get all simulations in a list. Optionally, get all simulations matching the given selection using pandas.","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"select","type":"pd.Series","default":"None","description":"pandas boolean series"},{"name":"sort","type":"str","default":"None","description":"Optionally sort the list with this keyword"},{"name":"reverse","type":"bool","default":"False","description":"swap sort direction"},{"name":"exclude","type":"set","default":"None","description":"sims to exclude"},{"name":"return_writer","type":"bool","default":"False","description":"if true, return `SimulationWriter`, otherwise return `Simulation`"}],"return":{"type":"list","description":"A list of `:class:~bamboost.simulation.Simulation` objects"}}}}},"methods":{"open_h5file":{"signature":"def open_h5file(file: \\"str\\", mode, driver=None, comm=None):\\n    ...","description":"Open h5 file. Waiting if file is not available. ","arguments":[{"name":"file","type":"str","default":null,"description":"File to open"},{"name":"mode","type":null,"default":null,"description":"\'r\', \'a\', \'w\', ..."},{"name":"driver","type":null,"default":"None","description":"driver for h5.File"},{"name":"comm","type":null,"default":"None","description":"MPI communicator"}],"return":{"type":null,"description":null}}},"modules":{}},"simulation":{"description":null,"classes":{"Links":{"description":"Link group. Used to create and access links.\\n\\nI don\'t know how to distribute this to its own file in the accessors\\ndirectory, due to circular imports.","methods":{"add_dataset":{"signature":"def add_dataset(\\n    self, name: \\"str\\", vector: \\"np.ndarray\\", attrs: \\"dict\\" = None\\n) -> \\"None\\":\\n    ...","description":"Add a dataset to the group. Error is thrown if attempting to overwrite with different shape than before. If same shape, data is overwritten (this is inherited from h5py -> require_dataset)","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"name","type":"str","default":null,"description":"Name for the dataset"},{"name":"vector","type":"np.ndarray","default":null,"description":"Data to write (max 2d)"},{"name":"attrs","type":"dict","default":"None","description":"Optional. Attributes of dataset."}],"return":{"type":"None","description":null}},"all_links":{"signature":"def all_links(self) -> \\"dict\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"dict","description":null}},"datasets":{"signature":"def datasets(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"groups":{"signature":"def groups(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"keys":{"signature":"def keys(self) -> \\"set\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"set","description":null}},"require_group":{"signature":"def require_group(self, name: \\"str\\") -> \\"Group\\":\\n    ...","description":"Add a new group to the current group. If exists, return existing. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"name","type":"str","default":null,"description":null}],"return":{"type":"Group","description":":class:`~bamboost.hdf_pointer.Group`"}},"update_attrs":{"signature":"def update_attrs(self, attrs: \\"dict\\") -> \\"None\\":\\n    ...","description":"Update the attributes of the group. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"attrs","type":"dict","default":null,"description":"the dictionary to write as attributes"}],"return":{"type":"None","description":null}}}},"Simulation":{"description":"A single dataset/simulation. Used to write to it, read from it or append.\\n\\nArgs:\\n    uid (str): unique identifier\\n    path (str): path to parent/database folder\\n    comm (MPI.Comm): MPI communicator (default=MPI.COMM_WORLD)","methods":{"change_note":{"signature":"def change_note(self, note) -> \\"None\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"note","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"change_status":{"signature":"def change_status(self, status: \\"str\\") -> \\"None\\":\\n    ...","description":"Change status of simulation. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"status","type":"str","default":null,"description":"new status"}],"return":{"type":"None","description":null}},"create_batch_script":{"signature":"def create_batch_script(\\n    self,\\n    commands: \\"list\\" = None,\\n    nnodes=1,\\n    ntasks=4,\\n    ncpus=1,\\n    time=\\"04:00:00\\",\\n    mem_per_cpu=2048,\\n    tmp=8000,\\n    euler=True,\\n) -> \\"None\\":\\n    ...","description":"Create a batch job and put it into the folder. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"commands","type":"list","default":"None","description":"A list of strings being the user defined commands to run"},{"name":"nnodes","type":null,"default":"1","description":"nb of nodes (default=1)"},{"name":"ntasks","type":null,"default":"4","description":"nb of tasks (default=4)"},{"name":"ncpus","type":null,"default":"1","description":"nb of cpus per task (default=1)"},{"name":"time","type":null,"default":"04:00:00","description":"requested time (default=4 hours)"},{"name":"mem_per_cpu","type":null,"default":"2048","description":"memory (default=2048)"},{"name":"tmp","type":null,"default":"8000","description":"temporary storage, set None to exclude option (default=8000)"},{"name":"euler","type":null,"default":"True","description":"If false, a local bash script will be written"}],"return":{"type":"None","description":null}},"create_xdmf_file":{"signature":"def create_xdmf_file(self, fields: \\"list\\" = None, nb_steps: \\"int\\" = None) -> \\"None\\":\\n    ...","description":"Create the xdmf file to read in paraview. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"fields","type":"list","default":"None","description":"fields for which to write timeseries information, if not specified, all fields in data are written."},{"name":"nb_steps","type":"int","default":"None","description":"number of steps the simulation has"}],"return":{"type":"None","description":null}},"get_data_interpolator":{"signature":"def get_data_interpolator(self, field: \\"str\\", step: \\"int\\"):\\n    ...","description":"Get Linear interpolator for data field at step. Uses the linked mesh. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"field","type":"str","default":null,"description":null},{"name":"step","type":"int","default":null,"description":"step"}],"return":{"type":null,"description":":class:`scipy.interpolate.LinearNDInterpolator`"}},"get_full_uid":{"signature":"def get_full_uid(self) -> \\"str\\":\\n    ...","description":"Returns the full uid of the simulation (including the one of the database) ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"str","description":null}},"get_mesh":{"signature":"def get_mesh(self, mesh_name: \\"str\\" = None) -> \\"Tuple[np.ndarray, np.ndarray]\\":\\n    ...","description":"Return coordinates and connectivity. Currently returns numpy arrays. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"mesh_name","type":"str","default":"None","description":"optional, name of mesh to read (default = mesh)"}],"return":{"type":"Tuple[np.ndarray, np.ndarray]","description":"Tuple of np.arrays (coordinates, connectivity)"}},"open":{"signature":"def open(self, mode: \\"str\\" = \\"r\\", driver=None, comm=None) -> \\"FileHandler\\":\\n    ...","description":"Use this as a context manager in a `with` statement. Purpose: keeping the file open to directly access/edit something in the HDF5 file of this simulation.","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"mode","type":"str","default":"r","description":"file mode (see h5py docs)"},{"name":"driver","type":null,"default":"None","description":"file driver (see h5py docs)"},{"name":"comm","type":null,"default":"None","description":"mpi communicator"}],"return":{"type":"FileHandler","description":null}},"open_in_file_explorer":{"signature":"def open_in_file_explorer(self) -> \\"None\\":\\n    ...","description":"Open the simulation directory. Uses `xdg-open` on linux systems. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"show_files":{"signature":"def show_files(\\n    self, level=-1, limit_to_directories=False, length_limit=1000, printit=True\\n) -> \\"str\\":\\n    ...","description":"Show the file tree of the simulation directory. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"level","type":null,"default":"-1","description":"how deep to print the tree"},{"name":"limit_to_directories","type":null,"default":"False","description":"only print directories"},{"name":"length_limit","type":null,"default":"1000","description":"cutoff"},{"name":"printit","type":null,"default":"True","description":null}],"return":{"type":"str","description":null}},"show_h5tree":{"signature":"def show_h5tree(self) -> \\"None\\":\\n    ...","description":"Print the tree inside the h5 file. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"submit":{"signature":"def submit(self) -> \\"None\\":\\n    ...","description":"Submit the job for this simulation. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"update_metadata":{"signature":"def update_metadata(self, update_dict: \\"dict\\") -> \\"None\\":\\n    ...","description":"Update the metadata attributes. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"update_dict","type":"dict","default":null,"description":"dictionary to push"}],"return":{"type":"None","description":null}},"update_parameters":{"signature":"def update_parameters(self, update_dict: \\"dict\\") -> \\"None\\":\\n    ...","description":"Update the parameters dictionary. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"update_dict","type":"dict","default":null,"description":"dictionary to push"}],"return":{"type":"None","description":null}}}}},"methods":{"with_file_open":{"signature":"def with_file_open(mode: \\"str\\" = \\"r\\", driver=None, comm=None):\\n    ...","description":"Open the file (`self._file`) before function Close the file after the function call  Works on classes containing the member `_file` of type :class:`~bamboost.common.file_handler.FileHandler`","arguments":[{"name":"mode","type":"str","default":"r","description":null},{"name":"driver","type":null,"default":"None","description":null},{"name":"comm","type":null,"default":"None","description":null}],"return":{"type":null,"description":null}}},"modules":{}},"simulation_writer":{"description":null,"classes":{"SimulationWriter":{"description":"The SimulationWriter is the writer object for a single simulation. It inherits\\nall reading methods from :class:`Simulation`.\\n\\nArgs:\\n    uid: The identifier of the simulation\\n    path: The (parent) database path\\n    comm: An MPI communicator (Default: `MPI.COMM_WORLD`)","methods":{"add_additional":{"signature":"def add_additional(self, name: \\"str\\", file: \\"str\\") -> \\"None\\":\\n    ...","description":"Add an additional file stored elsewhere or in database directory. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"name","type":"str","default":null,"description":"Name of data"},{"name":"file","type":"str","default":null,"description":"filename of file"}],"return":{"type":"None","description":null}},"add_field":{"signature":"def add_field(\\n    self, name: \\"str\\", vector: \\"np.array\\", time: \\"float\\" = None, mesh: \\"str\\" = None\\n) -> \\"None\\":\\n    ...","description":"Add a dataset to the file. The data is stored at `data/`. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"name","type":"str","default":null,"description":"Name for the dataset"},{"name":"vector","type":"np.array","default":null,"description":"Dataset"},{"name":"time","type":"float","default":"None","description":"Optional. time"},{"name":"mesh","type":"str","default":"None","description":"Optional. Linked mesh for this data"}],"return":{"type":"None","description":null}},"add_global_field":{"signature":"def add_global_field(self, name: \\"str\\", value: \\"float\\") -> \\"None\\":\\n    ...","description":"Add a gobal field. These are stored at `gloals/` as an array in a single dataset.","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"name","type":"str","default":null,"description":"Name for the data"},{"name":"value","type":"float","default":null,"description":"Data"}],"return":{"type":"None","description":null}},"add_mesh":{"signature":"def add_mesh(\\n    self, coordinates: \\"np.ndarray\\", connectivity: \\"np.ndarray\\", mesh_name: \\"str\\" = None\\n) -> \\"None\\":\\n    ...","description":"Add the mesh to file. Currently only 2d meshes. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"coordinates","type":"np.ndarray","default":null,"description":"Coordinates as array (nb_nodes, dim)"},{"name":"connectivity","type":"np.ndarray","default":null,"description":"Connectivity matrix (nb_cells, nb nodes per cell)"},{"name":"mesh_name","type":"str","default":"None","description":"name for mesh (default = `mesh`)"}],"return":{"type":"None","description":null}},"add_metadata":{"signature":"def add_metadata(self) -> \\"None\\":\\n    ...","description":"Add metadata to h5 file. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"add_parameters":{"signature":"def add_parameters(self, parameters: \\"dict\\") -> \\"None\\":\\n    ...","description":"Add parameters to simulation. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"parameters","type":"dict","default":null,"description":"Dictionary with parameters."}],"return":{"type":"None","description":null}},"change_note":{"signature":"def change_note(self, note) -> \\"None\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"note","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"change_status":{"signature":"def change_status(self, status: \\"str\\") -> \\"None\\":\\n    ...","description":"Change status of simulation. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"status","type":"str","default":null,"description":"new status"}],"return":{"type":"None","description":null}},"copy_executable":{"signature":"def copy_executable(self, script_path: \\"str\\") -> \\"None\\":\\n    ...","description":"WILL BE REMOVED. USE COPY_FILE. Copy an executable to directory for reproducability.","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"script_path","type":"str","default":null,"description":"path to script"}],"return":{"type":"None","description":null}},"copy_file":{"signature":"def copy_file(self, source: \\"Union[str, list]\\", destination: \\"str\\" = \\"\\") -> \\"None\\":\\n    ...","description":"Copy a file to the datafolder. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"source","type":"Union[str, list]","default":null,"description":"path to file, or list of files"},{"name":"destination","type":"str","default":"","description":"destination (will create intermediatory directories)"}],"return":{"type":"None","description":null}},"create_batch_script":{"signature":"def create_batch_script(\\n    self,\\n    commands: \\"list\\" = None,\\n    nnodes=1,\\n    ntasks=4,\\n    ncpus=1,\\n    time=\\"04:00:00\\",\\n    mem_per_cpu=2048,\\n    tmp=8000,\\n    euler=True,\\n) -> \\"None\\":\\n    ...","description":"Create a batch job and put it into the folder. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"commands","type":"list","default":"None","description":"A list of strings being the user defined commands to run"},{"name":"nnodes","type":null,"default":"1","description":"nb of nodes (default=1)"},{"name":"ntasks","type":null,"default":"4","description":"nb of tasks (default=4)"},{"name":"ncpus","type":null,"default":"1","description":"nb of cpus per task (default=1)"},{"name":"time","type":null,"default":"04:00:00","description":"requested time (default=4 hours)"},{"name":"mem_per_cpu","type":null,"default":"2048","description":"memory (default=2048)"},{"name":"tmp","type":null,"default":"8000","description":"temporary storage, set None to exclude option (default=8000)"},{"name":"euler","type":null,"default":"True","description":"If false, a local bash script will be written"}],"return":{"type":"None","description":null}},"create_xdmf_file":{"signature":"def create_xdmf_file(self, fields: \\"list\\" = None, nb_steps: \\"int\\" = None) -> \\"None\\":\\n    ...","description":"Create the xdmf file to read in paraview. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"fields","type":"list","default":"None","description":"fields for which to write timeseries information, if not specified, all fields in data are written."},{"name":"nb_steps","type":"int","default":"None","description":"number of steps the simulation has"}],"return":{"type":"None","description":null}},"finish_sim":{"signature":"def finish_sim(self, status: \\"str\\" = \\"Finished\\") -> \\"None\\":\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"status","type":"str","default":"Finished","description":null}],"return":{"type":"None","description":null}},"finish_step":{"signature":"def finish_step(self) -> \\"None\\":\\n    ...","description":"Finish step. Adds 1 to the step counter. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"get_data_interpolator":{"signature":"def get_data_interpolator(self, field: \\"str\\", step: \\"int\\"):\\n    ...","description":"Get Linear interpolator for data field at step. Uses the linked mesh. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"field","type":"str","default":null,"description":null},{"name":"step","type":"int","default":null,"description":"step"}],"return":{"type":null,"description":":class:`scipy.interpolate.LinearNDInterpolator`"}},"get_full_uid":{"signature":"def get_full_uid(self) -> \\"str\\":\\n    ...","description":"Returns the full uid of the simulation (including the one of the database) ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"str","description":null}},"get_mesh":{"signature":"def get_mesh(self, mesh_name: \\"str\\" = None) -> \\"Tuple[np.ndarray, np.ndarray]\\":\\n    ...","description":"Return coordinates and connectivity. Currently returns numpy arrays. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"mesh_name","type":"str","default":"None","description":"optional, name of mesh to read (default = mesh)"}],"return":{"type":"Tuple[np.ndarray, np.ndarray]","description":"Tuple of np.arrays (coordinates, connectivity)"}},"initialize":{"signature":"def initialize(self) -> \\"SimulationWriter\\":\\n    ...","description":"Create a new file for this simlation. This deletes an existing h5 file of the simulation and creates an empty new one","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"SimulationWriter","description":null}},"open":{"signature":"def open(self, mode: \\"str\\" = \\"r\\", driver=None, comm=None) -> \\"FileHandler\\":\\n    ...","description":"Use this as a context manager in a `with` statement. Purpose: keeping the file open to directly access/edit something in the HDF5 file of this simulation.","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"mode","type":"str","default":"r","description":"file mode (see h5py docs)"},{"name":"driver","type":null,"default":"None","description":"file driver (see h5py docs)"},{"name":"comm","type":null,"default":"None","description":"mpi communicator"}],"return":{"type":"FileHandler","description":null}},"open_in_file_explorer":{"signature":"def open_in_file_explorer(self) -> \\"None\\":\\n    ...","description":"Open the simulation directory. Uses `xdg-open` on linux systems. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"register_git_attributes":{"signature":"def register_git_attributes(self, repo_path: \\"str\\" = \\"./\\") -> \\"None\\":\\n    ...","description":"Register git information for given repo. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"repo_path","type":"str","default":"./","description":"path to git repository"}],"return":{"type":"None","description":null}},"show_files":{"signature":"def show_files(\\n    self, level=-1, limit_to_directories=False, length_limit=1000, printit=True\\n) -> \\"str\\":\\n    ...","description":"Show the file tree of the simulation directory. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"level","type":null,"default":"-1","description":"how deep to print the tree"},{"name":"limit_to_directories","type":null,"default":"False","description":"only print directories"},{"name":"length_limit","type":null,"default":"1000","description":"cutoff"},{"name":"printit","type":null,"default":"True","description":null}],"return":{"type":"str","description":null}},"show_h5tree":{"signature":"def show_h5tree(self) -> \\"None\\":\\n    ...","description":"Print the tree inside the h5 file. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"submit":{"signature":"def submit(self) -> \\"None\\":\\n    ...","description":"Submit the job for this simulation. ","arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":"None","description":null}},"update_metadata":{"signature":"def update_metadata(self, update_dict: \\"dict\\") -> \\"None\\":\\n    ...","description":"Update the metadata attributes. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"update_dict","type":"dict","default":null,"description":"dictionary to push"}],"return":{"type":"None","description":null}},"update_parameters":{"signature":"def update_parameters(self, update_dict: \\"dict\\") -> \\"None\\":\\n    ...","description":"Update the parameters dictionary. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"update_dict","type":"dict","default":null,"description":"dictionary to push"}],"return":{"type":"None","description":null}}}}},"methods":{"flatten_dict":{"signature":"def flatten_dict(dictionary, parent_key=\\"\\", seperator=\\".\\"):\\n    ...","description":null,"arguments":[{"name":"dictionary","type":null,"default":null,"description":null},{"name":"parent_key","type":null,"default":"","description":null},{"name":"seperator","type":null,"default":".","description":null}],"return":{"type":null,"description":null}}},"modules":{}},"xdmf":{"description":null,"classes":{"XDMFWriter":{"description":"Write xdmf file for a subset of the stored data in the H5 file.\\n\\nArgs:\\n    filename (str): xdmf file path\\n    h5file (str): h5 file path","methods":{"add_timeseries":{"signature":"def add_timeseries(self, steps: int, fields: list):\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"steps","type":"<class \'int\'>","default":null,"description":null},{"name":"fields","type":"<class \'list\'>","default":null,"description":null}],"return":{"type":null,"description":null}},"write_attribute":{"signature":"def write_attribute(\\n    self, grid: xml.etree.ElementTree.Element, field_name: str, name: str, step: int\\n) -> None:\\n    ...","description":"Write an attribute/field. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"grid","type":"<class \'xml.etree.ElementTree.Element\'>","default":null,"description":null},{"name":"field_name","type":"<class \'str\'>","default":null,"description":null},{"name":"name","type":"<class \'str\'>","default":null,"description":null},{"name":"step","type":"<class \'int\'>","default":null,"description":null}],"return":{"type":"None","description":null}},"write_file":{"signature":"def write_file(self):\\n    ...","description":null,"arguments":[{"name":"self","type":null,"default":null,"description":null}],"return":{"type":null,"description":null}},"write_points_cells":{"signature":"def write_points_cells(self, points_location: str, cells_location: str):\\n    ...","description":"Write the mesh to the xdmf file. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"points_location","type":"<class \'str\'>","default":null,"description":null},{"name":"cells_location","type":"<class \'str\'>","default":null,"description":null}],"return":{"type":null,"description":null}},"write_step":{"signature":"def write_step(\\n    self, collection: xml.etree.ElementTree.Element, fields: list, step: int\\n):\\n    ...","description":"Write the data array for time t. ","arguments":[{"name":"self","type":null,"default":null,"description":null},{"name":"collection","type":"<class \'xml.etree.ElementTree.Element\'>","default":null,"description":null},{"name":"fields","type":"<class \'list\'>","default":null,"description":null},{"name":"step","type":"<class \'int\'>","default":null,"description":null}],"return":{"type":null,"description":null}}}}},"methods":{},"modules":{}}}');var i=n(6911),s=n(5893);const r=e=>0===Object.keys(e).length,a=e=>{let{name:t,parentName:n,props:l}=e,r=l.arguments;return(0,s.jsxs)("div",{className:"function",children:[(0,s.jsxs)("div",{className:"function-header",children:[(0,s.jsx)("h3",{id:t,children:(0,s.jsx)("span",{className:"function-header-title",children:t})}),(0,s.jsx)(i.Z,{language:"python",children:l.signature})]}),(0,s.jsxs)("p",{children:[(0,s.jsx)("b",{children:"Return:"})," [",l.return.type,"] - ",l.return.description]}),(0,s.jsx)("p",{children:l.description}),(0,s.jsxs)("table",{children:[(0,s.jsx)("thead",{children:(0,s.jsxs)("tr",{children:[(0,s.jsx)("th",{children:"Argument"}),(0,s.jsx)("th",{children:"Type"}),(0,s.jsx)("th",{children:"Description"}),(0,s.jsx)("th",{children:"Default"})]})}),r&&(0,s.jsx)("tbody",{children:r.map(((e,t)=>(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:e.name}),(0,s.jsx)("td",{children:e.type}),(0,s.jsx)("td",{children:e.description}),(0,s.jsx)("td",{children:e.default})]},`func_${t}`)))})]})]})},o=e=>{let{name:t,moduleName:n,obj:i}=e,r=i&&i.classes[t]||l[n].classes[t];return(0,s.jsxs)("div",{"data-search-children":!0,children:[(0,s.jsx)("h2",{id:t,className:"header-class",children:t}),r.methods&&Object.keys(r.methods).map(((e,n)=>{let l=r.methods[e];return(0,s.jsx)(a,{name:e,parentName:t,props:l},`class_${n}`)}))]})},d=e=>{let{moduleString:t}=e,n=t.split(".");console.log(n);let i=l[n[0]];for(let l=1;l<n.length;l++)i=i.modules[n[l]];return u({moduleName:n[n.length-1],parentModule:i})};function u(e){let{moduleName:t,parentModule:n}=e,i=n||l[t],d=i.classes,p=i.methods;return(0,s.jsxs)("div",{"data-search-children":!0,children:[(0,s.jsx)("ul",{children:!r(i.modules)&&Object.keys(i.modules).map(((e,t)=>(0,s.jsx)("li",{children:(0,s.jsx)("a",{href:`#${e}`,onClick:t=>{t.preventDefault(),document.querySelector(`#${e}`).scrollIntoView({behavior:"smooth"})},children:e})},`a1lk_${t}`)))}),!r(i.modules)&&Object.keys(i.modules).map(((e,t)=>(0,s.jsxs)("div",{children:[(0,s.jsx)("h2",{id:e,children:e}),(0,s.jsx)(u,{moduleName:e,parentModule:i.modules[e]},t)]},`b2l_${t}`))),(0,s.jsx)("div",{children:!r(d)&&Object.keys(d).map(((e,n)=>(0,s.jsx)(o,{name:e,moduleName:t,obj:i},`agi_${n}`)))}),(0,s.jsx)("div",{children:!r(p)&&Object.keys(p).map(((e,n)=>(0,s.jsx)(a,{name:e,parentName:t,props:p[e]},`oij_${n}`)))})]})}},8213:(e,t,n)=>{n.d(t,{o:()=>o});var l=n(7294),i=n(745),s=n(3935),r=n(5893);const a=e=>{let{headings:t,activeId:n}=e;return(0,r.jsx)("ul",{className:"custom-toc",children:t.map((e=>(0,r.jsxs)("li",{className:e.id===n?"active":"",children:[" ",(0,r.jsx)("a",{href:`#${e.id}`,onClick:t=>{t.preventDefault(),document.querySelector(`#${e.id}`).scrollIntoView({behavior:"smooth"})},children:e.title}),e.items.length>0&&(0,r.jsx)("ul",{children:e.items.map((e=>(0,r.jsxs)("li",{className:e.id===n?"active":"",children:[" ",(0,r.jsx)("a",{href:`#${e.id}`,onClick:t=>{t.preventDefault(),document.querySelector(`#${e.id}`).scrollIntoView({behavior:"smooth"})},children:e.title})]},e.id)))})]},e.id)))})},o=()=>{const[e,t]=(0,l.useState)(),{nestedHeadings:n}=(()=>{const[e,t]=(0,l.useState)([]);return(0,l.useEffect)((()=>{const e=(e=>{const t=[];return e.forEach(((e,n)=>{const{innerText:l,id:i}=e;"H2"===e.nodeName?t.push({id:i,title:l,items:[]}):"H3"===e.nodeName&&t.length>0&&t[t.length-1].items.push({id:i,title:l})})),t})(Array.from(document.querySelectorAll("h2, h3")));t(e)}),[]),{nestedHeadings:e}})(),[o,d]=(0,l.useState)(null);return(e=>{const t=(0,l.useRef)({});(0,l.useEffect)((()=>{const n=new IntersectionObserver((n=>{t.current=n.reduce(((e,t)=>(e[t.target.id]=t,e)),t.current);const i=[];Object.keys(t.current).forEach((e=>{const n=t.current[e];n.isIntersecting&&i.push(n)}));const s=e=>l.findIndex((t=>t.id===e));if(1===i.length)e(i[0].target.id);else if(i.length>1){const t=i.sort(((e,t)=>s(e.target.id)>s(t.target.id)));e(t[0].target.id)}}),{rootMargin:"0px 0px -40% 0px"}),l=Array.from(document.querySelectorAll("h2, h3"));return l.forEach((e=>n.observe(e))),()=>n.disconnect()}),[e])})(t),(0,l.useEffect)((()=>{const t=document.querySelector(".table-of-contents");t&&!o&&d((0,i.createRoot)(t)),t&&o&&setTimeout((()=>{(0,s.flushSync)((()=>{o.render((0,r.jsx)(a,{headings:n,activeId:e}))}))}),0)}),[n,e]),null}}}]);