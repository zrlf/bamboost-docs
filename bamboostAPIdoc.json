{
  "name": "bamboost",
  "slug": [
    "bamboost"
  ],
  "docstring": "",
  "short_description": "",
  "attributes": [
    {
      "name": "__author__",
      "annotation": null,
      "description": null,
      "default": "'florez@ethz.ch'"
    },
    {
      "name": "__copyright__",
      "annotation": null,
      "description": null,
      "default": "''"
    },
    {
      "name": "__license__",
      "annotation": null,
      "description": null,
      "default": "'LGPLv3'"
    },
    {
      "name": "BAMBOOST_LOGGER",
      "annotation": null,
      "description": null,
      "default": "<Logger bamboost (WARNING)>"
    }
  ],
  "classes": [],
  "functions": [
    {
      "name": "add_stream_handler",
      "docstring": "",
      "signature": "(logger: logging.Logger) -> None",
      "returns": {
        "annotation": null,
        "description": null
      },
      "arguments": {
        "logger": {
          "default": null,
          "annotation": "logging.Logger",
          "description": null
        }
      },
      "source": {
        "code": "def add_stream_handler(logger: logging.Logger) -> None:\n    stream_handler = logging.StreamHandler()\n    formatter = logging.Formatter(\n        \"[%(asctime)s] %(name)s: %(levelname)s - %(message)s\",\n        style=\"%\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n    stream_handler.setFormatter(formatter)\n    logger.addHandler(stream_handler)\n",
        "lines": [
          19,
          27
        ]
      },
      "props": {
        "isClassMethod": false
      },
      "examples": []
    },
    {
      "name": "set_log_level",
      "docstring": "",
      "signature": "(level: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']) -> None",
      "returns": {
        "annotation": null,
        "description": null
      },
      "arguments": {
        "level": {
          "default": null,
          "annotation": "Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']",
          "description": null
        }
      },
      "source": {
        "code": "def set_log_level(\n    level: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n) -> None:\n    BAMBOOST_LOGGER.setLevel(level)\n",
        "lines": [
          34,
          37
        ]
      },
      "props": {
        "isClassMethod": false
      },
      "examples": []
    }
  ],
  "submodules": [
    {
      "name": "accessors",
      "slug": [
        "bamboost",
        "accessors"
      ],
      "docstring": "",
      "short_description": "",
      "attributes": [],
      "classes": [],
      "functions": [],
      "submodules": [
        {
          "name": "meshes",
          "slug": [
            "bamboost",
            "accessors",
            "meshes"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [],
          "classes": [
            {
              "name": "MeshGroup",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "docstring": "",
                  "signature": "(self, key) -> bamboost.accessors.meshes.Mesh",
                  "returns": {
                    "annotation": "bamboost.accessors.meshes.Mesh",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef __getitem__(self, key) -> Mesh:\n    return Mesh(self._file, f\"{self.path_to_data}/{key}\")\n",
                    "lines": [
                      36,
                      38
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [],
              "inherits_from": {
                "bamboost.common.hdf_pointer.Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ],
                    [
                      "function",
                      "extract_attrs"
                    ]
                  ]
                },
                "bamboost.common.hdf_pointer.BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str = '/Mesh/0',\n    _default_mesh: str = 'mesh',\n    **kwargs\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "bamboost.common.file_handler.FileHandler",
                    "description": null
                  },
                  "path_to_data": {
                    "default": "/Mesh/0",
                    "annotation": "str",
                    "description": null
                  },
                  "_default_mesh": {
                    "default": "mesh",
                    "annotation": "str",
                    "description": null
                  },
                  "kwargs": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(\n    self,\n    file_handler: FileHandler,\n    path_to_data: str = \"/Mesh/0\",\n    _default_mesh: str = \"mesh\",\n    **kwargs,\n) -> None:\n    super().__init__(file_handler, path_to_data, **kwargs)\n    self._default_mesh = _default_mesh\n",
                  "lines": [
                    26,
                    34
                  ]
                }
              }
            },
            {
              "name": "Mesh",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "get_tuple": {
                  "name": "get_tuple",
                  "docstring": "",
                  "signature": "(self) -> Tuple[numpy.ndarray, numpy.ndarray]",
                  "returns": {
                    "annotation": "Tuple[numpy.ndarray, numpy.ndarray]",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef get_tuple(self) -> Tuple[np.ndarray, np.ndarray]:\n    return (self.coordinates, self.connectivity)\n",
                    "lines": [
                      58,
                      60
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [
                {
                  "name": "coordinates",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "connectivity",
                  "annotation": null,
                  "description": null,
                  "default": ""
                }
              ],
              "inherits_from": {
                "bamboost.common.hdf_pointer.Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ],
                    [
                      "function",
                      "extract_attrs"
                    ]
                  ]
                },
                "bamboost.common.hdf_pointer.BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "bamboost.common.file_handler.FileHandler",
                    "description": null
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n    super().__init__(file_handler, path_to_data)\n",
                  "lines": [
                    42,
                    43
                  ]
                }
              }
            }
          ],
          "functions": [],
          "submodules": [],
          "examples": [],
          "version": null
        },
        {
          "name": "fielddata",
          "slug": [
            "bamboost",
            "accessors",
            "fielddata"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [],
          "classes": [
            {
              "name": "DataGroup",
              "short_description": "This pointer points to the data directory. Item accessor returns the",
              "docstring": "This pointer points to the data directory. Item accessor returns the\nindividual data fields. `meshes` is passed to here for access of linked\nmeshes.",
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "docstring": "",
                  "signature": "(self, key) -> bamboost.accessors.fielddata.FieldData",
                  "returns": {
                    "annotation": "bamboost.accessors.fielddata.FieldData",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def __getitem__(self, key) -> FieldData:\n    return FieldData(self._file, f\"{self.path_to_data}/{key}\", meshes=self.meshes)\n",
                    "lines": [
                      47,
                      48
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "__iter__": {
                  "name": "__iter__",
                  "docstring": "",
                  "signature": "(\n    self\n) -> Generator[bamboost.accessors.fielddata.FieldData, NoneType, NoneType]",
                  "returns": {
                    "annotation": "Generator[bamboost.accessors.fielddata.FieldData, NoneType, NoneType]",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def __iter__(self) -> Generator[FieldData, None, None]:\n    for key in self.keys():\n        yield self.__getitem__(key)\n",
                    "lines": [
                      50,
                      52
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [
                {
                  "name": "meshes",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "info",
                  "annotation": "pandas.core.frame.DataFrame",
                  "description": "View the data stored.\n",
                  "default": ""
                }
              ],
              "inherits_from": {
                "bamboost.common.hdf_pointer.Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ],
                    [
                      "function",
                      "extract_attrs"
                    ]
                  ]
                },
                "bamboost.common.hdf_pointer.BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    meshes: bamboost.accessors.meshes.MeshGroup,\n    path_to_data: str = '/data',\n    **kwargs\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "bamboost.common.file_handler.FileHandler",
                    "description": null
                  },
                  "meshes": {
                    "default": null,
                    "annotation": "bamboost.accessors.meshes.MeshGroup",
                    "description": null
                  },
                  "path_to_data": {
                    "default": "/data",
                    "annotation": "str",
                    "description": null
                  },
                  "kwargs": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(\n    self,\n    file_handler: FileHandler,\n    meshes: MeshGroup,\n    path_to_data: str = \"/data\",\n    **kwargs,\n) -> None:\n    super().__init__(file_handler, path_to_data, **kwargs)\n    self.meshes = meshes\n",
                  "lines": [
                    37,
                    45
                  ]
                }
              }
            },
            {
              "name": "FieldData",
              "short_description": "This pointer points to a specific data field. `meshes` is passed to here",
              "docstring": "This pointer points to a specific data field. `meshes` is passed to here\nfor access of linked meshes.",
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "docstring": "",
                  "signature": "(self, key) -> numpy.ndarray",
                  "returns": {
                    "annotation": "numpy.ndarray",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef __getitem__(self, key) -> np.ndarray:\n    return self._get_full_data()[key]\n",
                    "lines": [
                      92,
                      94
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "__len__": {
                  "name": "__len__",
                  "docstring": "",
                  "signature": "(self) -> int",
                  "returns": {
                    "annotation": "int",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef __len__(self) -> int:\n    return len(self.datasets())\n",
                    "lines": [
                      113,
                      115
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "datasets": {
                  "name": "datasets",
                  "docstring": "",
                  "signature": "(self) -> set",
                  "returns": {
                    "annotation": "set",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef datasets(self) -> set:\n    return super().datasets() - {self._vds_key, self._times_key}\n",
                    "lines": [
                      117,
                      119
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "at_step": {
                  "name": "at_step",
                  "docstring": "Direct access to data at step. Does not require the virtual dataset.\n",
                  "signature": "(self, *steps: int) -> numpy.ndarray",
                  "returns": {
                    "annotation": "numpy.ndarray",
                    "description": ":class:`np.ndarray`"
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "steps": {
                      "default": null,
                      "annotation": "int",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open()\ndef at_step(self, *steps: int) -> np.ndarray:\n    \"\"\"Direct access to data at step. Does not require the virtual dataset.\n\n    Args:\n        step0, step1, ...: step to extract (can be multiple)\n    Returns:\n        :class:`np.ndarray`\n    \"\"\"\n    data = list()\n    for step in steps:\n        if step < 0:\n            step = len(self) + step\n        data.append(self.obj[str(step)][()])\n    if len(data) <= 1:\n        return data[0]\n    else:\n        return data\n",
                    "lines": [
                      131,
                      148
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "regenerate_virtual_datasets": {
                  "name": "regenerate_virtual_datasets",
                  "docstring": "Regenerate virtual dataset. Call this if the data has changed, thus the\nvirtual datasets need to be updated to cover the actual data.",
                  "signature": "(self) -> None",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def regenerate_virtual_datasets(self) -> None:\n    \"\"\"Regenerate virtual dataset. Call this if the data has changed, thus the\n    virtual datasets need to be updated to cover the actual data.\n    \"\"\"\n    self._create_times()\n    self._create_vds()\n",
                    "lines": [
                      192,
                      197
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [
                {
                  "name": "meshes",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "shape",
                  "annotation": "tuple",
                  "description": null,
                  "default": ""
                },
                {
                  "name": "dtype",
                  "annotation": "type",
                  "description": null,
                  "default": ""
                },
                {
                  "name": "times",
                  "annotation": "numpy.ndarray",
                  "description": "Return the array of timestamps.\n",
                  "default": ""
                },
                {
                  "name": "mesh",
                  "annotation": "bamboost.accessors.meshes.Mesh",
                  "description": "Return the linked mesh. Currently returns the linked mesh of first step only.\n",
                  "default": ""
                },
                {
                  "name": "coordinates",
                  "annotation": "numpy.ndarray",
                  "description": "Wrapper for mesh.coordinates",
                  "default": ""
                },
                {
                  "name": "connectivity",
                  "annotation": "numpy.ndarray",
                  "description": "Wrapper for mesh.connectivity",
                  "default": ""
                },
                {
                  "name": "msh",
                  "annotation": "Tuple[numpy.ndarray, numpy.ndarray]",
                  "description": "Wrapper to get mesh as tuple",
                  "default": ""
                }
              ],
              "inherits_from": {
                "bamboost.common.hdf_pointer.Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "extract_attrs"
                    ]
                  ]
                },
                "bamboost.common.hdf_pointer.BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str,\n    meshes: bamboost.accessors.meshes.MeshGroup\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "bamboost.common.file_handler.FileHandler",
                    "description": null
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  },
                  "meshes": {
                    "default": null,
                    "annotation": "bamboost.accessors.meshes.MeshGroup",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(\n    self, file_handler: FileHandler, path_to_data: str, meshes: MeshGroup\n) -> None:\n    super().__init__(file_handler, path_to_data)\n    self.meshes = meshes\n    self._name = path_to_data.split(\"/\")[-1]\n",
                  "lines": [
                    85,
                    90
                  ]
                }
              }
            }
          ],
          "functions": [],
          "submodules": [],
          "examples": [],
          "version": null
        },
        {
          "name": "globals",
          "slug": [
            "bamboost",
            "accessors",
            "globals"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [],
          "classes": [
            {
              "name": "GlobalGroup",
              "short_description": "Enhanced Group for '/globals'.",
              "docstring": "Enhanced Group for '/globals'.\n",
              "methods": {},
              "properties": [
                {
                  "name": "df",
                  "annotation": "pandas.core.frame.DataFrame",
                  "description": "Return a pandas DataFrame with all datasets.",
                  "default": ""
                }
              ],
              "inherits_from": {
                "bamboost.common.hdf_pointer.Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ],
                    [
                      "function",
                      "extract_attrs"
                    ]
                  ]
                },
                "bamboost.common.hdf_pointer.BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "bamboost.common.file_handler.FileHandler",
                    "description": null
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n    super().__init__(file_handler, path_to_data)\n",
                  "lines": [
                    29,
                    30
                  ]
                }
              }
            }
          ],
          "functions": [],
          "submodules": [],
          "examples": [],
          "version": null
        }
      ],
      "examples": [],
      "version": null
    },
    {
      "name": "common",
      "slug": [
        "bamboost",
        "common"
      ],
      "docstring": "",
      "short_description": "",
      "attributes": [],
      "classes": [],
      "functions": [],
      "submodules": [
        {
          "name": "file_handler",
          "slug": [
            "bamboost",
            "common",
            "file_handler"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [
            {
              "name": "HAS_MPIO",
              "annotation": null,
              "description": null,
              "default": "True"
            },
            {
              "name": "MPI_ACTIVE",
              "annotation": null,
              "description": null,
              "default": "False"
            },
            {
              "name": "FILE_MODE_HIRARCHY",
              "annotation": null,
              "description": null,
              "default": "{'r': 1, 'r+': 2, 'a': 2, 'w': 3}"
            }
          ],
          "classes": [
            {
              "name": "FileHandler",
              "short_description": "File handler for an hdf5 file with the purpose of handling opening and closing",
              "docstring": "File handler for an hdf5 file with the purpose of handling opening and closing\nof the file. We use the concept of composition to include an object of this type\nin classes which need access to an hdf5 file (such as the hdf5pointer and Simulation.)",
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "docstring": "",
                  "signature": "(self, key) -> Any",
                  "returns": {
                    "annotation": "Any",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@capture_key_error\ndef __getitem__(self, key) -> Any:\n    return self.file_object[key]\n",
                    "lines": [
                      142,
                      144
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "open": {
                  "name": "open",
                  "docstring": "",
                  "signature": "(self, mode: str = 'r', driver=None, comm=None)",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "mode": {
                      "default": "r",
                      "annotation": "str",
                      "description": null
                    },
                    "driver": {
                      "default": "None",
                      "annotation": null,
                      "description": null
                    },
                    "comm": {
                      "default": "None",
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def open(self, mode: str = \"r\", driver=None, comm=None):\n    if self._lock <= 0:\n        log.debug(f\"[{id(self)}] Open {self.file_name}\")\n        self.file_object = open_h5file(self.file_name, mode, driver, comm)\n\n    if FILE_MODE_HIRARCHY[self.file_object.mode] < FILE_MODE_HIRARCHY[mode]:\n        self.change_file_mode(mode, driver, comm)\n\n    log.debug(f\"[{id(self)}] Lock stack {self._lock}\")\n    self._lock += 1\n    return self.file_object\n",
                    "lines": [
                      164,
                      174
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "close": {
                  "name": "close",
                  "docstring": "",
                  "signature": "(self)",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def close(self):\n    self._lock -= 1\n    if self._lock == 0:\n        log.debug(f\"[{id(self)}] Close {self.file_name}\")\n        self.file_object.close()\n    log.debug(f\"[{id(self)}] Lock stack {self._lock}\")\n",
                    "lines": [
                      176,
                      181
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "change_file_mode": {
                  "name": "change_file_mode",
                  "docstring": "",
                  "signature": "(self, mode: str, driver=None, comm=None)",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "mode": {
                      "default": null,
                      "annotation": "str",
                      "description": null
                    },
                    "driver": {
                      "default": "None",
                      "annotation": null,
                      "description": null
                    },
                    "comm": {
                      "default": "None",
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def change_file_mode(self, mode: str, driver=None, comm=None):\n    log.info(\n        f\"Forced closing and reopening to change file mode [{self.file_name}].\"\n    )\n    self.file_object.close()\n    self.file_object = open_h5file(self.file_name, mode, driver, comm)\n",
                    "lines": [
                      183,
                      188
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [
                {
                  "name": "file_object",
                  "annotation": "h5py._hl.files.File",
                  "description": null,
                  "default": ""
                },
                {
                  "name": "file_name",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "simulation_uid",
                  "annotation": null,
                  "description": null,
                  "default": ""
                }
              ],
              "inherits_from": {},
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_name: str,\n    _comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_name": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  },
                  "_comm": {
                    "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x7010845dcad0>",
                    "annotation": "bamboost.common._mock_mpi.MockMPI.Comm",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(\n    self, file_name: str, _comm: mpi.MPI.Comm = mpi.MPI.COMM_WORLD\n) -> None:\n    self.file_object: h5py.File = None\n    self.file_name = file_name\n    self.simulation_uid = os.path.basename(file_name)\n    self._lock = 0\n    self._mode = \"r\"\n    self._driver = None\n    self._comm = _comm\n",
                  "lines": [
                    122,
                    131
                  ]
                }
              }
            }
          ],
          "functions": [
            {
              "name": "open_h5file",
              "docstring": "Open h5 file. Waiting if file is not available.\n",
              "signature": "(\n    file: str,\n    mode: Union[Literal['mpio'], Type[NoneType]],\n    driver: Union[bool, Type[NoneType]] = None,\n    comm=None\n)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "file": {
                  "default": null,
                  "annotation": "str",
                  "description": "File to open"
                },
                "mode": {
                  "default": null,
                  "annotation": "Union[Literal['mpio'], Type[NoneType]]",
                  "description": "'r', 'a', 'w', ..."
                },
                "driver": {
                  "default": "None",
                  "annotation": "Union[bool, Type[NoneType]]",
                  "description": "driver for h5.File"
                },
                "comm": {
                  "default": "None",
                  "annotation": null,
                  "description": "MPI communicator"
                }
              },
              "source": {
                "code": "def open_h5file(\n    file: str,\n    mode: Literal[\"mpio\"] | Type[None],\n    driver: bool | Type[None] = None,\n    comm=None,\n):\n    \"\"\"Open h5 file. Waiting if file is not available.\n\n    Args:\n        file (str): File to open\n        mode (str): 'r', 'a', 'w', ...\n        driver (str): driver for h5.File\n        comm: MPI communicator\n    \"\"\"\n    while True:\n        try:\n            if driver == \"mpio\" and MPI_ACTIVE and mpi.MPI_ON:\n                return h5py.File(file, mode, driver=driver, comm=comm)\n            else:\n                return h5py.File(file, mode)\n\n        except BlockingIOError:\n            log.warning(f\"file locked --> {file}\")\n            time.sleep(0.2)\n",
                "lines": [
                  47,
                  70
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "with_file_open",
              "docstring": "Open the file (`self._file`) before function\nClose the file after the function call\n\nWorks on classes containing the member `_file` of type :class:`~bamboost.common.file_handler.FileHandler`",
              "signature": "(mode: str = 'r', driver=None, comm=None)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "mode": {
                  "default": "r",
                  "annotation": "str",
                  "description": null
                },
                "driver": {
                  "default": "None",
                  "annotation": null,
                  "description": null
                },
                "comm": {
                  "default": "None",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def with_file_open(mode: str = \"r\", driver=None, comm=None):\n    \"\"\"Open the file (`self._file`) before function\n    Close the file after the function call\n\n    Works on classes containing the member `_file` of type :class:`~bamboost.common.file_handler.FileHandler`\n    \"\"\"\n\n    def decorator(method):\n        @wraps(method)\n        def wrapper(self, *args, **kwargs):\n            with self._file(mode, driver, comm):\n                return method(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n",
                "lines": [
                  73,
                  88
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "capture_key_error",
              "docstring": "",
              "signature": "(method)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "method": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def capture_key_error(method):\n    @wraps(method)\n    def inner(self, *args, **kwargs):\n        try:\n            return method(self, *args, **kwargs)\n        except KeyError as e:\n            e.add_note(f\"[file: {self.file_name}]\")\n            raise e\n\n    return inner\n",
                "lines": [
                  91,
                  100
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          ],
          "submodules": [],
          "examples": [],
          "version": null
        },
        {
          "name": "utilities",
          "slug": [
            "bamboost",
            "common",
            "utilities"
          ],
          "docstring": "Utility functions used by bamboost.",
          "short_description": "Utility functions used by bamboost.",
          "attributes": [],
          "classes": [],
          "functions": [
            {
              "name": "flatten_dict",
              "docstring": "",
              "signature": "(dictionary, parent_key='', seperator='.')",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "dictionary": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "parent_key": {
                  "default": "",
                  "annotation": null,
                  "description": null
                },
                "seperator": {
                  "default": ".",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def flatten_dict(dictionary, parent_key=\"\", seperator=\".\"):\n    items = []\n    for key, value in dictionary.items():\n        new_key = parent_key + seperator + key if parent_key else key\n        if isinstance(value, MutableMapping):\n            items.extend(flatten_dict(value, new_key, seperator=seperator).items())\n        else:\n            items.append((new_key, value))\n    return dict(items)\n",
                "lines": [
                  36,
                  44
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "unflatten_dict",
              "docstring": "",
              "signature": "(dictionary, seperator='.')",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "dictionary": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "seperator": {
                  "default": ".",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def unflatten_dict(dictionary, seperator=\".\"):\n    new_dict = dict()\n    for key, value in dictionary.items():\n        parts = key.split(seperator)\n        d = new_dict\n        for part in parts[:-1]:\n            if part not in d:\n                d[part] = dict()\n            d = d[part]\n        d[parts[-1]] = value\n    return new_dict\n",
                "lines": [
                  47,
                  57
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "tree",
              "docstring": "Given a directory Path object print a visual tree structure",
              "signature": "(\n    dir_path: pathlib.Path,\n    level: int = -1,\n    limit_to_directories: bool = False,\n    length_limit: int = 1000\n)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "dir_path": {
                  "default": null,
                  "annotation": "pathlib.Path",
                  "description": null
                },
                "level": {
                  "default": "-1",
                  "annotation": "int",
                  "description": null
                },
                "limit_to_directories": {
                  "default": "False",
                  "annotation": "bool",
                  "description": null
                },
                "length_limit": {
                  "default": "1000",
                  "annotation": "int",
                  "description": null
                }
              },
              "source": {
                "code": "def tree(\n    dir_path: Path,\n    level: int = -1,\n    limit_to_directories: bool = False,\n    length_limit: int = 1000,\n):\n    \"\"\"Given a directory Path object print a visual tree structure\"\"\"\n    dir_path = Path(dir_path)  # accept string coerceable to Path\n    files = 0\n    directories = 0\n    folder_symbol = \"\\U00002b57 \"\n\n    def inner(dir_path: Path, prefix: str = \"\", level=-1):\n        nonlocal files, directories\n        if not level:\n            return  # 0, stop iterating\n        if limit_to_directories:\n            contents = [d for d in dir_path.iterdir() if d.is_dir()]\n        else:\n            contents = list(dir_path.iterdir())\n        pointers = [tee] * (len(contents) - 1) + [last]\n        for pointer, path in zip(pointers, contents):\n            if path.is_dir():\n                yield prefix + pointer + \"\\U000025cc \" + path.name\n                directories += 1\n                extension = branch if pointer == tee else space\n                yield from inner(path, prefix=prefix + extension, level=level - 1)\n            elif not limit_to_directories:\n                yield prefix + pointer + path.name\n                files += 1\n\n    tree_string = \"\"\n    tree_string += (folder_symbol + dir_path.name) + \"\\n\"\n    iterator = inner(dir_path, level=level)\n    for line in islice(iterator, length_limit):\n        tree_string += (line) + \"\\n\"\n    if next(iterator, None):\n        tree_string += (f\"... length_limit, {length_limit}, reached, counted:\") + \"\\n\"\n    tree_string += (\n        f\"\\n{directories} directories\" + (f\", {files} files\" if files else \"\")\n    ) + \"\\n\"\n    return tree_string\n",
                "lines": [
                  61,
                  102
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "h5_tree",
              "docstring": "",
              "signature": "(val, pre='')",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "val": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "pre": {
                  "default": "",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def h5_tree(val, pre=\"\"):\n    items = len(val)\n    for key, val in val.items():\n        items -= 1\n        if items == 0:\n            # the last item\n            if type(val) == h5py._hl.group.Group:\n                print(pre + \"\u2514\u2500\u2500 \" + key)\n                h5_tree(val, pre + \"    \")\n            else:\n                print(pre + \"\u2514\u2500\u2500 \" + key + \" (%d)\" % len(val))\n        else:\n            if type(val) == h5py._hl.group.Group:\n                print(pre + \"\u251c\u2500\u2500 \" + key)\n                h5_tree(val, pre + \"\u2502   \")\n            else:\n                print(pre + \"\u251c\u2500\u2500 \" + key + \" (%d)\" % len(val))\n",
                "lines": [
                  105,
                  121
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "show_differences",
              "docstring": "This function takes a pandas DataFrame as input and returns a modified\nDataFrame that shows only the columns which have differences.\n\nThe function first creates a copy of the input DataFrame to work with. It\nthen iterates over each column in the DataFrame and tries to calculate the\nnumber of unique values in that column. If successful, it adds the column\nname and number of unique values to a list of good results. If there is an\nerror, it attempts to apply json.dumps to the column and then calculate the\nnumber of unique values again. If this is successful, it also adds the\ncolumn name and number of unique values to the list of good results. If\nthere is still an error, it adds the column name and the error to a list of\nerrors.\n\nAfter processing all columns, the function removes any columns that had\nerrors from the DataFrame. It then sets the index of the DataFrame to 'id'\nand filters out any columns that have only one unique value. The modified\nDataFrame is then returned.",
              "signature": "(df: pandas.core.frame.DataFrame) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "pandas.core.frame.DataFrame",
                "description": "pd.DataFrame"
              },
              "arguments": {
                "df": {
                  "default": null,
                  "annotation": "pandas.core.frame.DataFrame",
                  "description": "The input DataFrame to analyze"
                }
              },
              "source": {
                "code": "def show_differences(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"This function takes a pandas DataFrame as input and returns a modified\n    DataFrame that shows only the columns which have differences.\n\n    The function first creates a copy of the input DataFrame to work with. It\n    then iterates over each column in the DataFrame and tries to calculate the\n    number of unique values in that column. If successful, it adds the column\n    name and number of unique values to a list of good results. If there is an\n    error, it attempts to apply json.dumps to the column and then calculate the\n    number of unique values again. If this is successful, it also adds the\n    column name and number of unique values to the list of good results. If\n    there is still an error, it adds the column name and the error to a list of\n    errors.\n\n    After processing all columns, the function removes any columns that had\n    errors from the DataFrame. It then sets the index of the DataFrame to 'id'\n    and filters out any columns that have only one unique value. The modified\n    DataFrame is then returned.\n\n    Args:\n        df (pd.DataFrame): The input DataFrame to analyze\n\n    Returns:\n        pd.DataFrame\n    \"\"\"\n    import json\n\n    df_diff = df.copy()\n    cols_nunique_good = []\n    cols_nunique_error = []\n    for col in df_diff.columns:\n        try:\n            nunique = df_diff[col].nunique()\n            cols_nunique_good.append((col, nunique))\n        except Exception:\n            try:\n                df_diff[col] = df_diff[col].apply(json.dumps)\n                nunique = df_diff[col].nunique()\n                cols_nunique_good.append((col, nunique))\n            except TypeError as e:\n                cols_nunique_error.append((col, e))\n\n    df_diff = df_diff[\n        df_diff.columns[~df_diff.columns.isin([col for col, _ in cols_nunique_error])]\n    ]\n    try:\n        df_diff.set_index(\"id\", inplace=True)\n    except KeyError:\n        pass\n    df_diff = df_diff.loc[:, (df_diff.nunique() != 1)]\n    df_diff.dropna(axis=1, how=\"all\", inplace=True)\n    return df_diff\n",
                "lines": [
                  124,
                  175
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "to_camel_case",
              "docstring": "",
              "signature": "(s: str) -> str",
              "returns": {
                "annotation": "str",
                "description": null
              },
              "arguments": {
                "s": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "def to_camel_case(s: str) -> str:\n    words = s.split()\n    camel_case = words[0].lower() + \"\".join([word.capitalize() for word in words[1:]])\n    return camel_case\n",
                "lines": [
                  178,
                  181
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          ],
          "submodules": [],
          "examples": [],
          "version": null
        },
        {
          "name": "git_utility",
          "slug": [
            "bamboost",
            "common",
            "git_utility"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [],
          "classes": [
            {
              "name": "GitStateGetter",
              "short_description": "",
              "docstring": "",
              "methods": {
                "create_git_string": {
                  "name": "create_git_string",
                  "docstring": "",
                  "signature": "(self) -> str",
                  "returns": {
                    "annotation": "str",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def create_git_string(self) -> str:\n    self.string = \"\"\n\n    self.string += \"\\n\"\n    self.string += \"----- REMOTE ------ \\n\"\n    self.string += self._git_command(\"git remote -v\")\n\n    self.string += \"\\n\"\n    self.string += \"----- BRANCH ------ \\n\"\n    self.string += self._git_command(\"git branch -v\")\n\n    self.string += \"\\n\"\n    self.string += \"----- LAST COMMIT ------ \\n\"\n    self.string += self._git_command(\"git rev-parse HEAD\")\n\n    self.string += \"\\n\"\n    self.string += \"----- STATUS ------ \\n\"\n    self.string += self._git_command(\"git status\")\n\n    self.string += \"\\n\"\n    self.string += \"----- DIFFERENCE ------ \\n\"\n    self.string += self._git_command(\"git diff HEAD\")\n\n    return self.string\n",
                    "lines": [
                      30,
                      53
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [],
              "inherits_from": {},
              "examples": [],
              "constructor": {
                "signature": "(self)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(self) -> None:\n    pass\n",
                  "lines": [
                    16,
                    17
                  ]
                }
              }
            }
          ],
          "functions": [],
          "submodules": [],
          "examples": [],
          "version": null
        },
        {
          "name": "hdf_pointer",
          "slug": [
            "bamboost",
            "common",
            "hdf_pointer"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [],
          "classes": [
            {
              "name": "BasePointer",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "new_pointer": {
                  "name": "new_pointer",
                  "docstring": "Returns a new pointer object.",
                  "signature": "(\n    cls,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n) -> bamboost.common.hdf_pointer.BasePointer",
                  "returns": {
                    "annotation": "bamboost.common.hdf_pointer.BasePointer",
                    "description": null
                  },
                  "arguments": {
                    "cls": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "file_handler": {
                      "default": null,
                      "annotation": "bamboost.common.file_handler.FileHandler",
                      "description": null
                    },
                    "path_to_data": {
                      "default": null,
                      "annotation": "str",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@classmethod\ndef new_pointer(cls, file_handler: FileHandler, path_to_data: str) -> BasePointer:\n    \"\"\"Returns a new pointer object.\"\"\"\n    with file_handler(\"r\") as f:\n        obj = f.file_object[path_to_data]\n        if isinstance(obj, h5py.Group):\n            if issubclass(cls, Group):\n                return cls(file_handler, path_to_data)\n            else:\n                return Group(file_handler, path_to_data)\n        elif isinstance(obj, h5py.Dataset):\n            return Dataset(file_handler, path_to_data)\n        else:\n            return BasePointer(file_handler, path_to_data)\n",
                    "lines": [
                      42,
                      55
                    ]
                  },
                  "props": {
                    "isClassMethod": true
                  },
                  "examples": []
                },
                "__getitem__": {
                  "name": "__getitem__",
                  "docstring": "",
                  "signature": "(self, key)",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef __getitem__(self, key):\n    new_path = f\"{self.path_to_data}/{key}\"\n    return self.new_pointer(self._file, new_path)\n",
                    "lines": [
                      85,
                      88
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [
                {
                  "name": "path_to_data",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "obj",
                  "annotation": null,
                  "description": "The object this BasePointer points to. File needs to be open for access.",
                  "default": ""
                },
                {
                  "name": "attrs",
                  "annotation": null,
                  "description": null,
                  "default": ""
                }
              ],
              "inherits_from": {},
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "bamboost.common.file_handler.FileHandler",
                    "description": null
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n    self._file = file_handler\n    self.path_to_data = path_to_data\n",
                  "lines": [
                    57,
                    59
                  ]
                }
              }
            },
            {
              "name": "Group",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "__iter__": {
                  "name": "__iter__",
                  "docstring": "",
                  "signature": "(self)",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def __iter__(self):\n    for key in self.keys():\n        yield self.__getitem__(key)\n",
                    "lines": [
                      103,
                      105
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "keys": {
                  "name": "keys",
                  "docstring": "",
                  "signature": "(self) -> set",
                  "returns": {
                    "annotation": "set",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef keys(self) -> set:\n    return set(self.obj.keys())\n",
                    "lines": [
                      107,
                      109
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "groups": {
                  "name": "groups",
                  "docstring": "",
                  "signature": "(self) -> set",
                  "returns": {
                    "annotation": "set",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef groups(self) -> set:\n    return {key for key in self.keys() if isinstance(self.obj[key], h5py.Group)}\n",
                    "lines": [
                      111,
                      113
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "datasets": {
                  "name": "datasets",
                  "docstring": "",
                  "signature": "(self) -> set",
                  "returns": {
                    "annotation": "set",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef datasets(self) -> set:\n    return {key for key in self.keys() if isinstance(self.obj[key], h5py.Dataset)}\n",
                    "lines": [
                      115,
                      117
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "extract_attrs": {
                  "name": "extract_attrs",
                  "docstring": "Extract the attributes of all members of the group.\n",
                  "signature": "(self, variant: Literal['group', 'dataset', 'all'] = 'all') -> dict",
                  "returns": {
                    "annotation": "dict",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "variant": {
                      "default": "all",
                      "annotation": "Literal['group', 'dataset', 'all']",
                      "description": "one of 'group', 'dataset', 'all'"
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef extract_attrs(\n    self, variant: Literal[\"group\", \"dataset\", \"all\"] = \"all\"\n) -> dict:\n    \"\"\"Extract the attributes of all members of the group.\n\n    Args:\n        variant: one of 'group', 'dataset', 'all'\n    \"\"\"\n    if variant == \"group\":\n        keys = self.groups()\n    elif variant == \"dataset\":\n        keys = self.datasets()\n    elif variant == \"all\":\n        keys = self.keys()\n    else:\n        raise ValueError(\"variant must be one of 'group', 'dataset', 'all'\")\n\n    attrs = {}\n    for key in keys:\n        attrs[key] = dict(self.obj[key].attrs)\n    return attrs\n",
                    "lines": [
                      119,
                      140
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [],
              "inherits_from": {
                "bamboost.common.hdf_pointer.BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "bamboost.common.file_handler.FileHandler",
                    "description": null
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n    super().__init__(file_handler, path_to_data)\n",
                  "lines": [
                    97,
                    98
                  ]
                }
              }
            },
            {
              "name": "MutableGroup",
              "short_description": "Used for the `userdata` group.",
              "docstring": "Used for the `userdata` group.",
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "docstring": "Used to access datasets (:class:`~bamboost.common.hdf_pointer.Dataset`)\nor groups inside this group (:class:`~bamboost.common.hdf_pointer.MutableGroup`)",
                  "signature": "(self, key) -> Any",
                  "returns": {
                    "annotation": "Any",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef __getitem__(self, key) -> Any:\n    \"\"\"Used to access datasets (:class:`~bamboost.common.hdf_pointer.Dataset`)\n    or groups inside this group (:class:`~bamboost.common.hdf_pointer.MutableGroup`)\n    \"\"\"\n    try:\n        return super().__getitem__(key)\n    except KeyError:\n        pass\n\n    try:\n        return self.obj.attrs[key]\n    except KeyError:\n        pass\n\n    return super().__getitem__(key)\n",
                    "lines": [
                      202,
                      217
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "__setitem__": {
                  "name": "__setitem__",
                  "docstring": "Used to set an attribute.\nWill be written as an attribute to the group.",
                  "signature": "(self, key, newvalue)",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "newvalue": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def __setitem__(self, key, newvalue):\n    \"\"\"Used to set an attribute.\n    Will be written as an attribute to the group.\n    \"\"\"\n    if isinstance(newvalue, str) or not isinstance(newvalue, Iterable):\n        self.update_attrs({key: newvalue})\n    else:\n        self.add_dataset(key, np.array(newvalue))\n",
                    "lines": [
                      219,
                      226
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "update_attrs": {
                  "name": "update_attrs",
                  "docstring": "Update the attributes of the group.\n",
                  "signature": "(self, attrs: dict) -> None",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "attrs": {
                      "default": null,
                      "annotation": "dict",
                      "description": "the dictionary to write as attributes"
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"a\")\ndef update_attrs(self, attrs: dict) -> None:\n    \"\"\"Update the attributes of the group.\n\n    Args:\n        attrs: the dictionary to write as attributes\n    \"\"\"\n    self.obj.attrs.update(attrs)\n",
                    "lines": [
                      236,
                      243
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "add_dataset": {
                  "name": "add_dataset",
                  "docstring": "Add a dataset to the group. Error is thrown if attempting to overwrite\nwith different shape than before. If same shape, data is overwritten\n(this is inherited from h5py -> require_dataset)",
                  "signature": "(\n    self,\n    name: str,\n    vector: numpy.ndarray,\n    attrs: dict = None,\n    dtype: str = None\n) -> None",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "name": {
                      "default": null,
                      "annotation": "str",
                      "description": "Name for the dataset"
                    },
                    "vector": {
                      "default": null,
                      "annotation": "numpy.ndarray",
                      "description": "Data to write (max 2d)"
                    },
                    "attrs": {
                      "default": "None",
                      "annotation": "dict",
                      "description": "Optional. Attributes of dataset."
                    },
                    "dtype": {
                      "default": "None",
                      "annotation": "str",
                      "description": "Optional. dtype of dataset. If not specified, uses dtype of inpyt array"
                    }
                  },
                  "source": {
                    "code": "def add_dataset(\n    self, name: str, vector: np.ndarray, attrs: dict = None, dtype: str = None\n) -> None:\n    \"\"\"Add a dataset to the group. Error is thrown if attempting to overwrite\n    with different shape than before. If same shape, data is overwritten\n    (this is inherited from h5py -> require_dataset)\n\n    Args:\n        name: Name for the dataset\n        vector: Data to write (max 2d)\n        attrs: Optional. Attributes of dataset.\n        dtype: Optional. dtype of dataset. If not specified, uses dtype of inpyt array\n    \"\"\"\n    if attrs is None:\n        attrs = {}\n    length_local = vector.shape[0]\n    length_p = np.array(self._file._comm.allgather(length_local))\n    length = np.sum(length_p)\n    dim = vector.shape[1:]\n    vec_shape = length, *dim\n\n    ranks = np.array([i for i in range(self._file._comm.size)])\n    idx_start = np.sum(length_p[ranks < self._file._comm.rank])\n    idx_end = idx_start + length_local\n\n    with self._file(\"a\", driver=\"mpio\"):\n        dataset = self.obj.require_dataset(\n            name, shape=vec_shape, dtype=dtype if dtype else vector.dtype\n        )\n        dataset[idx_start:idx_end] = vector\n        for key, item in attrs.items():\n            dataset.attrs[key] = item\n\n    log.info(f\"Written {name} as userdata to {self._file.file_name}...\")\n",
                    "lines": [
                      245,
                      278
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "require_group": {
                  "name": "require_group",
                  "docstring": "Add a new group to the current group. If exists, return existing.\n",
                  "signature": "(self, name: str) -> bamboost.common.hdf_pointer.MutableGroup",
                  "returns": {
                    "annotation": "bamboost.common.hdf_pointer.MutableGroup",
                    "description": ":class:`~bamboost.hdf_pointer.Group`"
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "name": {
                      "default": null,
                      "annotation": "str",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def require_group(self, name: str) -> MutableGroup:\n    \"\"\"Add a new group to the current group. If exists, return existing.\n\n    Returns:\n        :class:`~bamboost.hdf_pointer.Group`\n    \"\"\"\n    return MutableGroup(self._file, f\"{self.path_to_data}/{name}\")\n",
                    "lines": [
                      280,
                      286
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [],
              "inherits_from": {
                "bamboost.common.hdf_pointer.Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ],
                    [
                      "function",
                      "extract_attrs"
                    ]
                  ]
                },
                "bamboost.common.hdf_pointer.BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "bamboost.common.file_handler.FileHandler",
                    "description": null
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n    super().__init__(file_handler, path_to_data)\n    # Create group if it doesn't exist\n    with self._file(\"a\", driver=\"mpio\"):\n        self._file.file_object.require_group(path_to_data)\n",
                  "lines": [
                    193,
                    197
                  ]
                }
              }
            },
            {
              "name": "Dataset",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "__getitem__": {
                  "name": "__getitem__",
                  "docstring": "",
                  "signature": "(self, slice)",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "slice": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_file_open(\"r\")\ndef __getitem__(self, slice):\n    return self.obj[slice]\n",
                    "lines": [
                      293,
                      295
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [
                {
                  "name": "attrs",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "shape",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "dtype",
                  "annotation": null,
                  "description": null,
                  "default": ""
                }
              ],
              "inherits_from": {
                "bamboost.common.hdf_pointer.BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "bamboost.common.file_handler.FileHandler",
                    "description": null
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n    super().__init__(file_handler, path_to_data)\n",
                  "lines": [
                    290,
                    291
                  ]
                }
              }
            }
          ],
          "functions": [],
          "submodules": [],
          "examples": [],
          "version": null
        },
        {
          "name": "mpi",
          "slug": [
            "bamboost",
            "common",
            "mpi"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [
            {
              "name": "log",
              "annotation": null,
              "description": null,
              "default": "<Logger bamboost.mpi (WARNING)>"
            },
            {
              "name": "MPIType",
              "annotation": null,
              "description": null,
              "default": "typing.Union[bamboost.common._mock_mpi.MockMPI, typing.Any]"
            },
            {
              "name": "MPI_ON",
              "annotation": null,
              "description": null,
              "default": "False"
            },
            {
              "name": "ENV_BAMBOOST_MPI",
              "annotation": "bool",
              "description": "Indicates the use of `mpi4py.MPI`. If `0`, the `MockMPI` class is used\ninstead. Is set by reading the environment variable `BAMBOOST_MPI` [0 or 1].",
              "default": "'0'"
            },
            {
              "name": "MPI",
              "annotation": "Union[bamboost.common._mock_mpi.MockMPI, Any]",
              "description": null,
              "default": "<class 'bamboost.common._mock_mpi.MockMPI'>"
            }
          ],
          "classes": [],
          "functions": [],
          "submodules": [],
          "examples": [],
          "version": null
        }
      ],
      "examples": [],
      "version": null
    },
    {
      "name": "extensions",
      "slug": [
        "bamboost",
        "extensions"
      ],
      "docstring": "",
      "short_description": "",
      "attributes": [
        {
          "name": "extensions",
          "annotation": null,
          "description": null,
          "default": "<bamboost.extensions.ExtensionsLazyLoader object>"
        }
      ],
      "classes": [
        {
          "name": "ExtensionsLazyLoader",
          "short_description": "",
          "docstring": "",
          "methods": {},
          "properties": [
            {
              "name": "FenicsWriter",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "Remote",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "RemoteManager",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "install_slurm",
              "annotation": null,
              "description": null,
              "default": ""
            }
          ],
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "()",
            "arguments": {},
            "source": {
              "code": "",
              "lines": null
            }
          }
        }
      ],
      "functions": [],
      "submodules": [
        {
          "name": "fenics",
          "slug": [
            "bamboost",
            "extensions",
            "fenics"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [],
          "classes": [
            {
              "name": "FenicsWriter",
              "short_description": "Helper writer for input from FEniCS directly.",
              "docstring": "Helper writer for input from FEniCS directly.\n",
              "methods": {
                "add_field": {
                  "name": "add_field",
                  "docstring": "Add a dataset to the file. The data is stored at `data/`.\n",
                  "signature": "(\n    self,\n    name: str,\n    func: <fenics.Function>,\n    time: float = None,\n    mesh: str = None,\n    dtype: str = None,\n    center: Literal['Node', 'Cell'] = 'Node'\n) -> None",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "name": {
                      "default": null,
                      "annotation": "str",
                      "description": "Name for the dataset"
                    },
                    "func": {
                      "default": null,
                      "annotation": "<fenics.Function>",
                      "description": "FEniCS function to store"
                    },
                    "time": {
                      "default": "None",
                      "annotation": "float",
                      "description": "Optional. time"
                    },
                    "mesh": {
                      "default": "None",
                      "annotation": "str",
                      "description": "Optional. Linked mesh for this data"
                    },
                    "dtype": {
                      "default": "None",
                      "annotation": "str",
                      "description": "Optional. Numpy style datatype, see h5py documentation,\ndefaults to the dtype of the vector"
                    },
                    "center": {
                      "default": "Node",
                      "annotation": "Literal['Node', 'Cell']",
                      "description": "Optional. Center of the data. Can be 'Node' or 'Cell'.\nDefault is 'Node'."
                    }
                  },
                  "source": {
                    "code": "def add_field(\n    self,\n    name: str,\n    func: fe.Function,\n    time: float = None,\n    mesh: str = None,\n    dtype: str = None,\n    center: Literal[\"Node\", \"Cell\"] = \"Node\",\n) -> None:\n    \"\"\"Add a dataset to the file. The data is stored at `data/`.\n\n    Args:\n        name: Name for the dataset\n        func: FEniCS function to store\n        time: Optional. time\n        mesh: Optional. Linked mesh for this data\n        dtype: Optional. Numpy style datatype, see h5py documentation,\n            defaults to the dtype of the vector\n        center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n            Default is 'Node'.\n    \"\"\"\n    mesh = mesh if mesh is not None else self._default_mesh\n    time = time if time is not None else self.step\n\n    self._dump_fenics_field(\n        f\"data/{name}/{self.step}\",\n        func,\n        dtype=dtype,\n        center=center,\n    )\n    self._comm.barrier()  # attempt to fix bug (see SimulationWriter add_field)\n\n    if self._prank == 0:\n        with self._file(\"a\"):\n            vec = self._file[\"data\"][name][str(self.step)]\n            vec.attrs.update({\"center\": center, \"mesh\": mesh, \"t\": time})\n\n    self._comm.barrier()  # attempt to fix bug (see SimulationWriter add_field)\n",
                    "lines": [
                      48,
                      85
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "add_mesh": {
                  "name": "add_mesh",
                  "docstring": "Add the mesh to file using fe.HDF5File. I can't figure out how to\nextract the local mesh data in correct order when running in parallel.",
                  "signature": "(self, mesh: <fenics.Mesh>, mesh_name: str = None) -> None",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "mesh": {
                      "default": null,
                      "annotation": "<fenics.Mesh>",
                      "description": "FEniCS mesh object"
                    },
                    "mesh_name": {
                      "default": "None",
                      "annotation": "str",
                      "description": "name for mesh (default = `mesh`)"
                    }
                  },
                  "source": {
                    "code": "def add_mesh(self, mesh: fe.Mesh, mesh_name: str = None) -> None:\n    \"\"\"\n    Add the mesh to file using fe.HDF5File. I can't figure out how to\n    extract the local mesh data in correct order when running in parallel.\n\n    Args:\n        mesh: FEniCS mesh object\n        mesh_name: name for mesh (default = `mesh`)\n    \"\"\"\n    mesh_name = mesh_name if mesh_name is not None else self._default_mesh\n    mesh_location = f\"{self._mesh_location}/{mesh_name}/\"\n\n    assert not self._file.file_object, \"File is open -> Quitting\"\n\n    @contextmanager\n    def temporary_close_file():\n        was_open = False\n        if self._file.file_object:\n            self._file.file_object.close()\n            was_open = True\n        try:\n            yield\n        finally:\n            if was_open:\n                self._file.file_object = open_h5file(\n                    self._file.file_name,\n                    self._file.mode,\n                    self._file.driver,\n                    self._file.comm,\n                )\n\n    with temporary_close_file():\n        with fe.HDF5File(self._comm, self.h5file, \"a\") as f:\n            f.write(mesh, mesh_location)\n",
                    "lines": [
                      214,
                      247
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [],
              "inherits_from": {
                "bamboost.simulation_writer.SimulationWriter": {
                  "module": "bamboost.simulation_writer",
                  "members": [
                    [
                      "variable",
                      "step"
                    ],
                    [
                      "function",
                      "initialize"
                    ],
                    [
                      "function",
                      "add_metadata"
                    ],
                    [
                      "function",
                      "add_parameters"
                    ],
                    [
                      "function",
                      "add_fields"
                    ],
                    [
                      "function",
                      "add_global_field"
                    ],
                    [
                      "function",
                      "add_global_fields"
                    ],
                    [
                      "function",
                      "finish_step"
                    ],
                    [
                      "function",
                      "finish_sim"
                    ],
                    [
                      "function",
                      "register_git_attributes"
                    ],
                    [
                      "function",
                      "copy_executable"
                    ],
                    [
                      "function",
                      "copy_file"
                    ]
                  ]
                },
                "bamboost.simulation.Simulation": {
                  "module": "bamboost.simulation",
                  "members": [
                    [
                      "variable",
                      "uid"
                    ],
                    [
                      "variable",
                      "path_database"
                    ],
                    [
                      "variable",
                      "database_id"
                    ],
                    [
                      "variable",
                      "path"
                    ],
                    [
                      "variable",
                      "h5file"
                    ],
                    [
                      "variable",
                      "xdmffile"
                    ],
                    [
                      "variable",
                      "meshes"
                    ],
                    [
                      "variable",
                      "data"
                    ],
                    [
                      "variable",
                      "globals"
                    ],
                    [
                      "variable",
                      "userdata"
                    ],
                    [
                      "variable",
                      "links"
                    ],
                    [
                      "function",
                      "fromUID"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "parameters"
                    ],
                    [
                      "variable",
                      "metadata"
                    ],
                    [
                      "function",
                      "files"
                    ],
                    [
                      "function",
                      "show_files"
                    ],
                    [
                      "function",
                      "open_in_file_explorer"
                    ],
                    [
                      "function",
                      "open_in_paraview"
                    ],
                    [
                      "function",
                      "get_full_uid"
                    ],
                    [
                      "function",
                      "change_status"
                    ],
                    [
                      "function",
                      "update_metadata"
                    ],
                    [
                      "function",
                      "update_parameters"
                    ],
                    [
                      "function",
                      "create_xdmf_file"
                    ],
                    [
                      "function",
                      "create_run_script"
                    ],
                    [
                      "function",
                      "create_batch_script"
                    ],
                    [
                      "function",
                      "submit"
                    ],
                    [
                      "function",
                      "change_note"
                    ],
                    [
                      "function",
                      "open"
                    ],
                    [
                      "variable",
                      "mesh"
                    ],
                    [
                      "function",
                      "get_mesh"
                    ],
                    [
                      "variable",
                      "data_info"
                    ],
                    [
                      "variable",
                      "git"
                    ],
                    [
                      "function",
                      "get_data_interpolator"
                    ],
                    [
                      "function",
                      "show_h5tree"
                    ],
                    [
                      "function",
                      "enter_path"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    uid: str,\n    path: str,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>,\n    create_if_not_exists: bool = False\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "uid": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  },
                  "path": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  },
                  "comm": {
                    "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x7010845dcad0>",
                    "annotation": "bamboost.common._mock_mpi.MockMPI.Comm",
                    "description": null
                  },
                  "create_if_not_exists": {
                    "default": "False",
                    "annotation": "bool",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(\n    self,\n    uid: str,\n    path: str,\n    comm: MPI.Comm = MPI.COMM_WORLD,\n    create_if_not_exists: bool = False,\n):\n    super().__init__(uid, path, comm)\n",
                  "lines": [
                    39,
                    46
                  ]
                }
              }
            }
          ],
          "functions": [],
          "submodules": [],
          "examples": [],
          "version": null
        },
        {
          "name": "remote_manager",
          "slug": [
            "bamboost",
            "extensions",
            "remote_manager"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [],
          "classes": [
            {
              "name": "Remote",
              "short_description": "Access bamboost database of a remote server. The index is fetched using",
              "docstring": "Access bamboost database of a remote server. The index is fetched using\nrsync over ssh. The `remote_name` can be a hostname or an IP address. Make\nsure that ssh keys are set and working, as there is no user authentication.\nThe `skip_update` flag can be set to avoid fetching the index from the\nremote server.",
              "methods": {
                "list": {
                  "name": "list",
                  "docstring": "List all remote servers.",
                  "signature": "(cls) -> <classmethod(<function Remote.list at 0x701083ecf100>)>",
                  "returns": {
                    "annotation": "<classmethod(<function Remote.list at 0x701083ecf100>)>",
                    "description": null
                  },
                  "arguments": {
                    "cls": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@classmethod\ndef list(cls) -> list:\n    \"\"\"List all remote servers.\"\"\"\n    return [\n        name\n        for name in os.listdir(CACHE_DIR)\n        if os.path.isdir(os.path.join(CACHE_DIR, name))\n    ]\n",
                    "lines": [
                      142,
                      149
                    ]
                  },
                  "props": {
                    "isClassMethod": true
                  },
                  "examples": []
                },
                "__getitem__": {
                  "name": "__getitem__",
                  "docstring": "Return a `RemoteManager` for the given id.",
                  "signature": "(self, id: str) -> bamboost.extensions.remote_manager.RemoteManager",
                  "returns": {
                    "annotation": "bamboost.extensions.remote_manager.RemoteManager",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "id": {
                      "default": null,
                      "annotation": "str",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def __getitem__(self, id: str) -> RemoteManager:\n    \"\"\"Return a `RemoteManager` for the given id.\"\"\"\n    id = id.split(\" - \")[0]\n    return RemoteManager(id, remote=self)\n",
                    "lines": [
                      158,
                      161
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "fetch_index": {
                  "name": "fetch_index",
                  "docstring": "Fetch the index from the remote server.",
                  "signature": "(self) -> subprocess.Popen",
                  "returns": {
                    "annotation": "subprocess.Popen",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def fetch_index(self) -> subprocess.Popen:\n    \"\"\"Fetch the index from the remote server.\"\"\"\n    return subprocess.Popen(\n        [\"rsync\", \"-av\", f\"{self.remote_name}:{REMOTE_INDEX}\", self.file],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n    )\n",
                    "lines": [
                      163,
                      170
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "get_manager": {
                  "name": "get_manager",
                  "docstring": "",
                  "signature": "(\n    self,\n    id: str,\n    skip_update: bool = False\n) -> bamboost.extensions.remote_manager.RemoteManager",
                  "returns": {
                    "annotation": "bamboost.extensions.remote_manager.RemoteManager",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "id": {
                      "default": null,
                      "annotation": "str",
                      "description": null
                    },
                    "skip_update": {
                      "default": "False",
                      "annotation": "bool",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def get_manager(self, id: str, skip_update: bool = False) -> RemoteManager:\n    return RemoteManager(id, remote=self, skip_update=skip_update)\n",
                    "lines": [
                      172,
                      173
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "get_path": {
                  "name": "get_path",
                  "docstring": "Get the path of a database from its ID.\n",
                  "signature": "(self, id: str) -> str",
                  "returns": {
                    "annotation": "str",
                    "description": "path of the database"
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "id": {
                      "default": null,
                      "annotation": "str",
                      "description": "ID of the database"
                    }
                  },
                  "source": {
                    "code": "@with_connection\ndef get_path(self, id: str) -> str:\n    self._cursor.execute(\"SELECT path FROM dbindex WHERE id=?\", (id,))\n    fetch = self._cursor.fetchone()\n    if fetch is None:\n        raise KeyError(f\"No database found with id: {id}\")\n    else:\n        return fetch[0]\n",
                    "lines": [
                      175,
                      182
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "insert_local_path": {
                  "name": "insert_local_path",
                  "docstring": "",
                  "signature": "(self, id: str, path: str) -> None",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "id": {
                      "default": null,
                      "annotation": "str",
                      "description": null
                    },
                    "path": {
                      "default": null,
                      "annotation": "str",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "@with_connection\ndef insert_local_path(self, id: str, path: str) -> None:\n    try:\n        self._cursor.execute(\n            \"UPDATE dbindex SET local_path=? WHERE id=?\", (path, id)\n        )\n    except sqlite3.OperationalError:\n        self._cursor.execute(\n            \"ALTER TABLE dbindex ADD COLUMN local_path TEXT DEFAULT NULL\"\n        )\n        self._cursor.execute(\n            \"UPDATE dbindex SET local_path=? WHERE id=?\", (path, id)\n        )\n",
                    "lines": [
                      184,
                      196
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [
                {
                  "name": "remote_name",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "local_path",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "file",
                  "annotation": null,
                  "description": null,
                  "default": ""
                }
              ],
              "inherits_from": {
                "bamboost.index.IndexAPI": {
                  "module": "bamboost.index",
                  "members": [
                    [
                      "function",
                      "ThreadSafe"
                    ],
                    [
                      "function",
                      "create_index_table"
                    ],
                    [
                      "function",
                      "get_database_table"
                    ],
                    [
                      "function",
                      "read_table"
                    ],
                    [
                      "function",
                      "fetch"
                    ],
                    [
                      "function",
                      "insert_path"
                    ],
                    [
                      "function",
                      "get_id"
                    ],
                    [
                      "function",
                      "scan_known_paths"
                    ],
                    [
                      "function",
                      "commit_once"
                    ],
                    [
                      "function",
                      "clean"
                    ],
                    [
                      "function",
                      "drop_path"
                    ],
                    [
                      "function",
                      "check_path"
                    ]
                  ]
                },
                "bamboost._sqlite_database.SQLiteHandler": {
                  "module": "bamboost._sqlite_database",
                  "members": [
                    [
                      "function",
                      "connect"
                    ],
                    [
                      "function",
                      "close"
                    ],
                    [
                      "function",
                      "commit"
                    ],
                    [
                      "function",
                      "open"
                    ]
                  ]
                }
              },
              "examples": [
                ">>> remote = Remote(\"euler\")\n>>> remote.read_table()\nreturns a pandas DataFrame of the remote index.\n>>> remote[\"<id>\"]\nreturns a RemoteManager object for the given id."
              ],
              "constructor": {
                "signature": "(cls, *args, **kwargs)",
                "arguments": {
                  "cls": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "args": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "kwargs": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  }
                },
                "source": {
                  "code": "def __new__(cls, *args, **kwargs):\n    \"\"\"Override the __new__ method to avoid the singleton pattern of IndexAPI.\"\"\"\n    return object.__new__(cls)\n",
                  "lines": [
                    123,
                    125
                  ]
                }
              }
            },
            {
              "name": "RemoteManager",
              "short_description": "Manager class with remote functionality. Constructor takes an existing ID",
              "docstring": "Manager class with remote functionality. Constructor takes an existing ID\nof a database on a remote server. The ssh connection must be set up to work\nwithout explicit user authentication. Data is lazily transferred using\nrsync.",
              "methods": {
                "get_view": {
                  "name": "get_view",
                  "docstring": "View of the database and its parametric space. Read from the sql\ndatabase. If `include_linked_sims` is True, the individual h5 files are\nscanned.",
                  "signature": "(self, include_linked_sims: bool = False) -> pandas.core.frame.DataFrame",
                  "returns": {
                    "annotation": "pandas.core.frame.DataFrame",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "include_linked_sims": {
                      "default": "False",
                      "annotation": "bool",
                      "description": "if True, include the parameters of linked sims"
                    }
                  },
                  "source": {
                    "code": "def get_view(self, include_linked_sims: bool = False) -> pd.DataFrame:\n    df = super().get_view(include_linked_sims)\n    df.insert(1, \"cached\", False)\n    for id in os.listdir(self.path):\n        if id in df[\"id\"].values:\n            df.loc[df[\"id\"] == id, \"cached\"] = True\n\n    opts = config.get(\"options\", {})\n    if \"sort_table_key\" in opts:\n        df.sort_values(\n            opts.get(\"sort_table_key\", \"id\"),\n            ascending=opts.get(\"sort_table_order\", \"asc\") == \"asc\",\n            inplace=True,\n        )\n    return df\n",
                    "lines": [
                      275,
                      289
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": [
                    ">>> db.get_view()\n>>> db.get_view(include_linked_sims=True)"
                  ]
                },
                "sim": {
                  "name": "sim",
                  "docstring": "Return simulation object.\n",
                  "signature": "(self, uid, return_writer: bool = False)",
                  "returns": {
                    "annotation": null,
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "uid": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "return_writer": {
                      "default": "False",
                      "annotation": "bool",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def sim(self, uid, return_writer: bool = False):\n    \"\"\"Return simulation object.\n\n    Args:\n        - uid (str): the unique id of the sim to be transferred.\n        - return_writer (bool): Flag to indicate whether to return a writer\n          object. Default is False.\n\n    This method checks if the data for the given uid is already in the\n    local cache. If not, it transfers the data from a remote location using\n    rsync. The method then calls the superclass method to perform further\n    operations on the transferred data.\n    \"\"\"\n    # Check if data is already in cache\n    if os.path.exists(f\"{self.path}/{uid}\"):\n        log.info(f\"Data for {uid} already in cache\")\n        return RemoteSimulation(uid, self)\n\n    # Transfer data using rsync\n    log.info(f\"Data not in cache. Transferring data for {uid} from {self.remote}\")\n    self.rsync(uid)\n\n    return RemoteSimulation(uid, self)\n",
                    "lines": [
                      291,
                      313
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "rsync": {
                  "name": "rsync",
                  "docstring": "Transfer data using rsync. Wait for the process to finish and return\nself.",
                  "signature": "(\n    self,\n    uid: str | None = None\n) -> bamboost.extensions.remote_manager.RemoteManager",
                  "returns": {
                    "annotation": "bamboost.extensions.remote_manager.RemoteManager",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "uid": {
                      "default": "None",
                      "annotation": "str | None",
                      "description": "The unique id of the simulation to be transferred. If None,\nall simulations are synced."
                    }
                  },
                  "source": {
                    "code": "def rsync(self, uid: str | None = None) -> RemoteManager:\n    \"\"\"Transfer data using rsync. Wait for the process to finish and return\n    self.\n\n    Args:\n        uid: The unique id of the simulation to be transferred. If None,\n            all simulations are synced.\n    \"\"\"\n    process = self._rsync(uid)\n    for line in iter(process.stdout.readline, ''):\n        print(line, end='')\n    process.wait()\n    return self\n",
                    "lines": [
                      351,
                      363
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [
                {
                  "name": "UID",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "remote",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "comm",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "path",
                  "annotation": null,
                  "description": null,
                  "default": ""
                },
                {
                  "name": "remote_path_db",
                  "annotation": null,
                  "description": null,
                  "default": ""
                }
              ],
              "inherits_from": {
                "bamboost.manager.Manager": {
                  "module": "bamboost.manager",
                  "members": [
                    [
                      "variable",
                      "FIX_DF"
                    ],
                    [
                      "variable",
                      "fromUID"
                    ],
                    [
                      "variable",
                      "fromName"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "function",
                      "__len__"
                    ],
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "variable",
                      "all_uids"
                    ],
                    [
                      "variable",
                      "df"
                    ],
                    [
                      "function",
                      "get_view_from_hdf_files"
                    ],
                    [
                      "variable",
                      "data_info"
                    ],
                    [
                      "function",
                      "sims"
                    ],
                    [
                      "function",
                      "create_simulation"
                    ],
                    [
                      "function",
                      "remove"
                    ],
                    [
                      "function",
                      "find"
                    ],
                    [
                      "function",
                      "global_fields_in_all"
                    ],
                    [
                      "function",
                      "get_parameters"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    id: str,\n    remote: bamboost.extensions.remote_manager.Remote,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "id": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  },
                  "remote": {
                    "default": null,
                    "annotation": "bamboost.extensions.remote_manager.Remote",
                    "description": null
                  },
                  "comm": {
                    "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x7010845dcad0>",
                    "annotation": "bamboost.common._mock_mpi.MockMPI.Comm",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(\n    self,\n    id: str,\n    remote: Remote,\n    comm: MPI.Comm = MPI.COMM_WORLD,\n) -> None:\n    \"\"\"\n    params\n    skip_update: if True, does not lookup the new database on the remote:\n    \"\"\"\n    self.UID = id\n    self.remote = remote\n    self.comm = comm\n    self.path = os.path.join(self.remote.local_path, self.UID)\n    log.info(f\"Creating cache directory at {self.path}\")\n    os.makedirs(self.path, exist_ok=True)\n\n    self.remote_path_db = self._index.get_path(self.UID)\n\n    # check if path exists\n    if not os.path.isdir(self.path):\n        os.makedirs(self.path)\n\n    # Write the database ID file if it does not exist\n    if not os.path.exists(f\"{self.path}/.BAMBOOST-{self.UID}\"):\n        with open(f\"{self.path}/.BAMBOOST-{self.UID}\", \"w\") as f:\n            f.write(self.UID)\n\n    self.UID = id\n    self._index.insert_local_path(self.UID, self.path)\n\n    # Update the SQL table for the database\n    with self._index.open():\n        self._table.create_database_table()\n        # self._table.sync()\n",
                  "lines": [
                    216,
                    250
                  ]
                }
              }
            },
            {
              "name": "RemoteSimulation",
              "short_description": "A single dataset/simulation. Used to write to it, read from it or append.",
              "docstring": "A single dataset/simulation. Used to write to it, read from it or append.\n",
              "methods": {
                "sync": {
                  "name": "sync",
                  "docstring": "Sync the simulation data with the remote server.",
                  "signature": "(self) -> bamboost.extensions.remote_manager.RemoteSimulation",
                  "returns": {
                    "annotation": "bamboost.extensions.remote_manager.RemoteSimulation",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def sync(self) -> RemoteSimulation:\n    \"\"\"Sync the simulation data with the remote server.\"\"\"\n    self.manager.rsync(self.uid)\n    return self\n",
                    "lines": [
                      371,
                      374
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "get_full_uid": {
                  "name": "get_full_uid",
                  "docstring": "Returns the full uid of the simulation (including the one of the database)",
                  "signature": "(self) -> str",
                  "returns": {
                    "annotation": "str",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "def get_full_uid(self) -> str:\n    return f\"ssh://{self.manager.remote.remote_name}/{self.manager.UID}:{self.uid}\"\n",
                    "lines": [
                      376,
                      377
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "properties": [
                {
                  "name": "manager",
                  "annotation": null,
                  "description": null,
                  "default": ""
                }
              ],
              "inherits_from": {
                "bamboost.simulation.Simulation": {
                  "module": "bamboost.simulation",
                  "members": [
                    [
                      "variable",
                      "uid"
                    ],
                    [
                      "variable",
                      "path_database"
                    ],
                    [
                      "variable",
                      "database_id"
                    ],
                    [
                      "variable",
                      "path"
                    ],
                    [
                      "variable",
                      "h5file"
                    ],
                    [
                      "variable",
                      "xdmffile"
                    ],
                    [
                      "variable",
                      "meshes"
                    ],
                    [
                      "variable",
                      "data"
                    ],
                    [
                      "variable",
                      "globals"
                    ],
                    [
                      "variable",
                      "userdata"
                    ],
                    [
                      "variable",
                      "links"
                    ],
                    [
                      "function",
                      "fromUID"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "parameters"
                    ],
                    [
                      "variable",
                      "metadata"
                    ],
                    [
                      "function",
                      "files"
                    ],
                    [
                      "function",
                      "show_files"
                    ],
                    [
                      "function",
                      "open_in_file_explorer"
                    ],
                    [
                      "function",
                      "open_in_paraview"
                    ],
                    [
                      "function",
                      "change_status"
                    ],
                    [
                      "function",
                      "update_metadata"
                    ],
                    [
                      "function",
                      "update_parameters"
                    ],
                    [
                      "function",
                      "create_xdmf_file"
                    ],
                    [
                      "function",
                      "create_run_script"
                    ],
                    [
                      "function",
                      "create_batch_script"
                    ],
                    [
                      "function",
                      "submit"
                    ],
                    [
                      "function",
                      "change_note"
                    ],
                    [
                      "function",
                      "open"
                    ],
                    [
                      "variable",
                      "mesh"
                    ],
                    [
                      "function",
                      "get_mesh"
                    ],
                    [
                      "variable",
                      "data_info"
                    ],
                    [
                      "variable",
                      "git"
                    ],
                    [
                      "function",
                      "get_data_interpolator"
                    ],
                    [
                      "function",
                      "show_h5tree"
                    ],
                    [
                      "function",
                      "enter_path"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    self,\n    uid: str,\n    manager: bamboost.extensions.remote_manager.RemoteManager\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "uid": {
                    "default": null,
                    "annotation": "str",
                    "description": null
                  },
                  "manager": {
                    "default": null,
                    "annotation": "bamboost.extensions.remote_manager.RemoteManager",
                    "description": null
                  }
                },
                "source": {
                  "code": "def __init__(self, uid: str, manager: RemoteManager) -> None:\n    super().__init__(uid, manager.path, _db_id=manager.UID)\n    self.manager = manager\n",
                  "lines": [
                    367,
                    369
                  ]
                }
              }
            }
          ],
          "functions": [],
          "submodules": [],
          "examples": [],
          "version": null
        },
        {
          "name": "slurm",
          "slug": [
            "bamboost",
            "extensions",
            "slurm"
          ],
          "docstring": "",
          "short_description": "",
          "attributes": [],
          "classes": [],
          "functions": [
            {
              "name": "install",
              "docstring": "Install the slurm extension to the SimulationWriter class. Extends the\n__exit__ method to add slurm metadata.",
              "signature": "()",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {},
              "source": {
                "code": "def install():\n    \"\"\"Install the slurm extension to the SimulationWriter class. Extends the\n    __exit__ method to add slurm metadata.\n    \"\"\"\n    SimulationWriter.__exit__ = _extend_exit_slurm_info(SimulationWriter.__exit__)\n    SimulationWriter.__enter__ = _extend_enter_slurm_info(SimulationWriter.__enter__)\n",
                "lines": [
                  67,
                  72
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          ],
          "submodules": [],
          "examples": [],
          "version": null
        },
        {
          "name": "use_locking",
          "slug": [
            "bamboost",
            "extensions",
            "use_locking"
          ],
          "docstring": "This module provides a custom rather primitive file locking mechanism for\nHDF5 files.\n\nThis module provides a function `use_locking` that installs the mechanism by\nMonkey-patching the `FileHandler` class. To use this mechanism, call the\n`use_locking` function at the start of your script, before creating any\n`bamboost.common.file_handler.FileHandler` instances.",
          "short_description": "This module provides a custom rather primitive file locking mechanism for\nHDF5 files.",
          "attributes": [],
          "classes": [],
          "functions": [
            {
              "name": "get_lock_and_open_function",
              "docstring": "Returns a function that locks and opens an HDF5 file with the specified\nlock type.\n\nThe returned function acquires a lock on the lock file and opens the HDF5\nfile, returning both the opened HDF5 file object and the lock file object.\n\nThe returned function takes the following parameters:\n\n| Argument  | Description                                                                 |\n|-----------|-----------------------------------------------------------------------------|\n| file      | The path to the HDF5 file to open.                                          |\n| lock_file | The path to the lock file.                                                  |\n| mode      | The mode to open the file in (e.g., 'r', 'w', 'a').                         |\n| driver    | The HDF5 driver to use (e.g., 'mpio' for MPI-IO).                           |\n| comm      | The MPI communicator (only used with 'mpio' driver).                        |",
              "signature": "(\n    lock_type: Literal['shared', 'exclusive']\n) -> Callable[..., typing.Tuple[h5py._hl.files.File, _io.BufferedReader]]",
              "returns": {
                "annotation": "Callable[..., typing.Tuple[h5py._hl.files.File, _io.BufferedReader]]",
                "description": "A function that locks and opens an HDF5 file."
              },
              "arguments": {
                "lock_type": {
                  "default": null,
                  "annotation": "Literal['shared', 'exclusive']",
                  "description": "The type of lock to use."
                }
              },
              "source": {
                "code": "def get_lock_and_open_function(\n    lock_type: Literal[\"shared\", \"exclusive\"],\n) -> Callable[..., Tuple[h5py.File, BufferedReader]]:\n    \"\"\"Returns a function that locks and opens an HDF5 file with the specified\n    lock type.\n\n    The returned function acquires a lock on the lock file and opens the HDF5\n    file, returning both the opened HDF5 file object and the lock file object.\n\n    The returned function takes the following parameters:\n\n    | Argument  | Description                                                                 |\n    |-----------|-----------------------------------------------------------------------------|\n    | file      | The path to the HDF5 file to open.                                          |\n    | lock_file | The path to the lock file.                                                  |\n    | mode      | The mode to open the file in (e.g., 'r', 'w', 'a').                         |\n    | driver    | The HDF5 driver to use (e.g., 'mpio' for MPI-IO).                           |\n    | comm      | The MPI communicator (only used with 'mpio' driver).                        |\n\n    Args:\n        lock_type (Literal[\"shared\", \"exclusive\"]): The type of lock to use.\n\n    Returns:\n        Callable: A function that locks and opens an HDF5 file.\n    \"\"\"\n    lock_type_int = {\"shared\": fcntl.LOCK_SH, \"exclusive\": fcntl.LOCK_EX}[lock_type]\n\n    def lock_and_open(\n        file: str, lock_file: str, mode: str, driver: str, comm: Any\n    ) -> Tuple[h5py.File, BufferedReader]:\n        lock_file_object = open(lock_file, \"rb\")\n        # acquire a lock\n        fcntl.flock(lock_file_object, lock_type_int)\n        # open the file\n        h5_file = open_h5file(file, mode, driver, comm)\n        return h5_file, lock_file_object\n\n    return lock_and_open\n",
                "lines": [
                  33,
                  70
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "close_and_unlock",
              "docstring": "Close an HDF5 file and release the associated file lock.\n\nThis function performs the following operations:\n1. Closes the given HDF5 file.\n2. Releases the lock on the lock file.\n3. Closes the lock file.",
              "signature": "(h5_file: h5py._hl.files.File, lock_file: _io.BufferedReader) -> None",
              "returns": {
                "annotation": null,
                "description": "None"
              },
              "arguments": {
                "h5_file": {
                  "default": null,
                  "annotation": "h5py._hl.files.File",
                  "description": "The HDF5 file object to be closed."
                },
                "lock_file": {
                  "default": null,
                  "annotation": "_io.BufferedReader",
                  "description": "The lock file object to be unlocked and closed."
                }
              },
              "source": {
                "code": "def close_and_unlock(h5_file: h5py.File, lock_file: BufferedReader) -> None:\n    \"\"\"Close an HDF5 file and release the associated file lock.\n\n    This function performs the following operations:\n    1. Closes the given HDF5 file.\n    2. Releases the lock on the lock file.\n    3. Closes the lock file.\n\n    Args:\n        h5_file: The HDF5 file object to be closed.\n        lock_file: The lock file object to be unlocked and closed.\n\n    Returns:\n        None\n    \"\"\"\n    h5_file.close()\n    fcntl.flock(lock_file, fcntl.LOCK_UN)\n    lock_file.close()\n",
                "lines": [
                  73,
                  90
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "get_open_method",
              "docstring": "",
              "signature": "(\n    lock_type: Literal['shared', 'exclusive']\n) -> Callable[..., h5py._hl.files.File]",
              "returns": {
                "annotation": "Callable[..., h5py._hl.files.File]",
                "description": null
              },
              "arguments": {
                "lock_type": {
                  "default": null,
                  "annotation": "Literal['shared', 'exclusive']",
                  "description": null
                }
              },
              "source": {
                "code": "def get_open_method(\n    lock_type: Literal[\"shared\", \"exclusive\"],\n) -> Callable[..., h5py.File]:\n    open_function = get_lock_and_open_function(lock_type)\n\n    @wraps(FileHandler.open)\n    def _modified_open(self: FileHandler, mode: str = \"r\", driver=None, comm=None):\n        \"\"\"Create a primitive lock file for the file.\n\n        Will replace `file_handler.FileHandler.open` method.\n        \"\"\"\n        if self._lock <= 0:\n            # lock_file_access(self.file_name, comm)\n\n            log.debug(f\"[{id(self)}] Open {self.file_name}\")\n            # self.file_object = open_h5file(self.file_name, mode, driver, comm)\n            self.file_object, self._lock_file = open_function(  # type: ignore\n                self.file_name, self._lock_file_name, mode, driver, comm\n            )\n\n        if FILE_MODE_HIRARCHY[self.file_object.mode] < FILE_MODE_HIRARCHY[mode]:\n            close_and_unlock(self.file_object, self._lock_file)\n            self.file_object, self._lock_file = open_function(  # type: ignore\n                self.file_name, self._lock_file_name, mode, driver, comm\n            )\n\n        log.debug(f\"[{id(self)}] Lock stack {self._lock}\")\n        self._lock += 1\n        return self.file_object\n\n    return _modified_open\n",
                "lines": [
                  93,
                  123
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            {
              "name": "use_locking",
              "docstring": "Installs a primitive locking mechanism for FileHandler operations.\n\nThis function modifies the FileHandler class to include file locking\ncapabilities, ensuring thread-safe access to files. It wraps the\n`__init__`, `open`, and `close` methods of FileHandler with locking mechanisms.\n\nUsage:\n    Call this function before using FileHandler to enable locking:\n    use_locking(\"shared\")  # or use_locking(\"exclusive\")\n\nNote:\n    This function should be called only once, preferably at the start\n    of your program, before any FileHandler instances are created.\n\nNote:\n    You should only need this functionality if you are using HDF5 <= 1.10.6.\n    The newer versions of HDF5 (>= 1.10.7) have built-in file locking.",
              "signature": "(lock_type: Literal['shared', 'exclusive']) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "lock_type": {
                  "default": null,
                  "annotation": "Literal['shared', 'exclusive']",
                  "description": "The type of lock to use.\n- \"shared\" allows multiple processes to open the file simultaneously.\n- \"exclusive\" allows only one reader or writer at a time."
                }
              },
              "source": {
                "code": "def use_locking(lock_type: Literal[\"shared\", \"exclusive\"]) -> None:\n    \"\"\"Installs a primitive locking mechanism for FileHandler operations.\n\n    This function modifies the FileHandler class to include file locking\n    capabilities, ensuring thread-safe access to files. It wraps the\n    `__init__`, `open`, and `close` methods of FileHandler with locking mechanisms.\n\n    Usage:\n        Call this function before using FileHandler to enable locking:\n        use_locking(\"shared\")  # or use_locking(\"exclusive\")\n\n    Note:\n        This function should be called only once, preferably at the start\n        of your program, before any FileHandler instances are created.\n\n    Note:\n        You should only need this functionality if you are using HDF5 <= 1.10.6.\n        The newer versions of HDF5 (>= 1.10.7) have built-in file locking.\n\n    Args:\n        lock_type (Literal[\"shared\", \"exclusive\"]): The type of lock to use.\n            - \"shared\" allows multiple processes to open the file simultaneously.\n            - \"exclusive\" allows only one reader or writer at a time.\n    \"\"\"\n    if not hasattr(FileHandler.__init__, \"__wrapped__\"):\n        FileHandler.__init__ = _extend_init(FileHandler.__init__)\n\n    if not hasattr(FileHandler.open, \"__wrapped__\"):\n        FileHandler.open = get_open_method(lock_type)\n\n    if not hasattr(FileHandler.close, \"__wrapped__\"):\n        FileHandler.close = _modified_close\n\n    log.info(\"Primitive locking installed\")\n",
                "lines": [
                  155,
                  188
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          ],
          "submodules": [],
          "examples": [
            ">>> from bamboost.extensions.use_locking import use_locking\n>>> use_locking(\"shared\")"
          ],
          "version": null
        }
      ],
      "examples": [],
      "version": null
    },
    {
      "name": "index",
      "slug": [
        "bamboost",
        "index"
      ],
      "docstring": "Module to manage the database index and its ID's.",
      "short_description": "Module to manage the database index and its ID's.\n",
      "attributes": [
        {
          "name": "THREAD_SAFE",
          "annotation": null,
          "description": "if True, the index is thread safe",
          "default": "False"
        },
        {
          "name": "CONVERT_ARRAYS",
          "annotation": null,
          "description": "if True, convert numpy arrays to lists",
          "default": "True"
        },
        {
          "name": "PREFIX",
          "annotation": null,
          "description": "prefix for databaseID identifier file",
          "default": "'.BAMBOOST-'"
        },
        {
          "name": "DOT_REPLACEMENT",
          "annotation": null,
          "description": "replace dots with this in column names for sqlite",
          "default": "'DOT'"
        }
      ],
      "classes": [
        {
          "name": "Null",
          "short_description": "Null object to replace API classes for off-root processes.",
          "docstring": "Null object to replace API classes for off-root processes.",
          "methods": {
            "__getitem__": {
              "name": "__getitem__",
              "docstring": "",
              "signature": "(self, _)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "_": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def __getitem__(self, _):\n    return self\n",
                "lines": [
                  97,
                  98
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [],
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "()",
            "arguments": {},
            "source": {
              "code": "",
              "lines": null
            }
          }
        },
        {
          "name": "IndexAPI",
          "short_description": "SQLite database to store database ID, path lookup. As well as the table for",
          "docstring": "SQLite database to store database ID, path lookup. As well as the table for\neach database. Location: `~/.local/share/bamboost/bamboost.db`.\nSingleton pattern.",
          "methods": {
            "ThreadSafe": {
              "name": "ThreadSafe",
              "docstring": "",
              "signature": "(cls, *args, **kwargs) -> bamboost.index.IndexAPI",
              "returns": {
                "annotation": "bamboost.index.IndexAPI",
                "description": null
              },
              "arguments": {
                "cls": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "args": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "kwargs": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@classmethod\ndef ThreadSafe(cls, *args, **kwargs) -> IndexAPI:\n    instance = super().__new__(cls)\n    instance.__init__(*args, **kwargs)\n    return instance\n",
                "lines": [
                  145,
                  149
                ]
              },
              "props": {
                "isClassMethod": true
              },
              "examples": []
            },
            "__getitem__": {
              "name": "__getitem__",
              "docstring": "",
              "signature": "(self, id: str) -> bamboost.index.DatabaseTable",
              "returns": {
                "annotation": "bamboost.index.DatabaseTable",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "def __getitem__(self, id: str) -> DatabaseTable:\n    return DatabaseTable(id, _index=self)\n",
                "lines": [
                  157,
                  158
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_index_table": {
              "name": "create_index_table",
              "docstring": "Create the index table if it does not exist.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef create_index_table(self) -> None:\n    \"\"\"Create the index table if it does not exist.\"\"\"\n    self._cursor.execute(\n        \"\"\"CREATE TABLE IF NOT EXISTS dbindex (id TEXT PRIMARY KEY, path TEXT)\"\"\"\n    )\n",
                "lines": [
                  163,
                  168
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_database_table": {
              "name": "get_database_table",
              "docstring": "Get the table of a database.\n",
              "signature": "(self, id: str) -> bamboost.index.DatabaseTable",
              "returns": {
                "annotation": "bamboost.index.DatabaseTable",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "def get_database_table(self, id: str) -> DatabaseTable:\n    \"\"\"Get the table of a database.\n\n    Args:\n        - id (str): ID of the database\n    \"\"\"\n    return DatabaseTable(id, _index=self)\n",
                "lines": [
                  170,
                  176
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "read_table": {
              "name": "read_table",
              "docstring": "Read the index table.\n",
              "signature": "(self, *args, **kwargs) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "pandas.core.frame.DataFrame",
                "description": "index table"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "args": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "kwargs": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef read_table(self, *args, **kwargs) -> pd.DataFrame:\n    \"\"\"Read the index table.\n\n    Returns:\n        pd.DataFrame: index table\n    \"\"\"\n    return pd.read_sql_query(\"SELECT * FROM dbindex\", self._conn, *args, **kwargs)\n",
                "lines": [
                  178,
                  185
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "fetch": {
              "name": "fetch",
              "docstring": "Query the index table.\n",
              "signature": "(self, query: str, *args, **kwargs) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "pandas.core.frame.DataFrame",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "query": {
                  "default": null,
                  "annotation": "str",
                  "description": "query string"
                },
                "args": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "kwargs": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef fetch(self, query: str, *args, **kwargs) -> pd.DataFrame:\n    \"\"\"Query the index table.\n\n    Args:\n        query (str): query string\n    \"\"\"\n    self._cursor.execute(query, *args, **kwargs)\n    return self._cursor.fetchall()\n",
                "lines": [
                  187,
                  195
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_path": {
              "name": "get_path",
              "docstring": "Get the path of a database from its ID.\n",
              "signature": "(self, id: str) -> str",
              "returns": {
                "annotation": "str",
                "description": "path of the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "str",
                  "description": "ID of the database"
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef get_path(self, id: str) -> str:\n    \"\"\"Get the path of a database from its ID.\n\n    Args:\n        id (str): ID of the database\n\n    Returns:\n        str: path of the database\n    \"\"\"\n    self._cursor.execute(\"SELECT path FROM dbindex WHERE id=?\", (id,))\n    path_db = self._cursor.fetchone()\n    if path_db and _check_path(id, path_db[0]):\n        return path_db[0]\n\n    # if path is wrong, try to find it\n    for root_dir in get_known_paths():\n        res = find(id, root_dir)\n        if res:\n            path = os.path.dirname(res[0])\n            self.insert_path(id, path)\n            return path\n\n    # last resort, check home\n    res = find(id, paths[\"HOME\"])\n    if res:\n        path = os.path.dirname(res[0])\n        self.insert_path(id, path)\n        return path\n\n    raise FileNotFoundError(f\"Database {id} not found on system.\")\n",
                "lines": [
                  197,
                  227
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "insert_path": {
              "name": "insert_path",
              "docstring": "Insert a database path into the index.\n",
              "signature": "(self, id: str, path: str) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "str",
                  "description": "ID of the database"
                },
                "path": {
                  "default": null,
                  "annotation": "str",
                  "description": "path of the database"
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef insert_path(self, id: str, path: str) -> None:\n    \"\"\"Insert a database path into the index.\n\n    Args:\n        id (str): ID of the database\n        path (str): path of the database\n    \"\"\"\n    path = os.path.abspath(path)\n    self._cursor.execute(\"INSERT OR REPLACE INTO dbindex VALUES (?, ?)\", (id, path))\n",
                "lines": [
                  229,
                  238
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_id": {
              "name": "get_id",
              "docstring": "Get the ID of a database from its path.\n",
              "signature": "(self, path: str) -> str",
              "returns": {
                "annotation": "str",
                "description": "ID of the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "path": {
                  "default": null,
                  "annotation": "str",
                  "description": "path of the database"
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef get_id(self, path: str) -> str:\n    \"\"\"Get the ID of a database from its path.\n\n    Args:\n        path (str): path of the database\n\n    Returns:\n        str: ID of the database\n\n    Raises:\n        DatabaseNotFoundError: if the database is not found in the index\n    \"\"\"\n    path = os.path.abspath(path)\n    self._cursor.execute(\"SELECT id FROM dbindex WHERE path=?\", (path,))\n    fetched = self._cursor.fetchone()\n    if fetched is None:\n        raise DatabaseNotFoundError(f\"Database at {path} not found in index.\")\n    return fetched[0]\n",
                "lines": [
                  240,
                  258
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "scan_known_paths": {
              "name": "scan_known_paths",
              "docstring": "Scan known paths for databases and update the index.",
              "signature": "(self) -> dict",
              "returns": {
                "annotation": "dict",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef scan_known_paths(self) -> dict:\n    \"\"\"Scan known paths for databases and update the index.\"\"\"\n    for path in get_known_paths():\n        completed_process = subprocess.run(\n            [\"find\", path, \"-iname\", f\"{PREFIX}*\", \"-not\", \"-path\", r\"*/\\.git/*\"],\n            capture_output=True,\n        )\n        databases_found = completed_process.stdout.decode(\"utf-8\").splitlines()\n        for database in databases_found:\n            name = os.path.basename(database)\n            id = name.split(\"-\")[1]\n            self.insert_path(id, os.path.dirname(database))\n",
                "lines": [
                  260,
                  272
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "commit_once": {
              "name": "commit_once",
              "docstring": "Decorator to bundle changes to a single commit.\n",
              "signature": "(self, func) -> Callable",
              "returns": {
                "annotation": "Callable",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "func": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def commit_once(self, func) -> Callable:\n    \"\"\"Decorator to bundle changes to a single commit.\n\n    Example:\n        >>> @Index.commit_once\n        >>> def create_a_bunch_of_simulations():\n        >>>     for i in range(1000):\n        >>>         db.create_simulation(parameters={...})\n        >>>\n        >>> create_a_bunch_of_simulations()\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        with self.open(ensure_commit=True):\n            return func(*args, **kwargs)\n\n    return wrapper\n",
                "lines": [
                  274,
                  290
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> @Index.commit_once\n>>> def create_a_bunch_of_simulations():\n>>>     for i in range(1000):\n>>>         db.create_simulation(parameters={...})\n>>>\n>>> create_a_bunch_of_simulations()"
              ]
            },
            "clean": {
              "name": "clean",
              "docstring": "Clean the index from wrong paths.\n",
              "signature": "(self, purge: bool = False) -> bamboost.index.IndexAPI",
              "returns": {
                "annotation": "bamboost.index.IndexAPI",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "purge": {
                  "default": "False",
                  "annotation": "bool",
                  "description": "Also deletes the table of unmatching uid/path pairs. Defaults to False."
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef clean(self, purge: bool = False) -> IndexAPI:\n    \"\"\"Clean the index from wrong paths.\n\n    Args:\n        purge (bool, optional): Also deletes the table of unmatching uid/path pairs. Defaults to False.\n    \"\"\"\n    index = self._cursor.execute(\"SELECT id, path FROM dbindex\").fetchall()\n    for id, path in index:\n        if not _check_path(id, path):\n            self._cursor.execute(\"DELETE FROM dbindex WHERE id=?\", (id,))\n\n    if purge:\n        # all tables starting with db_ are tables of databases\n        all_tables = self._cursor.execute(\n            \"SELECT name FROM sqlite_master WHERE type='table'\"\n        ).fetchall()\n        id_list_tables = {\n            i[0].split(\"_\")[1] for i in all_tables if i[0].startswith(\"db_\")\n        }\n        id_list = self._cursor.execute(\"SELECT id FROM dbindex\").fetchall()\n\n        for id in id_list_tables:\n            if id not in id_list:\n                self._cursor.execute(f\"DROP TABLE db_{id}\")\n                self._cursor.execute(f\"DROP TABLE db_{id}_t\")\n\n    return self\n",
                "lines": [
                  292,
                  319
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "drop_path": {
              "name": "drop_path",
              "docstring": "Drop a path from the index.\n",
              "signature": "(self, id: str) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "str",
                  "description": "ID of the database"
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef drop_path(self, id: str) -> None:\n    \"\"\"Drop a path from the index.\n\n    Args:\n        id (str): ID of the database\n    \"\"\"\n    self._cursor.execute(\"DELETE FROM dbindex WHERE id=?\", (id,))\n",
                "lines": [
                  321,
                  328
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "check_path": {
              "name": "check_path",
              "docstring": "Check if path is going to the correct database.",
              "signature": "(self, id: str, path: str) -> bool",
              "returns": {
                "annotation": "bool",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                },
                "path": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "def check_path(self, id: str, path: str) -> bool:\n    \"\"\"Check if path is going to the correct database.\"\"\"\n    return _check_path(id, path)\n",
                "lines": [
                  330,
                  332
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [],
          "inherits_from": {
            "bamboost._sqlite_database.SQLiteHandler": {
              "module": "bamboost._sqlite_database",
              "members": [
                [
                  "variable",
                  "file"
                ],
                [
                  "function",
                  "connect"
                ],
                [
                  "function",
                  "close"
                ],
                [
                  "function",
                  "commit"
                ],
                [
                  "function",
                  "open"
                ]
              ]
            }
          },
          "examples": [],
          "constructor": {
            "signature": "(self, *, _file: str = None, convert_arrays: bool = None)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "_file": {
                "default": "None",
                "annotation": "str",
                "description": null
              },
              "convert_arrays": {
                "default": "None",
                "annotation": "bool",
                "description": null
              }
            },
            "source": {
              "code": "def __init__(self, *, _file: str = None, convert_arrays: bool = None):\n    convert_arrays = (\n        convert_arrays if convert_arrays is not None else CONVERT_ARRAYS\n    )\n    if hasattr(self, \"_initialized\"):\n        return\n    _file = _file or paths[\"DATABASE_FILE\"]\n    super().__init__(file=_file, convert_arrays=convert_arrays)\n    self.create_index_table()\n    self.clean()\n    self._initialized = True\n",
              "lines": [
                133,
                143
              ]
            }
          }
        },
        {
          "name": "DatabaseTable",
          "short_description": "Class to manage the table of a database. Multiton pattern. One table per",
          "docstring": "Class to manage the table of a database. Multiton pattern. One table per\ndatabase.",
          "methods": {
            "read_table": {
              "name": "read_table",
              "docstring": "Read the table of the database.\n",
              "signature": "(self) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "pandas.core.frame.DataFrame",
                "description": "table of the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef read_table(self) -> pd.DataFrame:\n    \"\"\"Read the table of the database.\n\n    Returns:\n        pd.DataFrame: table of the database\n    \"\"\"\n    df = pd.read_sql_query(f\"SELECT * FROM {self.tablename_db}\", self._conn)\n    # drop \"hidden\" columns which start with _\n    df = df.loc[:, ~df.columns.str.startswith(\"_\")]\n    df.rename(columns=lambda x: x.replace(DOT_REPLACEMENT, \".\"), inplace=True)\n    return df\n",
                "lines": [
                  380,
                  391
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "read_entry": {
              "name": "read_entry",
              "docstring": "Read an entry from the database.\n",
              "signature": "(self, entry_id: str) -> pandas.core.series.Series",
              "returns": {
                "annotation": "pandas.core.series.Series",
                "description": "entry from the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "entry_id": {
                  "default": null,
                  "annotation": "str",
                  "description": "ID of the entry"
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef read_entry(self, entry_id: str) -> pd.Series:\n    \"\"\"Read an entry from the database.\n\n    Args:\n        entry_id (str): ID of the entry\n\n    Returns:\n        pd.Series: entry from the database\n    \"\"\"\n    self._cursor.execute(\n        f\"SELECT * FROM {self.tablename_db} WHERE id=?\", (entry_id,)\n    )\n    series = pd.Series(*self._cursor.fetchall())\n    series.index = [description[0] for description in self._cursor.description]\n    series.rename(index=lambda x: x.replace(DOT_REPLACEMENT, \".\"), inplace=True)\n    return series\n",
                "lines": [
                  393,
                  409
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "read_column": {
              "name": "read_column",
              "docstring": "Read columns from the database.\n",
              "signature": "(self, *columns: str) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "pandas.core.frame.DataFrame",
                "description": "columns from the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "columns": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef read_column(self, *columns: str) -> pd.DataFrame:\n    \"\"\"Read columns from the database.\n\n    Args:\n        *columns (list): columns to read\n\n    Returns:\n        pd.DataFrame: columns from the database\n    \"\"\"\n    self._cursor.execute(f\"SELECT {', '.join(columns)} FROM {self.tablename_db}\")\n    df = pd.DataFrame.from_records(self._cursor.fetchall(), columns=columns)\n    df.rename(columns=lambda x: x.replace(DOT_REPLACEMENT, \".\"), inplace=True)\n    return df\n",
                "lines": [
                  411,
                  424
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "drop_table": {
              "name": "drop_table",
              "docstring": "Drop the table of the database.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef drop_table(self) -> None:\n    \"\"\"Drop the table of the database.\"\"\"\n    self._cursor.execute(f\"DROP TABLE {self.tablename_db}\")\n    self._cursor.execute(f\"DROP TABLE {self.tablename_update_times}\")\n",
                "lines": [
                  426,
                  430
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_database_table": {
              "name": "create_database_table",
              "docstring": "Create a table for a database.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef create_database_table(self) -> None:\n    \"\"\"Create a table for a database.\"\"\"\n    self._cursor.execute(\n        f\"\"\"CREATE TABLE IF NOT EXISTS {self.tablename_db} \n            (id TEXT PRIMARY KEY NOT NULL, time_stamp DATETIME, notes TEXT, processors INTEGER)\n        \"\"\"\n    )\n    self._cursor.execute(\n        f\"\"\"CREATE TABLE IF NOT EXISTS {self.tablename_update_times} (id TEXT PRIMARY KEY,\n            update_time DATETIME)\n        \"\"\"\n    )\n",
                "lines": [
                  432,
                  444
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "update_entry": {
              "name": "update_entry",
              "docstring": "Update an entry in the database.\n",
              "signature": "(self, entry_id: str, data: dict) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "entry_id": {
                  "default": null,
                  "annotation": "str",
                  "description": "ID of the entry"
                },
                "data": {
                  "default": null,
                  "annotation": "dict",
                  "description": "data to update"
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef update_entry(self, entry_id: str, data: dict) -> None:\n    \"\"\"Update an entry in the database.\n\n    Args:\n        entry_id (str): ID of the entry\n        data (dict): data to update\n    \"\"\"\n    # return if data is empty\n    if not data:\n        return\n\n    # get columns of table\n    self._cursor.execute(f\"PRAGMA table_info({self.tablename_db})\")\n    cols = self._cursor.fetchall()\n\n    # replace dots in keys\n    for key in list(data.keys()):\n        new_key = key.replace(\".\", DOT_REPLACEMENT)\n        new_key = _remove_illegal_column_characters(new_key)\n        if new_key != key:\n            data[new_key] = data.pop(key)\n\n    # check if columns exist\n    for key, val in data.items():\n        # key = key.replace(\".\", DOT_REPLACEMENT)\n        # key = _remove_illegal_column_characters(key)\n        if any(key == column[1] for column in cols):\n            continue\n        dtype = sql.get_sqlite_column_type(val)\n        self._cursor.execute(\n            f\"ALTER TABLE {self.tablename_db} ADD COLUMN [{key}] {dtype}\"\n        )\n\n    # insert data into table\n    data.pop(\"id\", None)\n\n    keys = \", \".join([f\"[{key}]\" for key in data.keys()])\n    values = \", \".join([f\":{key}\" for key in data.keys()])\n    updates = \", \".join([f\"[{key}] = excluded.[{key}]\" for key in data.keys()])\n\n    query = f\"\"\"\n    INSERT INTO {self.tablename_db} (id, {keys})\n    VALUES (:id, {values})\n    ON CONFLICT(id) DO UPDATE SET\n    {updates}\n    \"\"\"\n    data[\"id\"] = entry_id\n    self._cursor.execute(query, data)\n\n    # update update time\n    self._cursor.execute(\n        f\"INSERT OR REPLACE INTO {self.tablename_update_times} VALUES (?, ?)\",\n        (entry_id, time()),\n    )\n",
                "lines": [
                  446,
                  500
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "sync": {
              "name": "sync",
              "docstring": "Sync the table with the file system.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef sync(self) -> None:\n    \"\"\"Sync the table with the file system.\"\"\"\n    all_ids_fs = set(\n        [\n            i\n            for i in os.listdir(self.path)\n            if os.path.isdir(os.path.join(self.path, i))\n        ]\n    )\n\n    self._cursor.execute(\n        f\"SELECT id, update_time FROM {self.tablename_update_times}\"\n    )\n\n    for id, last_up_time in self._cursor.fetchall():\n        # remove entries that do not exist on the file system\n        if id not in all_ids_fs:\n            self._cursor.execute(\n                f\"DELETE FROM {self.tablename_db} WHERE id=?\", (id,)\n            )\n            self._cursor.execute(\n                f\"DELETE FROM {self.tablename_update_times} WHERE id=?\", (id,)\n            )\n            continue\n\n        # update entries that have been modified\n        all_ids_fs.remove(id)\n        if self.entry(id).mtime > last_up_time:\n            self.update_entry(id, self.entry(id).get_all_metadata())\n\n    # add new entries\n    for id in all_ids_fs:\n        self.update_entry(id, self.entry(id).get_all_metadata())\n",
                "lines": [
                  502,
                  535
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "entry": {
              "name": "entry",
              "docstring": "Get the Entry object of an entry.\nMultiton pattern. One Entry per entry.",
              "signature": "(self, entry_id: str) -> bamboost.index.Entry",
              "returns": {
                "annotation": "bamboost.index.Entry",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "entry_id": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "@sql.with_connection\ndef entry(self, entry_id: str) -> Entry:\n    \"\"\"Get the Entry object of an entry.\n    Multiton pattern. One Entry per entry.\n    \"\"\"\n    if entry_id not in self._entries:\n        self._entries[entry_id] = Entry(entry_id, self.path)\n    return self._entries[entry_id]\n",
                "lines": [
                  537,
                  544
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [
            {
              "name": "id",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "path",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "tablename_db",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "tablename_update_times",
              "annotation": null,
              "description": null,
              "default": ""
            }
          ],
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(self, id: str, *, _index: bamboost.index.IndexAPI = None)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "id": {
                "default": null,
                "annotation": "str",
                "description": null
              },
              "_index": {
                "default": "None",
                "annotation": "bamboost.index.IndexAPI",
                "description": null
              }
            },
            "source": {
              "code": "def __init__(self, id: str, *, _index: IndexAPI = None):\n    if hasattr(self, \"_initialized\"):\n        return\n\n    self.id = id\n    self._entries = {}\n    self._initialized = True\n    self._index = _index if _index is not None else IndexAPI()\n    self.path = self._index.get_path(self.id)\n    self.tablename_db = f\"db_{self.id}\"\n    self.tablename_update_times = f\"db_{self.id}_t\"\n    self.create_database_table()\n",
              "lines": [
                351,
                362
              ]
            }
          }
        },
        {
          "name": "Entry",
          "short_description": "Simulation entry in a database.",
          "docstring": "Simulation entry in a database.\nSimplified version of the Simulation class in the simulation module.",
          "methods": {
            "get_all_metadata": {
              "name": "get_all_metadata",
              "docstring": "Get all metadata of the entry.",
              "signature": "(self) -> dict",
              "returns": {
                "annotation": "dict",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def get_all_metadata(self) -> dict:\n    \"\"\"Get all metadata of the entry.\"\"\"\n    return {**self.metadata, **self.parameters}\n",
                "lines": [
                  578,
                  580
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [
            {
              "name": "id",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "path",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "h5file",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "metadata",
              "annotation": "dict",
              "description": "Get the metadata of the entry.",
              "default": ""
            },
            {
              "name": "parameters",
              "annotation": "dict",
              "description": "Get the parameters of the entry.",
              "default": ""
            },
            {
              "name": "mtime",
              "annotation": "float",
              "description": "Get the modification time of the entry.",
              "default": ""
            }
          ],
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(self, id: str, path: str)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "id": {
                "default": null,
                "annotation": "str",
                "description": null
              },
              "path": {
                "default": null,
                "annotation": "str",
                "description": null
              }
            },
            "source": {
              "code": "def __init__(self, id: str, path: str) -> None:\n    self.id = id\n    self.path = path\n    self.h5file = os.path.join(self.path, self.id, f\"{self.id}.h5\")\n",
              "lines": [
                553,
                556
              ]
            }
          }
        },
        {
          "name": "DatabaseNotFoundError",
          "short_description": "Exception raised when a database is not found in the index.",
          "docstring": "Exception raised when a database is not found in the index.",
          "methods": {},
          "properties": [],
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(self, /, *args, **kwargs)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "args": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "kwargs": {
                "default": null,
                "annotation": null,
                "description": null
              }
            },
            "source": {
              "code": "",
              "lines": null
            }
          }
        }
      ],
      "functions": [
        {
          "name": "find",
          "docstring": "Find the database with UID under given root_dir.\n",
          "signature": "(uid, root_dir) -> list",
          "returns": {
            "annotation": "list",
            "description": null
          },
          "arguments": {
            "uid": {
              "default": null,
              "annotation": null,
              "description": "UID to search for"
            },
            "root_dir": {
              "default": null,
              "annotation": null,
              "description": "root directory for search"
            }
          },
          "source": {
            "code": "def find(uid, root_dir) -> list:\n    \"\"\"Find the database with UID under given root_dir.\n\n    Args:\n        uid: UID to search for\n        root_dir: root directory for search\n    \"\"\"\n    if os.name == \"posix\":\n        paths = _find_posix(uid, root_dir)\n    else:\n        paths = _find_python(uid, root_dir)\n    if len(paths) > 1:\n        log.warning(f\"Multiple paths found for UID {uid}:\\n{paths}\")\n    return paths\n",
            "lines": [
              593,
              606
            ]
          },
          "props": {
            "isClassMethod": false
          },
          "examples": []
        },
        {
          "name": "get_uid_from_path",
          "docstring": "Returns the UID found in the specified path.",
          "signature": "(path: str) -> str",
          "returns": {
            "annotation": "str",
            "description": null
          },
          "arguments": {
            "path": {
              "default": null,
              "annotation": "str",
              "description": null
            }
          },
          "source": {
            "code": "def get_uid_from_path(path: str) -> str:\n    \"\"\"Returns the UID found in the specified path.\"\"\"\n    for file in os.listdir(path):\n        if file.startswith(\".BAMBOOST\"):\n            return file.split(\"-\")[1]\n    raise FileNotFoundError(\"No UID file found at specified path.\")\n",
            "lines": [
              609,
              614
            ]
          },
          "props": {
            "isClassMethod": false
          },
          "examples": []
        },
        {
          "name": "get_known_paths",
          "docstring": "",
          "signature": "() -> list",
          "returns": {
            "annotation": "list",
            "description": null
          },
          "arguments": {},
          "source": {
            "code": "def get_known_paths() -> list:\n    return config[\"index\"].get(\"paths\", [])\n",
            "lines": [
              617,
              618
            ]
          },
          "props": {
            "isClassMethod": false
          },
          "examples": []
        },
        {
          "name": "uid2",
          "docstring": "",
          "signature": "(uid) -> str",
          "returns": {
            "annotation": "str",
            "description": null
          },
          "arguments": {
            "uid": {
              "default": null,
              "annotation": null,
              "description": null
            }
          },
          "source": {
            "code": "def uid2(uid) -> str:\n    return f\"{PREFIX}{uid}\"\n",
            "lines": [
              639,
              640
            ]
          },
          "props": {
            "isClassMethod": false
          },
          "examples": []
        }
      ],
      "submodules": [],
      "examples": [],
      "version": null
    },
    {
      "name": "manager",
      "slug": [
        "bamboost",
        "manager"
      ],
      "docstring": "",
      "short_description": "",
      "attributes": [],
      "classes": [
        {
          "name": "Manager",
          "short_description": "View of database.",
          "docstring": "View of database.\n",
          "methods": {
            "__getitem__": {
              "name": "__getitem__",
              "docstring": "Returns the simulation in the specified row of the dataframe.\n",
              "signature": "(self, key: Union[str, int]) -> bamboost.simulation.Simulation",
              "returns": {
                "annotation": "bamboost.simulation.Simulation",
                "description": "The selected simulation object."
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": "Union[str, int]",
                  "description": "The simulation identifier (`str`) or the row index (`int`)."
                }
              },
              "source": {
                "code": "def __getitem__(self, key: Union[str, int]) -> Simulation:\n    \"\"\"Returns the simulation in the specified row of the dataframe.\n\n    Args:\n        key: The simulation identifier (`str`) or the row index (`int`).\n    Returns:\n        The selected simulation object.\n    \"\"\"\n    if isinstance(key, str):\n        return self.sim(key)\n    else:\n        return self.sim(self.df.loc[key, \"id\"])\n",
                "lines": [
                  130,
                  141
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "__len__": {
              "name": "__len__",
              "docstring": "",
              "signature": "(self) -> int",
              "returns": {
                "annotation": "int",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def __len__(self) -> int:\n    return len(self.all_uids)\n",
                "lines": [
                  156,
                  157
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "__iter__": {
              "name": "__iter__",
              "docstring": "",
              "signature": "(self) -> Generator[bamboost.simulation.Simulation, NoneType, NoneType]",
              "returns": {
                "annotation": "Generator[bamboost.simulation.Simulation, NoneType, NoneType]",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def __iter__(self) -> Generator[Simulation, None, None]:\n    for sim in self.sims():\n        yield sim\n",
                "lines": [
                  159,
                  161
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_view": {
              "name": "get_view",
              "docstring": "View of the database and its parametric space. Read from the sql\ndatabase. If `include_linked_sims` is True, the individual h5 files are\nscanned.",
              "signature": "(self, include_linked_sims: bool = False) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "pandas.core.frame.DataFrame",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "include_linked_sims": {
                  "default": "False",
                  "annotation": "bool",
                  "description": "if True, include the parameters of linked sims"
                }
              },
              "source": {
                "code": "def get_view(self, include_linked_sims: bool = False) -> pd.DataFrame:\n    \"\"\"View of the database and its parametric space. Read from the sql\n    database. If `include_linked_sims` is True, the individual h5 files are\n    scanned.\n\n    Args:\n        include_linked_sims: if True, include the parameters of linked sims\n\n    Examples:\n        >>> db.get_view()\n        >>> db.get_view(include_linked_sims=True)\n    \"\"\"\n    if include_linked_sims:\n        return self.get_view_from_hdf_files(include_linked_sims=include_linked_sims)\n\n    try:\n        with self._table.open():\n            self._table.sync()\n            df = self._table.read_table()\n    except index.Error as e:\n        log.warning(f\"index error: {e}\")\n        return self.get_view_from_hdf_files(include_linked_sims=include_linked_sims)\n\n    if df.empty:\n        return df\n    df[\"time_stamp\"] = pd.to_datetime(df[\"time_stamp\"])\n\n    # Sort dataframe columns\n    columns_start = [\"id\", \"notes\", \"status\", \"time_stamp\"]\n    columns_start = [col for col in columns_start if col in df.columns]\n    self._dataframe = df[[*columns_start, *df.columns.difference(columns_start)]]\n\n    opts = config.get(\"options\", {})\n    if \"sort_table_key\" in opts:\n        self._dataframe.sort_values(\n            opts.get(\"sort_table_key\", \"id\"),\n            ascending=opts.get(\"sort_table_order\", \"asc\") == \"asc\",\n            inplace=True,\n        )\n    return self._dataframe\n",
                "lines": [
                  267,
                  306
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> db.get_view()\n>>> db.get_view(include_linked_sims=True)"
              ]
            },
            "get_view_from_hdf_files": {
              "name": "get_view_from_hdf_files",
              "docstring": "View of the database and its parametric space. Read from the h5\nfiles metadata.",
              "signature": "(self, include_linked_sims: bool = False) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "pandas.core.frame.DataFrame",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "include_linked_sims": {
                  "default": "False",
                  "annotation": "bool",
                  "description": "if True, include the parameters of linked sims"
                }
              },
              "source": {
                "code": "def get_view_from_hdf_files(\n    self, include_linked_sims: bool = False\n) -> pd.DataFrame:\n    \"\"\"View of the database and its parametric space. Read from the h5\n    files metadata.\n\n    Args:\n        include_linked_sims: if True, include the parameters of linked sims\n    \"\"\"\n    all_uids = self._get_uids()\n    data = list()\n\n    for uid in all_uids:\n        tmp_dict = self._get_parameters_for_uid(\n            uid, include_linked_sims=include_linked_sims\n        )\n        data.append(tmp_dict)\n\n    df = pd.DataFrame.from_records(data)\n    if df.empty:\n        return df\n    df[\"time_stamp\"] = pd.to_datetime(df[\"time_stamp\"])\n\n    # Sort dataframe columns\n    columns_start = [\"id\", \"notes\", \"status\", \"time_stamp\"]\n    columns_start = [col for col in columns_start if col in df.columns]\n    self._dataframe = df[[*columns_start, *df.columns.difference(columns_start)]]\n    return self._dataframe\n",
                "lines": [
                  308,
                  335
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "sim": {
              "name": "sim",
              "docstring": "Get an existing simulation with uid. Same as accessing with `db[uid]` directly.\n",
              "signature": "(\n    self,\n    uid: str,\n    return_writer: bool = False,\n    writer_type: bamboost.simulation_writer.SimulationWriter = <class 'bamboost.simulation_writer.SimulationWriter'>\n) -> bamboost.simulation.Simulation",
              "returns": {
                "annotation": "bamboost.simulation.Simulation",
                "description": ":class:`~bamboost.simulation.Simulation`"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "uid": {
                  "default": null,
                  "annotation": "str",
                  "description": "unique identifier"
                },
                "return_writer": {
                  "default": "False",
                  "annotation": "bool",
                  "description": "if true, return `SimulationWriter`, otherwise\nreturn `Simulation`"
                },
                "writer_type": {
                  "default": "<class 'bamboost.simulation_writer.SimulationWriter'>",
                  "annotation": "bamboost.simulation_writer.SimulationWriter",
                  "description": "Optionally, you can specify a custom writer type to return."
                }
              },
              "source": {
                "code": "def sim(\n    self,\n    uid: str,\n    return_writer: bool = False,\n    writer_type: SimulationWriter = SimulationWriter,\n) -> Simulation:\n    \"\"\"Get an existing simulation with uid. Same as accessing with `db[uid]` directly.\n\n    Args:\n        uid (`str`): unique identifier\n        return_writer: if true, return `SimulationWriter`, otherwise\n            return `Simulation`\n        writer_type: Optionally, you can specify a custom writer type to return.\n\n    Returns:\n        :class:`~bamboost.simulation.Simulation`\n    \"\"\"\n    if return_writer:\n        return writer_type(uid, self.path, self.comm)\n    return Simulation(uid, self.path, self.comm, _db_id=self.UID)\n",
                "lines": [
                  363,
                  382
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "sims": {
              "name": "sims",
              "docstring": "Get all simulations in a list. Optionally, get all simulations matching the\ngiven selection using pandas.",
              "signature": "(\n    self,\n    select: pandas.core.series.Series | pandas.core.frame.DataFrame | dict = None,\n    sort: str = None,\n    reverse: bool = False,\n    exclude: set = None,\n    return_writer: bool = False\n) -> list[bamboost.simulation.Simulation]",
              "returns": {
                "annotation": "list[bamboost.simulation.Simulation]",
                "description": "A list of `:class:~bamboost.simulation.Simulation` objects"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "select": {
                  "default": "None",
                  "annotation": "pandas.core.series.Series | pandas.core.frame.DataFrame | dict",
                  "description": "Selection of simulations. Can be one of the following.\n- Pandas boolean series: A boolean series with the same length as the dataframe.\n- Pandas DataFrame: A subset of the full dataframe.\n- Dictionary: A dictionary with the parameters to select (see `find` for details)."
                },
                "sort": {
                  "default": "None",
                  "annotation": "str",
                  "description": "Optionally sort the list with this keyword"
                },
                "reverse": {
                  "default": "False",
                  "annotation": "bool",
                  "description": "swap sort direction"
                },
                "exclude": {
                  "default": "None",
                  "annotation": "set",
                  "description": "sims to exclude"
                },
                "return_writer": {
                  "default": "False",
                  "annotation": "bool",
                  "description": "if true, return `SimulationWriter`, otherwise\nreturn `Simulation`"
                }
              },
              "source": {
                "code": "def sims(\n    self,\n    select: pd.Series | pd.DataFrame | dict = None,\n    sort: str = None,\n    reverse: bool = False,\n    exclude: set = None,\n    return_writer: bool = False,\n) -> list[Simulation]:\n    \"\"\"Get all simulations in a list. Optionally, get all simulations matching the\n    given selection using pandas.\n\n    Args:\n        select: Selection of simulations. Can be one of the following.\n            - Pandas boolean series: A boolean series with the same length as the dataframe.\n            - Pandas DataFrame: A subset of the full dataframe.\n            - Dictionary: A dictionary with the parameters to select (see `find` for details).\n        sort (`str`): Optionally sort the list with this keyword\n        reverse (`bool`): swap sort direction\n        exclude (`list[str]`): sims to exclude\n        return_writer: if true, return `SimulationWriter`, otherwise\n            return `Simulation`\n\n    Returns:\n        A list of `:class:~bamboost.simulation.Simulation` objects\n\n    Examples:\n        >>> db.sims(select=db.df[\"status\"] == \"finished\", sort=\"time_stamp\")\n    \"\"\"\n    if select is None:\n        id_list = self.all_uids\n    elif isinstance(select, pd.DataFrame):\n        id_list = select[\"id\"].values\n    elif isinstance(select, pd.Series):\n        id_list = self.df[select][\"id\"].values\n    elif isinstance(select, dict):\n        id_list = self.find(select)[\"id\"].values\n    else:\n        raise ArgumentError('Invalid argument for argument \"select\"')\n\n    if exclude is not None:\n        exclude = list([exclude]) if isinstance(exclude, str) else exclude\n        id_list = [id for id in id_list if id not in exclude]\n\n    existing_sims = [self.sim(uid, return_writer) for uid in id_list]\n\n    if sort is None:\n        return existing_sims\n    else:\n        return sorted(\n            existing_sims, key=lambda s: s.parameters[sort], reverse=reverse\n        )\n",
                "lines": [
                  384,
                  434
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> db.sims(select=db.df[\"status\"] == \"finished\", sort=\"time_stamp\")"
              ]
            },
            "create_simulation": {
              "name": "create_simulation",
              "docstring": "Get a writer object for a new simulation. This is written for paralell use\nas it is likely that this may be used in an executable, creating multiple runs\nfor a parametric space, which may be run in paralell.",
              "signature": "(\n    self,\n    uid: str = None,\n    parameters: dict = None,\n    skip_duplicate_check: bool = False,\n    *,\n    prefix: str = None,\n    duplicate_action: str = 'prompt',\n    note: str = None,\n    files: list[str] = None,\n    links: dict[str, str] = None\n) -> bamboost.simulation_writer.SimulationWriter",
              "returns": {
                "annotation": "bamboost.simulation_writer.SimulationWriter",
                "description": "A simulation writer object."
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "uid": {
                  "default": "None",
                  "annotation": "str",
                  "description": "The name/uid for the simulation. If not specified, a random id\nwill be assigned."
                },
                "parameters": {
                  "default": "None",
                  "annotation": "dict",
                  "description": "Parameter dictionary. If provided, the parameters will be\nchecked against the existing sims for duplication. Otherwise, they may be\nspecified later with `bamboost.simulation_writer.SimulationWriter.add_parameters`.\nNote:\n    The parameters are stored in the h5 file as attributes.\n    - If the value is a dict, it is flattened using\n      `bamboost.common.utilities.flatten_dict`.\n    - If the value is a list/array, it is stored as a dataset."
                },
                "skip_duplicate_check": {
                  "default": "False",
                  "annotation": "bool",
                  "description": "if True, the duplicate check is skipped."
                },
                "prefix": {
                  "default": "None",
                  "annotation": "str",
                  "description": "Prefix for the uid. If not specified, no prefix is used."
                },
                "duplicate_action": {
                  "default": "prompt",
                  "annotation": "str",
                  "description": "how to deal with duplicates. Replace\nfirst duplicate ('r'), Create with altered uid (`c`), Create new\nwith new id (`n`), Abort (`a`) default \"prompt\" for each\nduplicate on a case by case basis."
                },
                "note": {
                  "default": "None",
                  "annotation": "str",
                  "description": "Note for the simulation."
                },
                "files": {
                  "default": "None",
                  "annotation": "list[str]",
                  "description": "List of files to copy to the simulation directory."
                },
                "links": {
                  "default": "None",
                  "annotation": "dict[str, str]",
                  "description": "Dictionary of links to other simulations."
                }
              },
              "source": {
                "code": "def create_simulation(\n    self,\n    uid: str = None,\n    parameters: dict = None,\n    skip_duplicate_check: bool = False,\n    *,\n    prefix: str = None,\n    duplicate_action: str = \"prompt\",\n    note: str = None,\n    files: list[str] = None,\n    links: dict[str, str] = None,\n) -> SimulationWriter:\n    \"\"\"Get a writer object for a new simulation. This is written for paralell use\n    as it is likely that this may be used in an executable, creating multiple runs\n    for a parametric space, which may be run in paralell.\n\n    Args:\n        uid (`str`): The name/uid for the simulation. If not specified, a random id\n            will be assigned.\n        parameters (`dict`): Parameter dictionary. If provided, the parameters will be\n            checked against the existing sims for duplication. Otherwise, they may be\n            specified later with `bamboost.simulation_writer.SimulationWriter.add_parameters`.\n            Note:\n                The parameters are stored in the h5 file as attributes.\n                - If the value is a dict, it is flattened using\n                  `bamboost.common.utilities.flatten_dict`.\n                - If the value is a list/array, it is stored as a dataset.\n        skip_duplicate_check (`bool`): if True, the duplicate check is skipped.\n        prefix (`str`): Prefix for the uid. If not specified, no prefix is used.\n        duplicate_action (`str`): how to deal with duplicates. Replace\n            first duplicate ('r'), Create with altered uid (`c`), Create new\n            with new id (`n`), Abort (`a`) default \"prompt\" for each\n            duplicate on a case by case basis.\n        note (`str`): Note for the simulation.\n        files (`list`): List of files to copy to the simulation directory.\n        links (`dict`): Dictionary of links to other simulations.\n\n    Note:\n        The files and links are copied to the simulation directory. The files are\n        copied with the same name as the original file. The links are copied with\n        the given name.\n\n    Examples:\n        >>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})\n\n        >>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")\n\n    Returns:\n        A simulation writer object.\n    \"\"\"\n    if parameters and not skip_duplicate_check:\n        go_on = True\n        if self.comm.rank == 0:\n            go_on, uid = self._check_duplicate(\n                parameters, uid, duplicate_action=duplicate_action\n            )\n        self.comm.bcast((go_on, uid), root=0)\n        if not go_on:\n            print(\"Aborting by user desire...\")\n            return None\n\n    if self.comm.rank == 0:\n        if not uid:\n            uid = uuid.uuid4().hex[:8]  # Assign random unique identifier\n        if isinstance(prefix, str) and prefix != \"\":\n            uid = \"_\".join([prefix, uid])\n    uid = self.comm.bcast(uid, root=0)\n\n    try:\n        # Create directory and h5 file\n        if self.comm.rank == 0:\n            os.makedirs(os.path.join(self.path, uid), exist_ok=True)\n            path_to_h5_file = os.path.join(self.path, uid, f\"{uid}.h5\")\n            if os.path.exists(path_to_h5_file):\n                os.remove(path_to_h5_file)\n            h5py.File(path_to_h5_file, \"a\").close()  # create file\n\n        new_sim = SimulationWriter(uid, self.path, self.comm)\n        new_sim.initialize()  # sets metadata and status\n        # add the id to the (fixed) _all_uids list\n        if hasattr(self, \"_all_uids\"):\n            self._all_uids.append(new_sim.uid)\n\n        # Add parameters, note, files, and links\n        if not any([parameters, note, files, links]):\n            return new_sim\n\n        with new_sim._file(\"r+\"):\n            if parameters:\n                new_sim.add_parameters(parameters)\n            if note:\n                new_sim.change_note(note)\n            if files:\n                new_sim.copy_file(files)\n            if links:\n                [\n                    new_sim.links.__setitem__(name, uid)\n                    for name, uid in links.items()\n                ]\n\n        return new_sim\n\n    except Exception as e:\n        # If any error occurs, remove the partially created simulation\n        if self.comm.rank == 0:\n            self.remove(uid)\n        raise e  # Re-raise the exception after cleanup\n",
                "lines": [
                  436,
                  542
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})",
                ">>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")"
              ]
            },
            "remove": {
              "name": "remove",
              "docstring": "CAUTION, DELETING DATA. Remove the data of a simulation.\n",
              "signature": "(self, uid: str) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "uid": {
                  "default": null,
                  "annotation": "str",
                  "description": "uid"
                }
              },
              "source": {
                "code": "def remove(self, uid: str) -> None:\n    \"\"\"CAUTION, DELETING DATA. Remove the data of a simulation.\n\n    Args:\n        uid (`str`): uid\n    \"\"\"\n    shutil.rmtree(os.path.join(self.path, uid))\n    self._table.sync()\n",
                "lines": [
                  544,
                  551
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "find": {
              "name": "find",
              "docstring": "Find simulations with the given parameters.\n\nThe dictionary can contain callables to filter inequalities or other\nfilters.",
              "signature": "(\n    self,\n    parameter_selection: dict[str, typing.Any]\n) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "pandas.core.frame.DataFrame",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "parameter_selection": {
                  "default": null,
                  "annotation": "dict[str, typing.Any]",
                  "description": "parameter selection dictionary"
                }
              },
              "source": {
                "code": "def find(self, parameter_selection: dict[str, Any]) -> pd.DataFrame:\n    \"\"\"Find simulations with the given parameters.\n\n    The dictionary can contain callables to filter inequalities or other\n    filters.\n\n    Examples:\n        >>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n        >>> db.find({\"a\": 1, \"b\": 2})\n\n    Args:\n        parameter_selection (dict): parameter selection dictionary\n    \"\"\"\n    parameter_selection = flatten_dict(parameter_selection)\n    params = {}\n    filters = {}\n    for key, val in parameter_selection.items():\n        if callable(val):\n            filters[key] = val\n        else:\n            params[key] = val\n\n    df = self.df\n    matches = self._list_duplicates(params, df=df)\n    matches = df[df.id.isin(matches)]\n    if len(matches) == 0:\n        return matches\n\n    for key, func in filters.items():\n        matches = matches[matches[key].apply(func)]\n\n    return matches\n",
                "lines": [
                  553,
                  584
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n>>> db.find({\"a\": 1, \"b\": 2})"
              ]
            },
            "global_fields_in_all": {
              "name": "global_fields_in_all",
              "docstring": "Get a list of all global fields in all simulations.\n",
              "signature": "(self) -> list",
              "returns": {
                "annotation": "list",
                "description": "List of global fields"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def global_fields_in_all(self) -> list:\n    \"\"\"Get a list of all global fields in all simulations.\n\n    Returns:\n        List of global fields\n    \"\"\"\n    fields = set()\n    for sim in self:\n        try:\n            fields.update(sim.globals.columns)\n        except KeyError:\n            continue\n\n    return fields\n",
                "lines": [
                  685,
                  698
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_parameters": {
              "name": "get_parameters",
              "docstring": "Get the parameters used in this database.\n",
              "signature": "(self) -> dict",
              "returns": {
                "annotation": "dict",
                "description": "Dictionary of parameters with it's count, range, and type. Sorted by count."
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def get_parameters(self) -> dict:\n    \"\"\"Get the parameters used in this database.\n\n    Returns:\n        Dictionary of parameters with it's count, range, and type. Sorted by count.\n    \"\"\"\n    parameters = dict()\n    for sim in self:\n        for key, val in sim.parameters.items():\n            if key not in parameters:\n                range = (val, val) if isinstance(val, numbers.Number) else None\n                parameters[key] = {\"range\": range, \"count\": 1, \"type\": type(val)}\n            else:\n                if isinstance(val, numbers.Number):\n                    parameters[key][\"range\"] = (\n                        min(parameters[key][\"range\"][0], val),\n                        max(parameters[key][\"range\"][1], val),\n                    )\n                parameters[key][\"count\"] += 1\n                parameters[key][\"type\"] = type(val)\n    return dict(\n        sorted(parameters.items(), key=lambda x: x[1][\"count\"], reverse=True)\n    )\n",
                "lines": [
                  700,
                  722
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [
            {
              "name": "FIX_DF",
              "annotation": null,
              "description": null,
              "default": "True"
            },
            {
              "name": "fromUID",
              "annotation": "bamboost.manager.ManagerFromUID",
              "description": null,
              "default": "<bamboost.manager.ManagerFromUID object>"
            },
            {
              "name": "fromName",
              "annotation": "bamboost.manager.ManagerFromName",
              "description": null,
              "default": "<bamboost.manager.ManagerFromName object>"
            },
            {
              "name": "path",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "comm",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "UID",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "all_uids",
              "annotation": "list",
              "description": null,
              "default": ""
            },
            {
              "name": "df",
              "annotation": "pandas.core.frame.DataFrame",
              "description": "View of the database and its parametric space.\n",
              "default": ""
            },
            {
              "name": "data_info",
              "annotation": "pandas.core.frame.DataFrame",
              "description": "Return view of stored data for all simulations\n",
              "default": ""
            }
          ],
          "inherits_from": {},
          "examples": [
            ">>> db = Manager(\"path/to/db\")\n>>> db.df # DataFrame of the database"
          ],
          "constructor": {
            "signature": "(\n    self,\n    path: str = None,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>,\n    uid: str = None,\n    create_if_not_exist: bool = True\n)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "path": {
                "default": "None",
                "annotation": "str",
                "description": null
              },
              "comm": {
                "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x7010845dcad0>",
                "annotation": "bamboost.common._mock_mpi.MockMPI.Comm",
                "description": null
              },
              "uid": {
                "default": "None",
                "annotation": "str",
                "description": null
              },
              "create_if_not_exist": {
                "default": "True",
                "annotation": "bool",
                "description": null
              }
            },
            "source": {
              "code": "def __init__(\n    self,\n    path: str = None,\n    comm: MPI.Comm = MPI.COMM_WORLD,\n    uid: str = None,\n    create_if_not_exist: bool = True,\n):\n    # provided uid has precedence\n    if uid is not None:\n        path = self._index.get_path(uid.upper())\n        path = comm.bcast(path, root=0)\n    self.path = path\n    self.comm = comm\n\n    # check if path exists\n    if not os.path.isdir(path):\n        if not create_if_not_exist:\n            raise NotADirectoryError(\"Specified path is not a valid path.\")\n        log.info(f\"Created new database ({path})\")\n        self._make_new(path)\n\n    # retrieve the UID of the database from the id file\n    # if not found, a new one is generated\n    self.UID = uid or self._retrieve_uid()\n\n    # Update the SQL table for the database\n    try:\n        with self._index.open():\n            self._index.insert_path(self.UID, self.path)\n            self._table.create_database_table()\n            self._table.sync()\n    except index.Error as e:\n        log.warning(f\"index error: {e}\")\n",
              "lines": [
                96,
                128
              ]
            }
          }
        },
        {
          "name": "ManagerFromUID",
          "short_description": "Get a database by its UID. This is used for autocompletion in ipython.",
          "docstring": "Get a database by its UID. This is used for autocompletion in ipython.",
          "methods": {
            "__getitem__": {
              "name": "__getitem__",
              "docstring": "",
              "signature": "(self, key) -> bamboost.manager.Manager",
              "returns": {
                "annotation": "bamboost.manager.Manager",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def __getitem__(self, key) -> Manager:\n    key = key.split()[0]  # take only uid\n    return Manager(uid=key, create_if_not_exist=False)\n",
                "lines": [
                  53,
                  55
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [
            {
              "name": "completion_keys",
              "annotation": null,
              "description": null,
              "default": ""
            }
          ],
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(self)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              }
            },
            "source": {
              "code": "def __init__(self) -> None:\n    # or [] to circumvent Null type (MPI)\n    ids = IndexAPI().fetch(f\"SELECT id, path FROM dbindex\") or []\n    self.completion_keys = tuple(\n        [f'{key} - {\"...\"+val[-25:] if len(val)>=25 else val}' for key, val in ids]\n    )\n",
              "lines": [
                43,
                48
              ]
            }
          }
        },
        {
          "name": "ManagerFromName",
          "short_description": "Get a database by its path/name. This is used for autocompletion in ipython.",
          "docstring": "Get a database by its path/name. This is used for autocompletion in ipython.",
          "methods": {
            "__getitem__": {
              "name": "__getitem__",
              "docstring": "",
              "signature": "(self, key) -> bamboost.manager.Manager",
              "returns": {
                "annotation": "bamboost.manager.Manager",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def __getitem__(self, key) -> Manager:\n    return Manager(key, create_if_not_exist=False)\n",
                "lines": [
                  68,
                  69
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [
            {
              "name": "completion_keys",
              "annotation": null,
              "description": null,
              "default": ""
            }
          ],
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(self)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              }
            },
            "source": {
              "code": "def __init__(self) -> None:\n    paths = IndexAPI().fetch(\"SELECT path FROM dbindex\") or []\n    self.completion_keys = tuple(paths)\n",
              "lines": [
                61,
                63
              ]
            }
          }
        }
      ],
      "functions": [],
      "submodules": [],
      "examples": [],
      "version": null
    },
    {
      "name": "simulation",
      "slug": [
        "bamboost",
        "simulation"
      ],
      "docstring": "",
      "short_description": "",
      "attributes": [],
      "classes": [
        {
          "name": "Simulation",
          "short_description": "A single dataset/simulation. Used to write to it, read from it or append.",
          "docstring": "A single dataset/simulation. Used to write to it, read from it or append.\n",
          "methods": {
            "fromUID": {
              "name": "fromUID",
              "docstring": "Return the `Simulation` with given UID.\n",
              "signature": "(full_uid: str, *, index_database: bamboost.index.IndexAPI = None) -> Self",
              "returns": {
                "annotation": "Self",
                "description": null
              },
              "arguments": {
                "full_uid": {
                  "default": null,
                  "annotation": "str",
                  "description": "the full id (Database uid : simulation uid)"
                },
                "index_database": {
                  "default": "None",
                  "annotation": "bamboost.index.IndexAPI",
                  "description": null
                }
              },
              "source": {
                "code": "@classmethod\ndef fromUID(cls, full_uid: str, *, index_database: index.IndexAPI = None) -> Self:\n    \"\"\"Return the `Simulation` with given UID.\n\n    Args:\n        full_uid: the full id (Database uid : simulation uid)\n    \"\"\"\n    if index_database is None:\n        index_database = index.IndexAPI()\n    db_uid, sim_uid = full_uid.split(\":\")\n    db_path = index_database.get_path(db_uid)\n    return cls(sim_uid, db_path, create_if_not_exists=False)\n",
                "lines": [
                  137,
                  148
                ]
              },
              "props": {
                "isClassMethod": true
              },
              "examples": []
            },
            "__getitem__": {
              "name": "__getitem__",
              "docstring": "Direct access to HDF5 file.\n",
              "signature": "(self, key) -> bamboost.common.hdf_pointer.BasePointer",
              "returns": {
                "annotation": "bamboost.common.hdf_pointer.BasePointer",
                "description": ":class:`~bamboost.common.file_handler.BasePointer`"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@with_file_open()\ndef __getitem__(self, key) -> hdf_pointer.BasePointer:\n    \"\"\"Direct access to HDF5 file.\n\n    Returns:\n        :class:`~bamboost.common.file_handler.BasePointer`\n    \"\"\"\n    return hdf_pointer.BasePointer.new_pointer(self._file, key)\n",
                "lines": [
                  150,
                  157
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "files": {
              "name": "files",
              "docstring": "Get the path to the file.\n",
              "signature": "(self, filename: str) -> str",
              "returns": {
                "annotation": "str",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "filename": {
                  "default": null,
                  "annotation": "str",
                  "description": "name of the file"
                }
              },
              "source": {
                "code": "def files(self, filename: str) -> str:\n    \"\"\"Get the path to the file.\n\n    Args:\n        filename: name of the file\n    \"\"\"\n    return os.path.join(self.path, filename)\n",
                "lines": [
                  255,
                  261
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "show_files": {
              "name": "show_files",
              "docstring": "Show the file tree of the simulation directory.\n",
              "signature": "(\n    self,\n    level=-1,\n    limit_to_directories=False,\n    length_limit=1000,\n    printit=True\n) -> str",
              "returns": {
                "annotation": "str",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "level": {
                  "default": "-1",
                  "annotation": null,
                  "description": "how deep to print the tree"
                },
                "limit_to_directories": {
                  "default": "False",
                  "annotation": null,
                  "description": "only print directories"
                },
                "length_limit": {
                  "default": "1000",
                  "annotation": null,
                  "description": "cutoff"
                },
                "printit": {
                  "default": "True",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def show_files(\n    self, level=-1, limit_to_directories=False, length_limit=1000, printit=True\n) -> str:\n    \"\"\"Show the file tree of the simulation directory.\n\n    Args:\n        level: how deep to print the tree\n        limit_to_directories: only print directories\n        length_limit: cutoff\n    \"\"\"\n    tree_string = utilities.tree(\n        self.path, level, limit_to_directories, length_limit\n    )\n    if printit:\n        print(tree_string)\n    else:\n        return tree_string\n",
                "lines": [
                  263,
                  279
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "open_in_file_explorer": {
              "name": "open_in_file_explorer",
              "docstring": "Open the simulation directory. Uses `xdg-open` on linux systems.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def open_in_file_explorer(self) -> None:\n    \"\"\"Open the simulation directory. Uses `xdg-open` on linux systems.\"\"\"\n    if os.name == \"nt\":  # should work on Windows\n        os.startfile(self.path)\n    else:\n        subprocess.run([\"xdg-open\", self.path])\n",
                "lines": [
                  281,
                  286
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "open_in_paraview": {
              "name": "open_in_paraview",
              "docstring": "Open the xdmf file in paraview.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def open_in_paraview(self) -> None:\n    \"\"\"Open the xdmf file in paraview.\"\"\"\n    subprocess.Popen([\"paraview\", self.xdmffile])\n",
                "lines": [
                  288,
                  290
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_full_uid": {
              "name": "get_full_uid",
              "docstring": "Returns the full uid of the simulation (including the one of the database)",
              "signature": "(self) -> str",
              "returns": {
                "annotation": "str",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def get_full_uid(self) -> str:\n    \"\"\"Returns the full uid of the simulation (including the one of the database)\"\"\"\n    database_uid = index.get_uid_from_path(self.path_database)\n    return f\"{database_uid}:{self.uid}\"\n",
                "lines": [
                  292,
                  295
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "change_status": {
              "name": "change_status",
              "docstring": "Change status of simulation.\n",
              "signature": "(self, status: str) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "status": {
                  "default": null,
                  "annotation": "str",
                  "description": "new status"
                }
              },
              "source": {
                "code": "def change_status(self, status: str) -> None:\n    \"\"\"Change status of simulation.\n\n    Args:\n        status (str): new status\n    \"\"\"\n    if self._prank == 0:\n        self._file.open(\"a\")\n        self._file.attrs[\"status\"] = status\n        self._file.close()\n\n    self._push_update_to_sqlite({\"status\": status})\n",
                "lines": [
                  297,
                  308
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "update_metadata": {
              "name": "update_metadata",
              "docstring": "Update the metadata attributes.\n",
              "signature": "(self, update_dict: dict) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "update_dict": {
                  "default": null,
                  "annotation": "dict",
                  "description": "dictionary to push"
                }
              },
              "source": {
                "code": "def update_metadata(self, update_dict: dict) -> None:\n    \"\"\"Update the metadata attributes.\n\n    Args:\n        update_dict: dictionary to push\n    \"\"\"\n    if self._prank == 0:\n        update_dict = utilities.flatten_dict(update_dict)\n        with self._file(\"a\") as file:\n            file.attrs.update(update_dict)\n\n        self._push_update_to_sqlite(update_dict)\n",
                "lines": [
                  310,
                  321
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "update_parameters": {
              "name": "update_parameters",
              "docstring": "Update the parameters dictionary.\n",
              "signature": "(self, update_dict: dict) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "update_dict": {
                  "default": null,
                  "annotation": "dict",
                  "description": "dictionary to push"
                }
              },
              "source": {
                "code": "def update_parameters(self, update_dict: dict) -> None:\n    \"\"\"Update the parameters dictionary.\n\n    Args:\n        update_dict: dictionary to push\n    \"\"\"\n    if self._prank == 0:\n        update_dict = utilities.flatten_dict(update_dict)\n        with self._file(\"a\") as file:\n            file[\"parameters\"].attrs.update(update_dict)\n\n        self._push_update_to_sqlite(update_dict)\n",
                "lines": [
                  323,
                  334
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_xdmf_file": {
              "name": "create_xdmf_file",
              "docstring": "Create the xdmf file to read in paraview.\n",
              "signature": "(self, fields: list = None, nb_steps: int = None) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "fields": {
                  "default": "None",
                  "annotation": "list",
                  "description": "fields for which to write timeseries information,\nif not specified, all fields in data are written."
                },
                "nb_steps": {
                  "default": "None",
                  "annotation": "int",
                  "description": "number of steps the simulation has"
                }
              },
              "source": {
                "code": "def create_xdmf_file(self, fields: list = None, nb_steps: int = None) -> None:\n    \"\"\"Create the xdmf file to read in paraview.\n\n    Args:\n        fields (list[str]): fields for which to write timeseries information,\n            if not specified, all fields in data are written.\n        nb_steps (int): number of steps the simulation has\n    \"\"\"\n\n    if self._prank == 0:\n        with self._file(\"r\"):\n            f = self._file.file_object\n            if \"data\" not in f.keys():\n                fields, nb_steps = [], 0\n            if fields is None:\n                fields = list(f[\"data\"].keys())\n\n            if nb_steps is None:\n                grp_name = list(f[\"data\"].keys())[0]\n                nb_steps = list(f[f\"data/{grp_name}\"].keys())\n                nb_steps = max(\n                    [\n                        int(step)\n                        for step in nb_steps\n                        if not (\n                            step.startswith(\"__\") or step.endswith(\"_intermediates\")\n                        )\n                    ]\n                )\n\n            # temporary fix to load coordinates/geometry\n            coords_name = (\n                \"geometry\"\n                if \"geometry\"\n                in f[f\"{self._mesh_location}/{self._default_mesh}\"].keys()\n                else \"coordinates\"\n            )\n\n        with self._file(\"r\"):\n            xdmf_writer = XDMFWriter(self.xdmffile, self._file)\n            xdmf_writer.write_points_cells(\n                f\"{self._mesh_location}/{self._default_mesh}/{coords_name}\",\n                f\"{self._mesh_location}/{self._default_mesh}/topology\",\n            )\n\n            if fields:\n                xdmf_writer.add_timeseries(nb_steps + 1, fields)\n            xdmf_writer.write_file()\n\n    self._comm.barrier()\n",
                "lines": [
                  336,
                  385
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_run_script": {
              "name": "create_run_script",
              "docstring": "Create a batch job and put it into the folder.\n",
              "signature": "(\n    self,\n    commands: list[str],\n    euler: bool = True,\n    sbatch_kwargs: dict[str, typing.Any] = None\n) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "commands": {
                  "default": null,
                  "annotation": "list[str]",
                  "description": "A list of strings being the user defined commands to run"
                },
                "euler": {
                  "default": "True",
                  "annotation": "bool",
                  "description": "If false, a local bash script will be written"
                },
                "sbatch_kwargs": {
                  "default": "None",
                  "annotation": "dict[str, typing.Any]",
                  "description": "Additional sbatch arguments.\nThis parameter allows you to provide additional arguments to the `sbatch` command\nwhen submitting jobs to a Slurm workload manager. The arguments should be provided\nin the format of a dict of sbatch option name and values.\n\nUse this parameter to specify various job submission options such as the number of\ntasks, CPU cores, memory requirements, email notifications, and other sbatch options\nthat are not covered by default settings.\nBy default, the following sbatch options are set:\n- `--output`: The output file is set to `<uid>.out`.\n- `--job-name`: The job name is set to `<full_uid>`.\n\nThe following arguments should bring you far:\n- `--ntasks`: The number of tasks to run. This is the number of MPI processes to start.\n- `--mem-per-cpu`: The memory required per CPU core.\n- `--time`: The maximum time the job is allowed to run.\n- `--tmp`: Temporary scratch space to use for the job."
                }
              },
              "source": {
                "code": "def create_run_script(\n    self,\n    commands: list[str],\n    euler: bool = True,\n    sbatch_kwargs: dict[str, Any] = None,\n) -> None:\n    \"\"\"Create a batch job and put it into the folder.\n\n    Args:\n        commands: A list of strings being the user defined commands to run\n        euler: If false, a local bash script will be written\n        sbatch_kwargs: Additional sbatch arguments.\n            This parameter allows you to provide additional arguments to the `sbatch` command\n            when submitting jobs to a Slurm workload manager. The arguments should be provided\n            in the format of a dict of sbatch option name and values.\n\n            Use this parameter to specify various job submission options such as the number of\n            tasks, CPU cores, memory requirements, email notifications, and other sbatch options\n            that are not covered by default settings.\n            By default, the following sbatch options are set:\n            - `--output`: The output file is set to `<uid>.out`.\n            - `--job-name`: The job name is set to `<full_uid>`.\n\n            The following arguments should bring you far:\n            - `--ntasks`: The number of tasks to run. This is the number of MPI processes to start.\n            - `--mem-per-cpu`: The memory required per CPU core.\n            - `--time`: The maximum time the job is allowed to run.\n            - `--tmp`: Temporary scratch space to use for the job.\n    \"\"\"\n\n    def _set_environment_variables():\n        return (\n            f\"\"\"DATABASE_DIR=$(sqlite3 {paths['DATABASE_FILE']} \"SELECT path FROM dbindex WHERE id='{self.database_id}'\")\\n\"\"\"\n            f\"SIMULATION_DIR=$DATABASE_DIR/{self.uid}\\n\"\n            f\"SIMULATION_ID={self.database_id}:{self.uid}\\n\\n\"\n        )\n\n    script = \"#!/bin/bash\\n\\n\"\n    if euler:\n        # Write sbatch submission script for EULER\n        # filename: sbatch_{self.uid}.sh\n        if sbatch_kwargs is None:\n            sbatch_kwargs = {}\n\n        sbatch_kwargs.setdefault(\"--output\", f\"{self.path}/{self.uid}.out\")\n        sbatch_kwargs.setdefault(\"--job-name\", self.get_full_uid())\n\n        for key, value in sbatch_kwargs.items():\n            script += f\"#SBATCH {key}={value}\\n\"\n\n        script += \"\\n\"\n        script += _set_environment_variables()\n        script += \"\\n\".join(commands)\n\n        with open(self.files(f\"sbatch_{self.uid}.sh\"), \"w\") as file:\n            file.write(script)\n    else:\n        # Write local bash script\n        # filename: {self.uid}.sh\n        script += _set_environment_variables()\n        script += \"\\n\".join(commands)\n\n        with open(self.files(f\"{self.uid}.sh\"), \"w\") as file:\n            file.write(script)\n\n    with self._file(\"a\") as file:\n        file.attrs.update({\"submitted\": False})\n    self._push_update_to_sqlite({\"submitted\": False})\n",
                "lines": [
                  387,
                  454
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_batch_script": {
              "name": "create_batch_script",
              "docstring": "",
              "signature": "(self, *args, **kwargs)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "args": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "kwargs": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@deprecated(\"use `create_run_script` instead\")\ndef create_batch_script(self, *args, **kwargs):\n    return self.create_run_script(*args, **kwargs)\n",
                "lines": [
                  456,
                  458
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "submit": {
              "name": "submit",
              "docstring": "Submit the job for this simulation.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def submit(self) -> None:\n    \"\"\"Submit the job for this simulation.\"\"\"\n    if f\"sbatch_{self.uid}.sh\" in os.listdir(self.path):\n        batch_script = os.path.abspath(\n            os.path.join(self.path, f\"sbatch_{self.uid}.sh\")\n        )\n        env = os.environ.copy()\n        _ = env.pop(\"BAMBOOST_MPI\", None)\n        subprocess.run([\"sbatch\", f\"{batch_script}\"], env=env)\n    elif f\"{self.uid}.sh\" in os.listdir(self.path):\n        bash_script = os.path.abspath(os.path.join(self.path, f\"{self.uid}.sh\"))\n        env = os.environ.copy()\n        _ = env.pop(\"BAMBOOST_MPI\", None)\n        subprocess.run([\"bash\", f\"{bash_script}\"], env=env)\n    else:\n        raise FileNotFoundError(\n            f\"Could not find a batch script for simulation {self.uid}.\"\n        )\n\n    log.info(f\"Simulation {self.uid} submitted!\")\n\n    with self._file(\"a\") as file:\n        file.attrs.update({\"submitted\": True})\n\n    self._push_update_to_sqlite({\"submitted\": True})\n",
                "lines": [
                  460,
                  484
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "change_note": {
              "name": "change_note",
              "docstring": "",
              "signature": "(self, note) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "note": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@with_file_open(\"a\")\ndef change_note(self, note) -> None:\n    if self._prank == 0:\n        self._file.attrs[\"notes\"] = note\n        self._push_update_to_sqlite({\"notes\": note})\n",
                "lines": [
                  486,
                  490
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "open": {
              "name": "open",
              "docstring": "Use this as a context manager in a `with` statement.\nPurpose: keeping the file open to directly access/edit something in the\nHDF5 file of this simulation.",
              "signature": "(\n    self,\n    mode: str = 'r',\n    driver=None,\n    comm=None\n) -> bamboost.common.file_handler.FileHandler",
              "returns": {
                "annotation": "bamboost.common.file_handler.FileHandler",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "mode": {
                  "default": "r",
                  "annotation": "str",
                  "description": "file mode (see h5py docs)"
                },
                "driver": {
                  "default": "None",
                  "annotation": null,
                  "description": "file driver (see h5py docs)"
                },
                "comm": {
                  "default": "None",
                  "annotation": null,
                  "description": "mpi communicator"
                }
              },
              "source": {
                "code": "def open(self, mode: str = \"r\", driver=None, comm=None) -> FileHandler:\n    \"\"\"Use this as a context manager in a `with` statement.\n    Purpose: keeping the file open to directly access/edit something in the\n    HDF5 file of this simulation.\n\n    Args:\n        mode (`str`): file mode (see h5py docs)\n        driver (`str`): file driver (see h5py docs)\n        comm (`str`): mpi communicator\n    \"\"\"\n    return self._file(mode, driver, comm)\n",
                "lines": [
                  495,
                  505
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_mesh": {
              "name": "get_mesh",
              "docstring": "Return coordinates and connectivity. Currently returns numpy arrays.\n",
              "signature": "(self, mesh_name: str = None) -> Tuple[numpy.ndarray, numpy.ndarray]",
              "returns": {
                "annotation": "Tuple[numpy.ndarray, numpy.ndarray]",
                "description": "Tuple of np.arrays (coordinates, connectivity)"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "mesh_name": {
                  "default": "None",
                  "annotation": "str",
                  "description": "optional, name of mesh to read (default = mesh)"
                }
              },
              "source": {
                "code": "@with_file_open(\"r\")\ndef get_mesh(self, mesh_name: str = None) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Return coordinates and connectivity. Currently returns numpy arrays.\n\n    Args:\n        mesh_name (`str`): optional, name of mesh to read (default = mesh)\n    Returns:\n        Tuple of np.arrays (coordinates, connectivity)\n    \"\"\"\n    if mesh_name is None:\n        mesh_name = self._default_mesh\n\n    # Raise an error if the mesh is not found\n    if (self._mesh_location.split(\"/\")[0] not in self._file.keys()) or (\n        mesh_name not in self._file[self._mesh_location].keys()\n    ):\n        raise KeyError(f\"Mesh location {self._mesh_location} not found in file.\")\n\n    mesh = self.meshes[mesh_name]\n    return mesh.coordinates, mesh.connectivity\n",
                "lines": [
                  516,
                  535
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_data_interpolator": {
              "name": "get_data_interpolator",
              "docstring": "Get Linear interpolator for data field at step. Uses the linked mesh.\n",
              "signature": "(self, field: str, step: int)",
              "returns": {
                "annotation": null,
                "description": ":class:`scipy.interpolate.LinearNDInterpolator`"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "field": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                },
                "step": {
                  "default": null,
                  "annotation": "int",
                  "description": "step"
                }
              },
              "source": {
                "code": "def get_data_interpolator(self, field: str, step: int):\n    \"\"\"Get Linear interpolator for data field at step. Uses the linked mesh.\n\n    Args:\n        name (`str`): name of the data field\n        step (`int`): step\n    Returns:\n        :class:`scipy.interpolate.LinearNDInterpolator`\n    \"\"\"\n    from scipy.interpolate import LinearNDInterpolator\n\n    return LinearNDInterpolator(\n        self.data[field].mesh.coordinates, self.data[field].at_step(step)\n    )\n",
                "lines": [
                  574,
                  587
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "show_h5tree": {
              "name": "show_h5tree",
              "docstring": "Print the tree inside the h5 file.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@with_file_open()\ndef show_h5tree(self) -> None:\n    \"\"\"Print the tree inside the h5 file.\"\"\"\n    # print('\\U00002B57 ' + os.path.basename(self.h5file))\n    print(\"\\U0001f43c \" + os.path.basename(self.h5file))\n    utilities.h5_tree(self._file.file_object)\n",
                "lines": [
                  589,
                  594
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "enter_path": {
              "name": "enter_path",
              "docstring": "A context manager for changing the working directory to this simulations' path.\n\n>>> with sim.working_directory():\n>>>     ...",
              "signature": "(self)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@contextmanager\ndef enter_path(self):\n    \"\"\"A context manager for changing the working directory to this simulations' path.\n\n    >>> with sim.working_directory():\n    >>>     ...\n    \"\"\"\n\n    current_dir = os.getcwd()\n    try:\n        os.chdir(self.path)\n        yield\n    finally:\n        os.chdir(current_dir)\n",
                "lines": [
                  596,
                  609
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [
            {
              "name": "uid",
              "annotation": "str",
              "description": null,
              "default": ""
            },
            {
              "name": "path_database",
              "annotation": "str",
              "description": null,
              "default": ""
            },
            {
              "name": "database_id",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "path",
              "annotation": "str",
              "description": null,
              "default": ""
            },
            {
              "name": "h5file",
              "annotation": "str",
              "description": null,
              "default": ""
            },
            {
              "name": "xdmffile",
              "annotation": "str",
              "description": null,
              "default": ""
            },
            {
              "name": "meshes",
              "annotation": "bamboost.accessors.meshes.MeshGroup",
              "description": null,
              "default": ""
            },
            {
              "name": "data",
              "annotation": "bamboost.accessors.fielddata.DataGroup",
              "description": null,
              "default": ""
            },
            {
              "name": "globals",
              "annotation": "bamboost.accessors.globals.GlobalGroup",
              "description": null,
              "default": ""
            },
            {
              "name": "userdata",
              "annotation": "bamboost.common.hdf_pointer.MutableGroup",
              "description": null,
              "default": ""
            },
            {
              "name": "links",
              "annotation": "bamboost.simulation.Links",
              "description": null,
              "default": ""
            },
            {
              "name": "parameters",
              "annotation": "Dict[str, Any]",
              "description": null,
              "default": ""
            },
            {
              "name": "metadata",
              "annotation": "dict",
              "description": null,
              "default": ""
            },
            {
              "name": "mesh",
              "annotation": "bamboost.accessors.meshes.Mesh",
              "description": "Return the default mesh.\n",
              "default": ""
            },
            {
              "name": "data_info",
              "annotation": "pandas.core.frame.DataFrame",
              "description": "View the data stored.\n",
              "default": ""
            },
            {
              "name": "git",
              "annotation": "dict",
              "description": "Get Git information.\n",
              "default": ""
            }
          ],
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(\n    self,\n    uid: str,\n    path: str,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>,\n    create_if_not_exists: bool = False,\n    *,\n    _db_id: str = None\n)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "uid": {
                "default": null,
                "annotation": "str",
                "description": null
              },
              "path": {
                "default": null,
                "annotation": "str",
                "description": null
              },
              "comm": {
                "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x7010845dcad0>",
                "annotation": "bamboost.common._mock_mpi.MockMPI.Comm",
                "description": null
              },
              "create_if_not_exists": {
                "default": "False",
                "annotation": "bool",
                "description": null
              },
              "_db_id": {
                "default": "None",
                "annotation": "str",
                "description": null
              }
            },
            "source": {
              "code": "def __init__(\n    self,\n    uid: str,\n    path: str,\n    comm: MPI.Comm = MPI.COMM_WORLD,\n    create_if_not_exists: bool = False,\n    *,\n    _db_id: str = None,\n):\n    self.uid: str = uid\n    path = comm.bcast(path, root=0)\n    self.path_database: str = os.path.abspath(path)\n    self.database_id = _db_id or index.get_uid_from_path(self.path_database)\n    self.path: str = os.path.abspath(os.path.join(path, uid))\n    self.h5file: str = os.path.join(self.path, f\"{self.uid}.h5\")\n    self.xdmffile: str = os.path.join(self.path, f\"{self.uid}.xdmf\")\n\n    if not os.path.exists(self.h5file) and not create_if_not_exists:\n        raise FileNotFoundError(\n            f\"Simulation {self.uid} does not exist in {self.path}.\"\n        )\n\n    os.makedirs(self.path, exist_ok=True)\n\n    # MPI information\n    self._comm = comm\n    self._psize = self._comm.size\n    self._prank = self._comm.rank\n    self._ranks = np.array([i for i in range(self._psize)])\n\n    self._file = FileHandler(self.h5file)\n\n    # Initialize groups to meshes, data and userdata. Create groups.\n    self.meshes: MeshGroup = MeshGroup(self._file)\n    self.data: DataGroup = DataGroup(self._file, self.meshes)\n    self.globals: GlobalGroup = GlobalGroup(self._file, \"/globals\")\n    self.userdata: hdf_pointer.MutableGroup = hdf_pointer.MutableGroup(\n        self._file, \"/userdata\"\n    )\n    self.links: Links = Links(self._file)\n",
              "lines": [
                96,
                135
              ]
            }
          }
        },
        {
          "name": "Links",
          "short_description": "Link group. Used to create and access links.",
          "docstring": "Link group. Used to create and access links.\n\nI don't know how to distribute this to its own file in the accessors\ndirectory, due to circular imports.",
          "methods": {
            "__getitem__": {
              "name": "__getitem__",
              "docstring": "Returns the linked simulation object.",
              "signature": "(self, key) -> bamboost.simulation.Simulation",
              "returns": {
                "annotation": "bamboost.simulation.Simulation",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@with_file_open(\"r\", driver=\"mpio\")\ndef __getitem__(self, key) -> Simulation:\n    \"\"\"Returns the linked simulation object.\"\"\"\n    return Simulation.fromUID(self.obj.attrs[key])\n",
                "lines": [
                  53,
                  56
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "__setitem__": {
              "name": "__setitem__",
              "docstring": "Creates the link.",
              "signature": "(self, key, newvalue)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "newvalue": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def __setitem__(self, key, newvalue):\n    \"\"\"Creates the link.\"\"\"\n    return self.update_attrs({key: newvalue})\n",
                "lines": [
                  58,
                  60
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "all_links": {
              "name": "all_links",
              "docstring": "",
              "signature": "(self) -> dict",
              "returns": {
                "annotation": "dict",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "@with_file_open(\"r\")\ndef all_links(self) -> dict:\n    return dict(self.obj.attrs)\n",
                "lines": [
                  79,
                  81
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [],
          "inherits_from": {
            "bamboost.common.hdf_pointer.MutableGroup": {
              "module": "bamboost.common.hdf_pointer",
              "members": [
                [
                  "function",
                  "update_attrs"
                ],
                [
                  "function",
                  "add_dataset"
                ],
                [
                  "function",
                  "require_group"
                ]
              ]
            },
            "bamboost.common.hdf_pointer.Group": {
              "module": "bamboost.common.hdf_pointer",
              "members": [
                [
                  "function",
                  "__iter__"
                ],
                [
                  "function",
                  "keys"
                ],
                [
                  "function",
                  "groups"
                ],
                [
                  "function",
                  "datasets"
                ],
                [
                  "function",
                  "extract_attrs"
                ]
              ]
            },
            "bamboost.common.hdf_pointer.BasePointer": {
              "module": "bamboost.common.hdf_pointer",
              "members": [
                [
                  "function",
                  "new_pointer"
                ],
                [
                  "variable",
                  "path_to_data"
                ],
                [
                  "variable",
                  "obj"
                ],
                [
                  "variable",
                  "attrs"
                ]
              ]
            }
          },
          "examples": [],
          "constructor": {
            "signature": "(self, file_handler: bamboost.common.file_handler.FileHandler)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "file_handler": {
                "default": null,
                "annotation": "bamboost.common.file_handler.FileHandler",
                "description": null
              }
            },
            "source": {
              "code": "def __init__(self, file_handler: FileHandler) -> None:\n    super().__init__(file_handler, path_to_data=\"links\")\n",
              "lines": [
                47,
                48
              ]
            }
          }
        }
      ],
      "functions": [],
      "submodules": [],
      "examples": [],
      "version": null
    },
    {
      "name": "simulation_writer",
      "slug": [
        "bamboost",
        "simulation_writer"
      ],
      "docstring": "",
      "short_description": "",
      "attributes": [],
      "classes": [
        {
          "name": "SimulationWriter",
          "short_description": "The SimulationWriter is the writer object for a single simulation. It inherits",
          "docstring": "The SimulationWriter is the writer object for a single simulation. It inherits\nall reading methods from :class:`Simulation`.\n\nThis class can be used as a context manager. When entering the context, the status\nof the simulation is changed to \"Started\". When an exception is raised inside the\ncontext, the status is changed to \"Failed [Exception]\".",
          "methods": {
            "initialize": {
              "name": "initialize",
              "docstring": "Create a new file for this simlation.\nThis deletes an existing h5 file of the simulation and creates an empty new one",
              "signature": "(self) -> bamboost.simulation_writer.SimulationWriter",
              "returns": {
                "annotation": "bamboost.simulation_writer.SimulationWriter",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def initialize(self) -> SimulationWriter:\n    \"\"\"Create a new file for this simlation.\n    This deletes an existing h5 file of the simulation and creates an empty new one\n    \"\"\"\n    self.step = 0\n    self.add_metadata()\n    self.change_status(\"Initiated\")\n\n    return self\n",
                "lines": [
                  68,
                  76
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_metadata": {
              "name": "add_metadata",
              "docstring": "Add metadata to h5 file.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def add_metadata(self) -> None:\n    \"\"\"Add metadata to h5 file.\"\"\"\n    nb_proc = self._comm.Get_size()\n    if self._prank == 0:\n        with self._file(\"a\"):\n            data = {\n                \"time_stamp\": str(datetime.datetime.now().replace(microsecond=0)),\n                \"id\": self.uid,\n                \"processors\": nb_proc,\n                \"notes\": self._file.attrs.get(\"notes\", \"\"),\n            }\n            self._file.attrs.update(data)\n        self._push_update_to_sqlite(data)\n",
                "lines": [
                  78,
                  90
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_parameters": {
              "name": "add_parameters",
              "docstring": "Add parameters to simulation.\n",
              "signature": "(self, parameters: dict) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "parameters": {
                  "default": null,
                  "annotation": "dict",
                  "description": "Dictionary with parameters."
                }
              },
              "source": {
                "code": "def add_parameters(self, parameters: dict) -> None:\n    \"\"\"Add parameters to simulation.\n\n    Args:\n        parameters: Dictionary with parameters.\n    \"\"\"\n    if self._prank == 0:\n        with self._file(\"a\"):\n            # flatten parameters\n            parameters = flatten_dict(parameters)\n\n            if \"parameters\" in self._file.keys():\n                del self._file[\"parameters\"]\n            grp = self._file.create_group(\"/parameters\")\n            for key, val in parameters.items():\n                if isinstance(val, np.ndarray):\n                    grp.create_dataset(key, data=val)\n                elif val is not None:\n                    grp.attrs[key] = val\n        self._push_update_to_sqlite(parameters)\n",
                "lines": [
                  92,
                  111
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_mesh": {
              "name": "add_mesh",
              "docstring": "Add the mesh to file. Currently only 2d meshes.\n\nNote:\n    If you are working with FEniCS, you can use the\n    `bamboost.extensions.fenics.FenicsWriter` writer. With it you can\n    write the FEniCS mesh directly.",
              "signature": "(\n    self,\n    coordinates: numpy.ndarray,\n    connectivity: numpy.ndarray,\n    mesh_name: str = None\n) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "coordinates": {
                  "default": null,
                  "annotation": "numpy.ndarray",
                  "description": "Coordinates as array (nb_nodes, dim)"
                },
                "connectivity": {
                  "default": null,
                  "annotation": "numpy.ndarray",
                  "description": "Connectivity matrix (nb_cells, nb nodes per cell)"
                },
                "mesh_name": {
                  "default": "None",
                  "annotation": "str",
                  "description": "name for mesh (default = `mesh`)"
                }
              },
              "source": {
                "code": "def add_mesh(\n    self, coordinates: np.ndarray, connectivity: np.ndarray, mesh_name: str = None\n) -> None:\n    \"\"\"Add the mesh to file. Currently only 2d meshes.\n\n    Note:\n        If you are working with FEniCS, you can use the\n        `bamboost.extensions.fenics.FenicsWriter` writer. With it you can\n        write the FEniCS mesh directly.\n    Args:\n        coordinates: Coordinates as array (nb_nodes, dim)\n        connectivity: Connectivity matrix (nb_cells, nb nodes per cell)\n        mesh_name: name for mesh (default = `mesh`)\n    \"\"\"\n    if mesh_name is None:\n        mesh_name = self._default_mesh\n    # self._mesh_location = 'Mesh/0/mesh/'\n    mesh_location = f\"{self._mesh_location}/{mesh_name}/\"\n\n    nb_nodes_local = coordinates.shape[0]\n    nb_cells_local = connectivity.shape[0]\n\n    # gather total mesh\n    nb_nodes_p = np.array(self._comm.allgather(nb_nodes_local))\n    nb_cells_p = np.array(self._comm.allgather(nb_cells_local))\n    nb_nodes, nb_cells = np.sum(nb_nodes_p), np.sum(nb_cells_p)\n\n    # shape of datasets\n    coord_shape = (\n        (nb_nodes, coordinates.shape[1]) if coordinates.ndim > 1 else (nb_nodes,)\n    )\n    conn_shape = (\n        (nb_cells, connectivity.shape[1]) if connectivity.ndim > 1 else (nb_cells,)\n    )\n\n    # global indices nodes\n    idx_start = np.sum(nb_nodes_p[self._ranks < self._prank])\n    idx_end = idx_start + nb_nodes_local\n\n    # global indices cells\n    idx_start_cells = np.sum(nb_cells_p[self._ranks < self._prank])\n    idx_end_cells = idx_start_cells + nb_cells_local\n    connectivity = connectivity + idx_start\n\n    with self._file(\"a\", driver=\"mpio\", comm=self._comm) as f:\n        if mesh_location in self._file.file_object:\n            del self._file.file_object[mesh_location]\n        grp = f.require_group(mesh_location)\n        coord = grp.require_dataset(\n            \"coordinates\", shape=coord_shape, dtype=coordinates.dtype\n        )\n        conn = grp.require_dataset(\n            \"topology\", shape=conn_shape, dtype=connectivity.dtype\n        )\n\n        coord[idx_start:idx_end] = coordinates\n        conn[idx_start_cells:idx_end_cells] = connectivity\n",
                "lines": [
                  113,
                  169
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_field": {
              "name": "add_field",
              "docstring": "Add a dataset to the file. The data is stored at `data/`.\n",
              "signature": "(\n    self,\n    name: str,\n    vector: <built-in function array>,\n    time: float = None,\n    mesh: str = None,\n    dtype: str = None,\n    center: Literal['Node', 'Cell'] = 'Node'\n) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "name": {
                  "default": null,
                  "annotation": "str",
                  "description": "Name for the dataset"
                },
                "vector": {
                  "default": null,
                  "annotation": "<built-in function array>",
                  "description": "Dataset"
                },
                "time": {
                  "default": "None",
                  "annotation": "float",
                  "description": "Optional. time"
                },
                "mesh": {
                  "default": "None",
                  "annotation": "str",
                  "description": "Optional. Linked mesh for this data"
                },
                "dtype": {
                  "default": "None",
                  "annotation": "str",
                  "description": "Optional. Numpy style datatype, see h5py documentation,\ndefaults to the dtype of the vector."
                },
                "center": {
                  "default": "Node",
                  "annotation": "Literal['Node', 'Cell']",
                  "description": "Optional. Center of the data. Can be 'Node' or 'Cell'.\nDefault is 'Node'."
                }
              },
              "source": {
                "code": "def add_field(\n    self,\n    name: str,\n    vector: np.array,\n    time: float = None,\n    mesh: str = None,\n    dtype: str = None,\n    center: Literal[\"Node\", \"Cell\"] = \"Node\",\n) -> None:\n    \"\"\"Add a dataset to the file. The data is stored at `data/`.\n\n    Args:\n        name: Name for the dataset\n        vector: Dataset\n        time: Optional. time\n        mesh: Optional. Linked mesh for this data\n        dtype: Optional. Numpy style datatype, see h5py documentation,\n            defaults to the dtype of the vector.\n        center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n            Default is 'Node'.\n    \"\"\"\n    if mesh is None:\n        mesh = self._default_mesh\n\n    if time is None:\n        time = self.step\n\n    self._dump_array(f\"data/{name}/{self.step}\", vector, dtype=dtype)\n    self._comm.barrier()  # attempt to fix bug (see SimulationWriter add_field)\n\n    if self._prank == 0:\n        with self._file(\"a\"):\n            # Sometimes this fails with (if simultaneously trying to read the file)\n            # KeyError: 'Unable to synchronously open object (addr overflow, addr = 247903512, size = 328, eoa = 247903240)'\n            # KeyError: 'Unable to synchronously open object (len not positive after adjustment for EOA)'\n            # I don't know exactly what is going on.\n            # It could be that some process is still writing and then it's opened again and the dataset doesn't exist properly\n            # OR the other processes try to open the file already for the next time while this one is waiting\n            vec = self._file[\"data\"][name][str(self.step)]\n            vec.attrs.update({\"center\": center, \"mesh\": mesh, \"t\": time})\n\n    self._comm.barrier()  # attempt to fix bug (see SimulationWriter add_field)\n",
                "lines": [
                  171,
                  212
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_fields": {
              "name": "add_fields",
              "docstring": "Add multiple fields at once.\n",
              "signature": "(\n    self,\n    fields: Dict[str, Union[numpy.ndarray, Tuple[numpy.ndarray, str]]],\n    time: float = None,\n    mesh: str = None\n) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "fields": {
                  "default": null,
                  "annotation": "Dict[str, Union[numpy.ndarray, Tuple[numpy.ndarray, str]]]",
                  "description": "Dictionary with fields. The value can be a tuple with the\ndata and a string \"Node\" or \"Cell\"."
                },
                "time": {
                  "default": "None",
                  "annotation": "float",
                  "description": "Optional. time"
                },
                "mesh": {
                  "default": "None",
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "def add_fields(\n    self,\n    fields: Dict[str, np.ndarray | Tuple[np.ndarray, str]],\n    time: float = None,\n    mesh: str = None,\n) -> None:\n    \"\"\"Add multiple fields at once.\n\n    Args:\n        fields: Dictionary with fields. The value can be a tuple with the\n            data and a string \"Node\" or \"Cell\".\n        time: Optional. time\n    \"\"\"\n    for key, value in fields.items():\n        if isinstance(value, tuple):\n            vector, center = value\n        else:\n            vector, center = value, \"Node\"\n        self.add_field(key, vector, time, mesh, center=center)\n",
                "lines": [
                  245,
                  263
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_global_field": {
              "name": "add_global_field",
              "docstring": "Add a gobal field. These are stored at `globals/` as an array in a\nsingle dataset.",
              "signature": "(self, name: str, value: Any, dtype: str = None) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "name": {
                  "default": null,
                  "annotation": "str",
                  "description": "Name for the data"
                },
                "value": {
                  "default": null,
                  "annotation": "Any",
                  "description": "Data. Can be a numpy array or a single value."
                },
                "dtype": {
                  "default": "None",
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "def add_global_field(self, name: str, value: Any, dtype: str = None) -> None:\n    \"\"\"Add a gobal field. These are stored at `globals/` as an array in a\n    single dataset.\n\n    Args:\n        name: Name for the data\n        value: Data. Can be a numpy array or a single value.\n    \"\"\"\n    self._dump_global_data(f\"globals/{name}\", value, self.step, dtype=dtype)\n",
                "lines": [
                  265,
                  273
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_global_fields": {
              "name": "add_global_fields",
              "docstring": "Add multiple global fields at once.\n",
              "signature": "(self, fields: Dict[str, Any]) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "fields": {
                  "default": null,
                  "annotation": "Dict[str, Any]",
                  "description": "Dictionary with fields"
                }
              },
              "source": {
                "code": "def add_global_fields(self, fields: Dict[str, Any]) -> None:\n    \"\"\"Add multiple global fields at once.\n\n    Args:\n        fields: Dictionary with fields\n    \"\"\"\n    for name, value in fields.items():\n        self.add_global_field(name, value)\n",
                "lines": [
                  312,
                  319
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "finish_step": {
              "name": "finish_step",
              "docstring": "Finish step. Adds 1 to the step counter.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def finish_step(self) -> None:\n    \"\"\"Finish step. Adds 1 to the step counter.\"\"\"\n    self.step += 1\n",
                "lines": [
                  321,
                  323
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "finish_sim": {
              "name": "finish_sim",
              "docstring": "",
              "signature": "(self, status: str = 'Finished') -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "status": {
                  "default": "Finished",
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "def finish_sim(self, status: str = \"Finished\") -> None:\n    if self._prank == 0:\n        self.change_status(status)\n",
                "lines": [
                  325,
                  327
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "register_git_attributes": {
              "name": "register_git_attributes",
              "docstring": "Register git information for given repo.\n",
              "signature": "(self, repo_path: str = './') -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "repo_path": {
                  "default": "./",
                  "annotation": "str",
                  "description": "path to git repository"
                }
              },
              "source": {
                "code": "def register_git_attributes(self, repo_path: str = \"./\") -> None:\n    \"\"\"Register git information for given repo.\n\n    Args:\n        repo_path (`str`): path to git repository\n    \"\"\"\n    if self._prank == 0:\n        repo_path = os.path.abspath(repo_path)\n        # store current working directory\n        cwd = os.getcwd()\n\n        # switch directory to git repo\n        os.chdir(repo_path)\n        git_string = GitStateGetter().create_git_string()\n\n        # switch working directory back\n        os.chdir(cwd)\n\n        with self._file(\"a\") as f:\n            grp = f.require_group(\"git\")\n            repo_name = os.path.split(repo_path)[1]\n            log.info(f\"Adding repo {repo_name}\")\n            if repo_name in grp.keys():\n                del grp[repo_name]\n            grp.create_dataset(repo_name, data=git_string)\n",
                "lines": [
                  329,
                  353
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "copy_executable": {
              "name": "copy_executable",
              "docstring": "WILL BE REMOVED. USE COPY_FILE.\nCopy an executable to directory for reproducability.",
              "signature": "(self, script_path: str) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "script_path": {
                  "default": null,
                  "annotation": "str",
                  "description": "path to script"
                }
              },
              "source": {
                "code": "def copy_executable(self, script_path: str) -> None:\n    \"\"\"WILL BE REMOVED. USE COPY_FILE.\n    Copy an executable to directory for reproducability.\n\n    Args:\n        script_path: path to script\n    \"\"\"\n    shutil.copy(script_path, self.path)\n    self.executable = os.path.split(script_path)[1]\n",
                "lines": [
                  355,
                  363
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "copy_file": {
              "name": "copy_file",
              "docstring": "Copy a file to the datafolder.\n",
              "signature": "(self, source: Union[str, list], destination: str = '') -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "source": {
                  "default": null,
                  "annotation": "Union[str, list]",
                  "description": "path to file, or list of files"
                },
                "destination": {
                  "default": "",
                  "annotation": "str",
                  "description": "destination (will create intermediatory directories)"
                }
              },
              "source": {
                "code": "def copy_file(self, source: Union[str, list], destination: str = \"\") -> None:\n    \"\"\"Copy a file to the datafolder.\n\n    Args:\n        source: path to file, or list of files\n        destination: destination (will create intermediatory directories)\n    \"\"\"\n    if self._prank != 0:\n        return\n\n    if isinstance(source, list):\n        for item in source:\n            self.copy_file(item, destination)\n        return\n\n    destination = os.path.join(self.path, destination)\n\n    if os.path.isdir(source):\n        shutil.copytree(\n            source,\n            os.path.join(destination, os.path.basename(source)),\n            dirs_exist_ok=True,\n        )\n    elif os.path.isfile(source):\n        os.makedirs(destination, exist_ok=True)\n        shutil.copy(source, destination)\n    else:\n        raise FileNotFoundError\n",
                "lines": [
                  365,
                  392
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [
            {
              "name": "step",
              "annotation": "int",
              "description": null,
              "default": ""
            }
          ],
          "inherits_from": {
            "bamboost.simulation.Simulation": {
              "module": "bamboost.simulation",
              "members": [
                [
                  "variable",
                  "uid"
                ],
                [
                  "variable",
                  "path_database"
                ],
                [
                  "variable",
                  "database_id"
                ],
                [
                  "variable",
                  "path"
                ],
                [
                  "variable",
                  "h5file"
                ],
                [
                  "variable",
                  "xdmffile"
                ],
                [
                  "variable",
                  "meshes"
                ],
                [
                  "variable",
                  "data"
                ],
                [
                  "variable",
                  "globals"
                ],
                [
                  "variable",
                  "userdata"
                ],
                [
                  "variable",
                  "links"
                ],
                [
                  "function",
                  "fromUID"
                ],
                [
                  "function",
                  "__getitem__"
                ],
                [
                  "variable",
                  "parameters"
                ],
                [
                  "variable",
                  "metadata"
                ],
                [
                  "function",
                  "files"
                ],
                [
                  "function",
                  "show_files"
                ],
                [
                  "function",
                  "open_in_file_explorer"
                ],
                [
                  "function",
                  "open_in_paraview"
                ],
                [
                  "function",
                  "get_full_uid"
                ],
                [
                  "function",
                  "change_status"
                ],
                [
                  "function",
                  "update_metadata"
                ],
                [
                  "function",
                  "update_parameters"
                ],
                [
                  "function",
                  "create_xdmf_file"
                ],
                [
                  "function",
                  "create_run_script"
                ],
                [
                  "function",
                  "create_batch_script"
                ],
                [
                  "function",
                  "submit"
                ],
                [
                  "function",
                  "change_note"
                ],
                [
                  "function",
                  "open"
                ],
                [
                  "variable",
                  "mesh"
                ],
                [
                  "function",
                  "get_mesh"
                ],
                [
                  "variable",
                  "data_info"
                ],
                [
                  "variable",
                  "git"
                ],
                [
                  "function",
                  "get_data_interpolator"
                ],
                [
                  "function",
                  "show_h5tree"
                ],
                [
                  "function",
                  "enter_path"
                ]
              ]
            }
          },
          "examples": [],
          "constructor": {
            "signature": "(\n    self,\n    uid: str,\n    path: str,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>,\n    create_if_not_exists: bool = True\n)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "uid": {
                "default": null,
                "annotation": "str",
                "description": null
              },
              "path": {
                "default": null,
                "annotation": "str",
                "description": null
              },
              "comm": {
                "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x7010845dcad0>",
                "annotation": "bamboost.common._mock_mpi.MockMPI.Comm",
                "description": null
              },
              "create_if_not_exists": {
                "default": "True",
                "annotation": "bool",
                "description": null
              }
            },
            "source": {
              "code": "def __init__(\n    self,\n    uid: str,\n    path: str,\n    comm: MPI.Comm = MPI.COMM_WORLD,\n    create_if_not_exists: bool = True,\n):\n    super().__init__(uid, path, comm, create_if_not_exists)\n    self.step: int = 0\n",
              "lines": [
                45,
                53
              ]
            }
          }
        }
      ],
      "functions": [],
      "submodules": [],
      "examples": [],
      "version": null
    },
    {
      "name": "xdmf",
      "slug": [
        "bamboost",
        "xdmf"
      ],
      "docstring": "",
      "short_description": "",
      "attributes": [],
      "classes": [
        {
          "name": "XDMFWriter",
          "short_description": "Write xdmf file for a subset of the stored data in the H5 file.",
          "docstring": "Write xdmf file for a subset of the stored data in the H5 file.\n",
          "methods": {
            "write_file": {
              "name": "write_file",
              "docstring": "",
              "signature": "(self)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def write_file(self):\n    tree = ET.ElementTree(self.xdmf_file)\n    self._pretty_print(tree.getroot())\n    tree.write(self.filename)\n",
                "lines": [
                  48,
                  51
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "write_points_cells": {
              "name": "write_points_cells",
              "docstring": "Write the mesh to the xdmf file.\n",
              "signature": "(self, points_location: str, cells_location: str)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "points_location": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                },
                "cells_location": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                }
              },
              "source": {
                "code": "def write_points_cells(self, points_location: str, cells_location: str):\n    \"\"\"Write the mesh to the xdmf file.\n\n    Args:\n        points (str): String to geometry/nodes in h5 file\n        cells (str): String to topology/cells in h5 file\n    \"\"\"\n    grid = ET.SubElement(\n        self.domain, \"Grid\", Name=self.mesh_name, GridType=\"Uniform\"\n    )\n    self._points(grid, points_location)\n    self._cells(grid, cells_location)\n",
                "lines": [
                  68,
                  79
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_timeseries": {
              "name": "add_timeseries",
              "docstring": "",
              "signature": "(self, steps: int, fields: list)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "steps": {
                  "default": null,
                  "annotation": "int",
                  "description": null
                },
                "fields": {
                  "default": null,
                  "annotation": "list",
                  "description": null
                }
              },
              "source": {
                "code": "def add_timeseries(self, steps: int, fields: list):\n    collection = ET.SubElement(\n        self.domain,\n        \"Grid\",\n        Name=\"TimeSeries\",\n        GridType=\"Collection\",\n        CollectionType=\"Temporal\",\n    )\n\n    for i in range(steps):\n        self.write_step(collection, fields, i)\n",
                "lines": [
                  123,
                  133
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "write_step": {
              "name": "write_step",
              "docstring": "Write the data array for time t.\n",
              "signature": "(\n    self,\n    collection: xml.etree.ElementTree.Element,\n    fields: list,\n    step: int\n)",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "collection": {
                  "default": null,
                  "annotation": "xml.etree.ElementTree.Element",
                  "description": null
                },
                "fields": {
                  "default": null,
                  "annotation": "list",
                  "description": null
                },
                "step": {
                  "default": null,
                  "annotation": "int",
                  "description": null
                }
              },
              "source": {
                "code": "def write_step(self, collection: ET.Element, fields: list, step: int):\n    \"\"\"Write the data array for time t.\n\n    Args:\n        t (float): time\n        data_location (str): String to data in h5 file\n        name (str): Name for the field in the Xdmf file\n    \"\"\"\n    with self._file(\"r\") as _f:\n        f = _f.file_object\n        grid = ET.SubElement(collection, \"Grid\")\n        ptr = f'xpointer(//Grid[@Name=\"{self.mesh_name}\"]/*[self::Topology or self::Geometry])'\n\n        ET.SubElement(\n            grid, \"{http://www.w3.org/2003/XInclude}include\", xpointer=ptr\n        )\n\n        t = f[f\"data/{fields[0]}/{step}\"].attrs.get(\"t\", step)\n        ET.SubElement(grid, \"Time\", Value=str(t))\n\n        for name in fields:\n            self.write_attribute(grid, name, name, step)\n",
                "lines": [
                  135,
                  156
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "write_attribute": {
              "name": "write_attribute",
              "docstring": "Write an attribute/field.",
              "signature": "(\n    self,\n    grid: xml.etree.ElementTree.Element,\n    field_name: str,\n    name: str,\n    step: int\n) -> None",
              "returns": {
                "annotation": null,
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "grid": {
                  "default": null,
                  "annotation": "xml.etree.ElementTree.Element",
                  "description": null
                },
                "field_name": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                },
                "name": {
                  "default": null,
                  "annotation": "str",
                  "description": null
                },
                "step": {
                  "default": null,
                  "annotation": "int",
                  "description": null
                }
              },
              "source": {
                "code": "def write_attribute(\n    self, grid: ET.Element, field_name: str, name: str, step: int\n) -> None:\n    \"\"\"Write an attribute/field.\"\"\"\n    with self._file(\"r\") as _f:\n        f = _f.file_object\n        data = f[f\"data/{field_name}/{step}\"]\n\n        if data.ndim == 1 or data.shape[1] <= 1:\n            att_type = \"Scalar\"\n        elif data.ndim == 2:\n            att_type = \"Vector\"\n        elif data.ndim == 3 and len(set(data.shape[1:])) == 1:\n            # Square shape -> Tensor\n            att_type = \"Tensor\"\n        else:\n            att_type = \"Matrix\"\n\n        # Cell or Node data\n        center = data.attrs.get(\"center\", \"Node\")\n\n        att = ET.SubElement(\n            grid,\n            \"Attribute\",\n            Name=name,\n            AttributeType=att_type,\n            Center=center,\n        )\n\n        dt, prec = numpy_to_xdmf_dtype[data.dtype.name]\n        dim = \" \".join([str(i) for i in data.shape])\n\n        data_item = ET.SubElement(\n            att,\n            \"DataItem\",\n            DataType=dt,\n            Dimensions=dim,\n            Format=\"HDF\",\n            Precision=prec,\n        )\n        data_item.text = f\"{self.h5file}:/data/{field_name}/{step}\"\n",
                "lines": [
                  158,
                  198
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "properties": [
            {
              "name": "filename",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "h5file",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "xdmf_file",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "domain",
              "annotation": null,
              "description": null,
              "default": ""
            },
            {
              "name": "mesh_name",
              "annotation": null,
              "description": null,
              "default": ""
            }
          ],
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(self, filename: str, _file: bamboost.common.file_handler.FileHandler)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "filename": {
                "default": null,
                "annotation": "str",
                "description": null
              },
              "_file": {
                "default": null,
                "annotation": "bamboost.common.file_handler.FileHandler",
                "description": null
              }
            },
            "source": {
              "code": "def __init__(self, filename: str, _file: FileHandler):\n    self.filename = filename\n    self._file = _file\n    self.h5file = os.path.basename(_file.file_name)\n    self.xdmf_file = ET.Element(\"Xdmf\", Version=\"3.0\")\n    self.domain = ET.SubElement(self.xdmf_file, \"Domain\")\n    ET.register_namespace(\"xi\", \"https://www.w3.org/2001/XInclude/\")\n    self.mesh_name = \"mesh\"\n",
              "lines": [
                39,
                46
              ]
            }
          }
        }
      ],
      "functions": [],
      "submodules": [],
      "examples": [],
      "version": null
    }
  ],
  "examples": [],
  "version": "0.8.1"
}