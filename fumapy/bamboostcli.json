{
  "name": "bamboostcli",
  "path": "bamboostcli",
  "filepath": "/home/florez/work/code/hdftui/bamboostcli/__init__.py",
  "description": null,
  "docstring": [],
  "attributes": [
    {
      "name": "__author__",
      "annotation": null,
      "description": null,
      "value": "'Flavio Lorez'"
    }
  ],
  "modules": {
    "api": {
      "name": "api",
      "path": "bamboostcli.api",
      "filepath": "/home/florez/work/code/hdftui/bamboostcli/api.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "Database": {
          "name": "Database",
          "path": "bamboostcli.api.Database",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "_self",
              "annotation": null,
              "description": null,
              "value": "_get_instance_by_class(_Database)"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboostcli.api.Database.__init__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self):\n    self._self = _get_instance_by_class(_Database)[0]"
            },
            "__getattr__": {
              "name": "__getattr__",
              "path": "bamboostcli.api.Database.__getattr__",
              "signature": "(self, name)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __getattr__(self, name):\n    return getattr(self._self, name)"
            },
            "uid_in_focus": {
              "name": "uid_in_focus",
              "path": "bamboostcli.api.Database.uid_in_focus",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def uid_in_focus(self):\n    uid = self._self.table._get_entry_in_focus()[\"id\"]\n    return uid"
            },
            "sim_in_focus": {
              "name": "sim_in_focus",
              "path": "bamboostcli.api.Database.sim_in_focus",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def sim_in_focus(self):\n    return self._self.db[self.uid_in_focus()]"
            },
            "print": {
              "name": "print",
              "path": "bamboostcli.api.Database.print",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def print(self):\n    print(self._self)"
            }
          },
          "source": "class Database:\n    def __init__(self):\n        self._self = _get_instance_by_class(_Database)[0]\n\n    def __getattr__(self, name):\n        return getattr(self._self, name)\n\n    def uid_in_focus(self):\n        uid = self._self.table._get_entry_in_focus()[\"id\"]\n        return uid\n\n    def sim_in_focus(self):\n        return self._self.db[self.uid_in_focus()]\n\n    def print(self):\n        print(self._self)",
          "inherited_members": {}
        }
      },
      "functions": {
        "_get_instance_by_class_name": {
          "name": "_get_instance_by_class_name",
          "path": "bamboostcli.api._get_instance_by_class_name",
          "signature": "(classname)",
          "description": null,
          "parameters": [
            {
              "name": "classname",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _get_instance_by_class_name(classname):\n    # get all objects tracked by the garbage collector\n    all_objects = gc.get_objects()\n\n    # filter objects by class name\n    instances = [\n        obj\n        for obj in all_objects\n        if isinstance(obj, object) and obj.__class__.__name__ == classname\n    ]\n    return instances"
        },
        "_get_instance_by_class": {
          "name": "_get_instance_by_class",
          "path": "bamboostcli.api._get_instance_by_class",
          "signature": "(cls)",
          "description": null,
          "parameters": [
            {
              "name": "cls",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _get_instance_by_class(cls):\n    # get all objects tracked by the garbage collector\n    all_objects = gc.get_objects()\n\n    # filter objects by class name\n    instances = [obj for obj in all_objects if isinstance(obj, cls)]\n    return instances"
        },
        "get_entry_in_focus": {
          "name": "get_entry_in_focus",
          "path": "bamboostcli.api.get_entry_in_focus",
          "signature": "()",
          "description": "Returns the bamboost Simulation object in focus.",
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def get_entry_in_focus():\n    \"\"\"Returns the bamboost Simulation object in focus.\"\"\"\n    cli_db = _get_instance_by_class(_Database)[0]\n    uid = cli_db.table._get_entry_in_focus()[\"id\"]\n    return cli_db.db[uid]"
        }
      }
    },
    "keybinds": {
      "name": "keybinds",
      "path": "bamboostcli.keybinds",
      "filepath": "/home/florez/work/code/hdftui/bamboostcli/keybinds.py",
      "description": "Keybind module of the bamboost tui.\n\nThis module contains the Keybind and the Keybindings class. `Keybind`\nrepresents a single keybinding, while `Keybindings` is a collection of\nkeybindings for a specific page or widget.",
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {
        "Keybind": {
          "name": "Keybind",
          "path": "bamboostcli.keybinds.Keybind",
          "description": "A single keybinding.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "name",
              "annotation": "str",
              "description": [
                {
                  "kind": "text",
                  "value": "The name of the keybinding."
                }
              ]
            },
            {
              "name": "key",
              "annotation": "str | list[str]",
              "description": [
                {
                  "kind": "text",
                  "value": "The key or keys that trigger the keybinding."
                }
              ]
            },
            {
              "name": "func",
              "annotation": "callable",
              "description": [
                {
                  "kind": "text",
                  "value": "The function that is called when the keybinding is triggered."
                }
              ]
            },
            {
              "name": "description",
              "annotation": "str",
              "description": [
                {
                  "kind": "text",
                  "value": "A short description of the keybinding."
                }
              ],
              "value": "''"
            },
            {
              "name": "aliases",
              "annotation": "list",
              "description": [
                {
                  "kind": "text",
                  "value": "Optional. A list of aliases for the keybinding."
                }
              ],
              "value": "list()"
            },
            {
              "name": "group",
              "annotation": "str",
              "description": [
                {
                  "kind": "text",
                  "value": "Optional. The group to which the keybinding belongs. This is used to group\nthe help widget."
                }
              ],
              "value": "None"
            },
            {
              "name": "obj",
              "annotation": "object",
              "description": [
                {
                  "kind": "text",
                  "value": "Optional. The object (instance) to which the keybinding belongs to. This is\npassed as the first argument to the function."
                }
              ],
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "name",
              "annotation": "str",
              "description": null,
              "value": null
            },
            {
              "name": "key",
              "annotation": "str | list[str]",
              "description": null,
              "value": null
            },
            {
              "name": "func",
              "annotation": "callable",
              "description": null,
              "value": null
            },
            {
              "name": "description",
              "annotation": "str",
              "description": null,
              "value": "''"
            },
            {
              "name": "aliases",
              "annotation": "list",
              "description": null,
              "value": "field(default_factory=list)"
            },
            {
              "name": "group",
              "annotation": "str",
              "description": null,
              "value": "None"
            },
            {
              "name": "obj",
              "annotation": "object",
              "description": null,
              "value": "None"
            }
          ],
          "docstring": [],
          "functions": {
            "key_as_string": {
              "name": "key_as_string",
              "path": "bamboostcli.keybinds.Keybind.key_as_string",
              "signature": "(self) -> str",
              "description": "Return the key as a string. If the key is a list, it is joined by ' \uea9c '.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def key_as_string(self) -> str:\n    \"\"\"Return the key as a string. If the key is a list, it is joined by ' \uea9c '.\"\"\"\n    if isinstance(self.key, list):\n        return \" \uea9c \".join(self.key)\n    return self.key"
            },
            "call": {
              "name": "call",
              "path": "bamboostcli.keybinds.Keybind.call",
              "signature": "(self, size, key) -> None",
              "description": "Call the function associated with the keybinding.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "size",
                  "annotation": "tuple",
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def call(self, size: tuple[int, int], key: str) -> None:\n    \"\"\"Call the function associated with the keybinding.\"\"\"\n    if self.obj is None:\n        return self.func(size, key)\n\n    # check if the function takes the size and key as arguments\n    if self.func.__code__.co_argcount == 1:\n        return self.func(self.obj)\n    return self.func(self.obj, size, key)"
            },
            "__init__": {
              "name": "__init__",
              "path": "bamboostcli.keybinds.Keybind.__init__",
              "signature": "(self, name, key, func, description='', aliases=list(), group=None, obj=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str | list[str]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "func",
                  "annotation": "callable",
                  "description": null,
                  "value": null
                },
                {
                  "name": "description",
                  "annotation": "str",
                  "description": null,
                  "value": "''"
                },
                {
                  "name": "aliases",
                  "annotation": "list",
                  "description": null,
                  "value": "list()"
                },
                {
                  "name": "group",
                  "annotation": "str",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "obj",
                  "annotation": "object",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass Keybind:\n    \"\"\"A single keybinding.\n\n    Args:\n        name: The name of the keybinding.\n        key: The key or keys that trigger the keybinding.\n        func: The function that is called when the keybinding is triggered.\n        description: A short description of the keybinding.\n        aliases: Optional. A list of aliases for the keybinding.\n        group: Optional. The group to which the keybinding belongs. This is used to group\n            the help widget.\n        obj: Optional. The object (instance) to which the keybinding belongs to. This is\n            passed as the first argument to the function.\n    \"\"\"\n\n    name: str\n    key: str | list[str]\n    func: callable\n    description: str = \"\"\n    aliases: list[str] = field(default_factory=list)\n    group: str = None\n    obj: object = None\n\n    def key_as_string(self) -> str:\n        \"\"\"Return the key as a string. If the key is a list, it is joined by ' \uea9c '.\"\"\"\n        if isinstance(self.key, list):\n            return \" \uea9c \".join(self.key)\n        return self.key\n\n    def call(self, size: tuple[int, int], key: str) -> None:\n        \"\"\"Call the function associated with the keybinding.\"\"\"\n        if self.obj is None:\n            return self.func(size, key)\n\n        # check if the function takes the size and key as arguments\n        if self.func.__code__.co_argcount == 1:\n            return self.func(self.obj)\n        return self.func(self.obj, size, key)",
          "inherited_members": {}
        },
        "Keybindings": {
          "name": "Keybindings",
          "path": "bamboostcli.keybinds.Keybindings",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "obj",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "group",
              "annotation": "str",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [
            {
              "name": "_obj",
              "annotation": null,
              "description": null,
              "value": "obj"
            },
            {
              "name": "_map",
              "annotation": "dict",
              "description": null,
              "value": "{}"
            },
            {
              "name": "_keychain",
              "annotation": null,
              "description": null,
              "value": "[]"
            },
            {
              "name": "_submap",
              "annotation": "dict",
              "description": null,
              "value": "None"
            },
            {
              "name": "_store",
              "annotation": "dict",
              "description": null,
              "value": "{}"
            },
            {
              "name": "group",
              "annotation": null,
              "description": null,
              "value": "group"
            },
            {
              "name": "key_indicator_widget",
              "annotation": "KeyIndicatorWidget",
              "description": null,
              "value": null
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboostcli.keybinds.Keybindings.__init__",
              "signature": "(self, obj, *, group=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "obj",
                  "annotation": null,
                  "description": [
                    {
                      "kind": "text",
                      "value": "The object to which the keybindings are applied."
                    }
                  ]
                },
                {
                  "name": "group",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The group to which the keybindings belong."
                    }
                  ],
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, obj, *, group: str = None) -> None:\n    \"\"\"\n    Args:\n        obj: The object to which the keybindings are applied.\n        group: The group to which the keybindings belong.\n    \"\"\"\n    self._obj = obj\n    self._map: dict[str, Keybind | dict] = {}\n    self._keychain = []\n    self._submap: dict[str, Keybind] = None\n    self._store: dict[str, Keybind] = {}\n    self.group = group"
            },
            "add": {
              "name": "add",
              "path": "bamboostcli.keybinds.Keybindings.add",
              "signature": "(self, new) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "new",
                  "annotation": "Keybind",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def add(self, new: Keybind) -> None:\n    self[new.name] = new"
            },
            "resolve_mapping": {
              "name": "resolve_mapping",
              "path": "bamboostcli.keybinds.Keybindings.resolve_mapping",
              "signature": "(self) -> None",
              "description": "Resolve the mapping of the keybindings.\n\nThis method is called after all keybindings have been added to the\nkeybindings table. It resolves the mapping of the keybindings and\ncreates a dictionary of the available keys (and aliases) and their\nfunctions.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def resolve_mapping(self) -> None:\n    \"\"\"Resolve the mapping of the keybindings.\n\n    This method is called after all keybindings have been added to the\n    keybindings table. It resolves the mapping of the keybindings and\n    creates a dictionary of the available keys (and aliases) and their\n    functions.\n    \"\"\"\n    # handle sub-maps\n    for key in self._store.values():\n        if isinstance(key.key, list):\n            submap = self._map\n            for i in key.key[:-1]:\n                if i not in submap:\n                    submap[i] = {}\n                submap = submap[i]\n            submap[key.key[-1]] = key\n        else:\n            try:\n                self._map.update({key.key: key})\n            except TypeError:\n                for key in self._store.values():\n                    print(key.name, key.key)\n                raise SystemExit\n\n        self._map.update({alias: key for alias in key.aliases})\n    self._submap = self._map"
            },
            "new": {
              "name": "new",
              "path": "bamboostcli.keybinds.Keybindings.new",
              "signature": "(self, name, key, func, description='', aliases=None) -> Keybindings",
              "description": "Add a new keybinding to the keybindings table.\n\nAdds a new keybinding with default values for the group and object.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The name of the keybinding."
                    }
                  ]
                },
                {
                  "name": "key",
                  "annotation": "str | list[str]",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The key or keys that trigger the keybinding."
                    }
                  ]
                },
                {
                  "name": "func",
                  "annotation": "callable",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function that is called when the keybinding is triggered."
                    }
                  ]
                },
                {
                  "name": "description",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Optional. A short description of the keybinding."
                    }
                  ],
                  "value": "''"
                },
                {
                  "name": "aliases",
                  "annotation": "list",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Optional. A list of aliases for the keybinding."
                    }
                  ],
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bamboostcli.keybinds.Keybindings",
                "description": null
              },
              "docstring": [],
              "source": "def new(\n    self,\n    name: str,\n    key: str | list[str],\n    func: callable,\n    description: str = \"\",\n    aliases: list[str] = None,\n) -> Keybindings:\n    \"\"\"Add a new keybinding to the keybindings table.\n\n    Adds a new keybinding with default values for the group and object.\n\n    Args:\n        name: The name of the keybinding.\n        key: The key or keys that trigger the keybinding.\n        func: The function that is called when the keybinding is triggered.\n        description: Optional. A short description of the keybinding.\n        aliases: Optional. A list of aliases for the keybinding.\n    \"\"\"\n    if aliases is None:\n        aliases = []\n    self.add(Keybind(name, key, func, description, aliases, obj=self._obj, group=self.group))\n    return self"
            },
            "keys": {
              "name": "keys",
              "path": "bamboostcli.keybinds.Keybindings.keys",
              "signature": "(self) -> dict",
              "description": "Return a dictionary of the available keys and their functions.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "dict",
                "description": null
              },
              "docstring": [],
              "source": "def keys(self) -> dict[str, callable]:\n    \"\"\"Return a dictionary of the available keys and their functions.\"\"\"\n    return self._submap.keys()"
            },
            "call": {
              "name": "call",
              "path": "bamboostcli.keybinds.Keybindings.call",
              "signature": "(self, size, key) -> None",
              "description": "Call the function associated with the given key or enter submap.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "size",
                  "annotation": "tuple",
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The key to pursue."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def call(self, size: tuple[int, int], key: str) -> None:\n    \"\"\"Call the function associated with the given key or enter submap.\n\n    Args:\n        key: The key to pursue.\n    \"\"\"\n    if isinstance(self._submap[key], dict):\n        self.update_submap(key)\n        return\n\n    self.key_indicator_widget.reset()\n    self._submap[key].call(size, key)\n    self.reset_submap()"
            },
            "merge": {
              "name": "merge",
              "path": "bamboostcli.keybinds.Keybindings.merge",
              "signature": "(self, other, group=None) -> None",
              "description": "Merge the keybindings of another Keybindings object into this one.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "other",
                  "annotation": "Keybindings",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The other Keybindings object."
                    }
                  ]
                },
                {
                  "name": "group",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Optional. The group to which the keybindings belongs."
                    }
                  ],
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def merge(self, other: Keybindings, group: str = None) -> None:\n    \"\"\"Merge the keybindings of another Keybindings object into this one.\n\n    Args:\n        other: The other Keybindings object.\n        group: Optional. The group to which the keybindings belongs.\n    \"\"\"\n    # merge this keybindings into the other first to overwrite duplicates correctly\n    tmp = other._store.copy()\n    # change group\n    if group is not None:\n        for key in tmp.values():\n            key.group = group\n    tmp.update(self._store)\n    self._store.update(tmp)\n    self.resolve_mapping()"
            },
            "update_submap": {
              "name": "update_submap",
              "path": "bamboostcli.keybinds.Keybindings.update_submap",
              "signature": "(self, key) -> None",
              "description": "Update the submap to the submap of the given key.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def update_submap(self, key: str) -> None:\n    \"\"\"Update the submap to the submap of the given key.\"\"\"\n    self._submap = self._submap[key]\n    self._keychain.append(key)\n    self.key_indicator_widget.set_text(\" > \".join(self._keychain))\n    if not self.key_indicator_widget.is_visible:\n        self.key_indicator_widget.toggle()"
            },
            "reset_submap": {
              "name": "reset_submap",
              "path": "bamboostcli.keybinds.Keybindings.reset_submap",
              "signature": "(self) -> None",
              "description": "Reset the submap to the main map.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def reset_submap(self) -> None:\n    \"\"\"Reset the submap to the main map.\"\"\"\n    self._submap = self._map\n    self._keychain = []"
            },
            "toggle_help": {
              "name": "toggle_help",
              "path": "bamboostcli.keybinds.Keybindings.toggle_help",
              "signature": "(self) -> None",
              "description": "Toggle the keybinds overlay.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def toggle_help(self) -> None:\n    \"\"\"Toggle the keybinds overlay.\"\"\"\n    if not hasattr(self, \"_keybinds_overlay\"):\n        self._keybinds_overlay = cKeybindsOverlay(\n            Caller.main_loop, Caller.widget_stack[-1], self\n        )\n    self._keybinds_overlay.toggle()"
            },
            "__getitem__": {
              "name": "__getitem__",
              "path": "bamboostcli.keybinds.Keybindings.__getitem__",
              "signature": "(self, key) -> Keybind",
              "description": "Get a Keybind by name.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bamboostcli.keybinds.Keybind",
                "description": null
              },
              "docstring": [],
              "source": "def __getitem__(self, key: str) -> Keybind:\n    \"Get a Keybind by name.\"\n    return self._store[key]"
            },
            "__delitem__": {
              "name": "__delitem__",
              "path": "bamboostcli.keybinds.Keybindings.__delitem__",
              "signature": "(self, key) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def __delitem__(self, key: str) -> None:\n    del self._store[key]"
            },
            "__setitem__": {
              "name": "__setitem__",
              "path": "bamboostcli.keybinds.Keybindings.__setitem__",
              "signature": "(self, key, value) -> None",
              "description": "Set a Keybind by name.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": "Keybind",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def __setitem__(self, key: str, value: Keybind) -> None:\n    \"Set a Keybind by name.\"\n    self._store[key] = value"
            },
            "__iter__": {
              "name": "__iter__",
              "path": "bamboostcli.keybinds.Keybindings.__iter__",
              "signature": "(self) -> Generator",
              "description": "Iterate over the Keybinds stored here.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Generator",
                "description": null
              },
              "docstring": [],
              "source": "def __iter__(self) -> Generator[Keybind, None, None]:\n    \"Iterate over the Keybinds stored here.\"\n    return iter(self._store.values())"
            },
            "__len__": {
              "name": "__len__",
              "path": "bamboostcli.keybinds.Keybindings.__len__",
              "signature": "(self) -> int",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "int",
                "description": null
              },
              "docstring": [],
              "source": "def __len__(self) -> int:\n    return len(self._store)"
            }
          },
          "source": "class Keybindings(MutableMapping[str, Keybind]):\n    def __init__(self, obj, *, group: str = None) -> None:\n        \"\"\"\n        Args:\n            obj: The object to which the keybindings are applied.\n            group: The group to which the keybindings belong.\n        \"\"\"\n        self._obj = obj\n        self._map: dict[str, Keybind | dict] = {}\n        self._keychain = []\n        self._submap: dict[str, Keybind] = None\n        self._store: dict[str, Keybind] = {}\n        self.group = group\n\n    def add(self, new: Keybind) -> None:\n        self[new.name] = new\n\n    def resolve_mapping(self) -> None:\n        \"\"\"Resolve the mapping of the keybindings.\n\n        This method is called after all keybindings have been added to the\n        keybindings table. It resolves the mapping of the keybindings and\n        creates a dictionary of the available keys (and aliases) and their\n        functions.\n        \"\"\"\n        # handle sub-maps\n        for key in self._store.values():\n            if isinstance(key.key, list):\n                submap = self._map\n                for i in key.key[:-1]:\n                    if i not in submap:\n                        submap[i] = {}\n                    submap = submap[i]\n                submap[key.key[-1]] = key\n            else:\n                try:\n                    self._map.update({key.key: key})\n                except TypeError:\n                    for key in self._store.values():\n                        print(key.name, key.key)\n                    raise SystemExit\n\n            self._map.update({alias: key for alias in key.aliases})\n        self._submap = self._map\n\n    def new(\n        self,\n        name: str,\n        key: str | list[str],\n        func: callable,\n        description: str = \"\",\n        aliases: list[str] = None,\n    ) -> Keybindings:\n        \"\"\"Add a new keybinding to the keybindings table.\n\n        Adds a new keybinding with default values for the group and object.\n\n        Args:\n            name: The name of the keybinding.\n            key: The key or keys that trigger the keybinding.\n            func: The function that is called when the keybinding is triggered.\n            description: Optional. A short description of the keybinding.\n            aliases: Optional. A list of aliases for the keybinding.\n        \"\"\"\n        if aliases is None:\n            aliases = []\n        self.add(Keybind(name, key, func, description, aliases, obj=self._obj, group=self.group))\n        return self\n\n    def keys(self) -> dict[str, callable]:\n        \"\"\"Return a dictionary of the available keys and their functions.\"\"\"\n        return self._submap.keys()\n\n    def call(self, size: tuple[int, int], key: str) -> None:\n        \"\"\"Call the function associated with the given key or enter submap.\n\n        Args:\n            key: The key to pursue.\n        \"\"\"\n        if isinstance(self._submap[key], dict):\n            self.update_submap(key)\n            return\n\n        self.key_indicator_widget.reset()\n        self._submap[key].call(size, key)\n        self.reset_submap()\n\n    def merge(self, other: Keybindings, group: str = None) -> None:\n        \"\"\"Merge the keybindings of another Keybindings object into this one.\n\n        Args:\n            other: The other Keybindings object.\n            group: Optional. The group to which the keybindings belongs.\n        \"\"\"\n        # merge this keybindings into the other first to overwrite duplicates correctly\n        tmp = other._store.copy()\n        # change group\n        if group is not None:\n            for key in tmp.values():\n                key.group = group\n        tmp.update(self._store)\n        self._store.update(tmp)\n        self.resolve_mapping()\n\n    @property\n    def key_indicator_widget(self) -> KeyIndicatorWidget:\n        \"\"\"Return the key indicator widget.\n\n        If a keychain is pressed, the key indicator prints the current keychain\n        to the top right of the screen.\n        \"\"\"\n        if not hasattr(self, \"_key_indicator_widget\"):\n            self._key_indicator_widget = KeyIndicatorWidget(\n                Caller.main_loop, Caller.widget_stack[-1], \"\"\n            )\n        return self._key_indicator_widget\n\n    def update_submap(self, key: str) -> None:\n        \"\"\"Update the submap to the submap of the given key.\"\"\"\n        self._submap = self._submap[key]\n        self._keychain.append(key)\n        self.key_indicator_widget.set_text(\" > \".join(self._keychain))\n        if not self.key_indicator_widget.is_visible:\n            self.key_indicator_widget.toggle()\n\n    def reset_submap(self) -> None:\n        \"\"\"Reset the submap to the main map.\"\"\"\n        self._submap = self._map\n        self._keychain = []\n\n    def toggle_help(self) -> None:\n        \"\"\"Toggle the keybinds overlay.\"\"\"\n        if not hasattr(self, \"_keybinds_overlay\"):\n            self._keybinds_overlay = cKeybindsOverlay(\n                Caller.main_loop, Caller.widget_stack[-1], self\n            )\n        self._keybinds_overlay.toggle()\n\n    def __getitem__(self, key: str) -> Keybind:\n        \"Get a Keybind by name.\"\n        return self._store[key]\n\n    def __delitem__(self, key: str) -> None:\n        del self._store[key]\n\n    def __setitem__(self, key: str, value: Keybind) -> None:\n        \"Set a Keybind by name.\"\n        self._store[key] = value\n\n    def __iter__(self) -> Generator[Keybind, None, None]:\n        \"Iterate over the Keybinds stored here.\"\n        return iter(self._store.values())\n\n    def __len__(self) -> int:\n        return len(self._store)",
          "inherited_members": {}
        },
        "KeyIndicatorWidget": {
          "name": "KeyIndicatorWidget",
          "path": "bamboostcli.keybinds.KeyIndicatorWidget",
          "description": "Displays the current keychain in an overlay.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "main_loop",
              "annotation": "urwid.MainLoop",
              "description": [
                {
                  "kind": "text",
                  "value": "The main loop (Caller.main_loop)"
                }
              ]
            },
            {
              "name": "bottom_w",
              "annotation": "urwid.Widget",
              "description": [
                {
                  "kind": "text",
                  "value": "The widget that is displayed below the\noverlay. Usually this should be `Caller.widget_stack[-1]`"
                }
              ]
            },
            {
              "name": "text",
              "annotation": "str",
              "description": [
                {
                  "kind": "text",
                  "value": "Initial text. Default is an empty string."
                }
              ],
              "value": "''"
            }
          ],
          "attributes": [
            {
              "name": "is_visible",
              "annotation": "bool",
              "description": null,
              "value": "False"
            },
            {
              "name": "main_loop",
              "annotation": null,
              "description": null,
              "value": "main_loop"
            },
            {
              "name": "bottom_w",
              "annotation": null,
              "description": null,
              "value": "bottom_w"
            },
            {
              "name": "text_w",
              "annotation": null,
              "description": null,
              "value": "urwid.AttrMap(urwid.Text(text), '8', '8')"
            },
            {
              "name": "overlay",
              "annotation": null,
              "description": null,
              "value": "urwid.Overlay(self.text_w, self.bottom_w, align='right', width='pack', valign='bottom', height=1)"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboostcli.keybinds.KeyIndicatorWidget.__init__",
              "signature": "(self, main_loop, bottom_w, text='')",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "main_loop",
                  "annotation": "urwid.MainLoop",
                  "description": null,
                  "value": null
                },
                {
                  "name": "bottom_w",
                  "annotation": "urwid.Widget",
                  "description": null,
                  "value": null
                },
                {
                  "name": "text",
                  "annotation": "str",
                  "description": null,
                  "value": "''"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, main_loop: urwid.MainLoop, bottom_w: urwid.Widget, text: str = \"\"):\n    self.main_loop = main_loop\n    self.bottom_w = bottom_w\n    self.text_w = urwid.AttrMap(urwid.Text(text), \"8\", \"8\")\n\n    self.overlay = urwid.Overlay(\n        self.text_w,\n        self.bottom_w,\n        align=\"right\",\n        width=\"pack\",\n        valign=\"bottom\",\n        height=1,\n    )\n    super().__init__(self.overlay)"
            },
            "set_text": {
              "name": "set_text",
              "path": "bamboostcli.keybinds.KeyIndicatorWidget.set_text",
              "signature": "(self, text) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "text",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def set_text(self, text: str) -> None:\n    self.text_w.base_widget.set_text(text)"
            },
            "reset": {
              "name": "reset",
              "path": "bamboostcli.keybinds.KeyIndicatorWidget.reset",
              "signature": "(self) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def reset(self) -> None:\n    self.text_w.base_widget.set_text(\"\")\n    if self.is_visible:\n        self.toggle()"
            },
            "toggle": {
              "name": "toggle",
              "path": "bamboostcli.keybinds.KeyIndicatorWidget.toggle",
              "signature": "(self) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def toggle(self) -> None:\n    if self.is_visible:\n        self.main_loop.widget = self.bottom_w\n        self.is_visible = False\n    else:\n        self.main_loop.widget = self\n        self.is_visible = True"
            },
            "keypress": {
              "name": "keypress",
              "path": "bamboostcli.keybinds.KeyIndicatorWidget.keypress",
              "signature": "(self, size, key) -> str | None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "size",
                  "annotation": "tuple[] | tuple[int] | tuple[int, int]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str | None",
                "description": null
              },
              "docstring": [],
              "source": "def keypress(self, size: tuple[()] | tuple[int] | tuple[int, int], key: str) -> str | None:\n    # this widget should pass all keypresses to the widget below\n    return self.bottom_w.keypress(size, key)"
            }
          },
          "source": "class KeyIndicatorWidget(urwid.Frame):\n    \"\"\"Displays the current keychain in an overlay.\n\n    Args:\n        main_loop (urwid.MainLoop): The main loop (Caller.main_loop)\n        bottom_w (urwid.Widget): The widget that is displayed below the\n            overlay. Usually this should be `Caller.widget_stack[-1]`\n        text: Initial text. Default is an empty string.\n    \"\"\"\n\n    is_visible: bool = False\n\n    def __init__(self, main_loop: urwid.MainLoop, bottom_w: urwid.Widget, text: str = \"\"):\n        self.main_loop = main_loop\n        self.bottom_w = bottom_w\n        self.text_w = urwid.AttrMap(urwid.Text(text), \"8\", \"8\")\n\n        self.overlay = urwid.Overlay(\n            self.text_w,\n            self.bottom_w,\n            align=\"right\",\n            width=\"pack\",\n            valign=\"bottom\",\n            height=1,\n        )\n        super().__init__(self.overlay)\n\n    def set_text(self, text: str) -> None:\n        self.text_w.base_widget.set_text(text)\n\n    def reset(self) -> None:\n        self.text_w.base_widget.set_text(\"\")\n        if self.is_visible:\n            self.toggle()\n\n\n    def toggle(self) -> None:\n        if self.is_visible:\n            self.main_loop.widget = self.bottom_w\n            self.is_visible = False\n        else:\n            self.main_loop.widget = self\n            self.is_visible = True\n\n    def keypress(self, size: tuple[()] | tuple[int] | tuple[int, int], key: str) -> str | None:\n        # this widget should pass all keypresses to the widget below\n        return self.bottom_w.keypress(size, key)",
          "inherited_members": {}
        },
        "cKeybindsOverlay": {
          "name": "cKeybindsOverlay",
          "path": "bamboostcli.keybinds.cKeybindsOverlay",
          "description": "Displays the keybindings in an overlay",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "main_loop",
              "annotation": "urwid.MainLoop",
              "description": [
                {
                  "kind": "text",
                  "value": "The main loop (Caller.main_loop)"
                }
              ]
            },
            {
              "name": "bottom_w",
              "annotation": "urwid.Widget",
              "description": null,
              "value": null
            },
            {
              "name": "keybinds",
              "annotation": "Keybinds",
              "description": [
                {
                  "kind": "text",
                  "value": "The keybindings to be displayed"
                }
              ]
            },
            {
              "name": "args",
              "annotation": null,
              "description": null,
              "value": "()"
            },
            {
              "name": "kwargs",
              "annotation": null,
              "description": null,
              "value": "{}"
            }
          ],
          "attributes": [
            {
              "name": "_sizing",
              "annotation": null,
              "description": null,
              "value": "frozenset(['box'])"
            },
            {
              "name": "is_visible",
              "annotation": "bool",
              "description": null,
              "value": "False"
            },
            {
              "name": "main_loop",
              "annotation": null,
              "description": null,
              "value": "main_loop"
            },
            {
              "name": "bottom_w",
              "annotation": null,
              "description": null,
              "value": "bottom_w"
            },
            {
              "name": "keybinds",
              "annotation": "Keybindings",
              "description": null,
              "value": "keybinds"
            },
            {
              "name": "box",
              "annotation": null,
              "description": null,
              "value": "cRoundedLineBox(urwid.Padding(urwid.ListBox(urwid.SimpleFocusListWalker(list_entries)), left=1, right=1), focus_map='8', title='Keybinds', title_align='left')"
            },
            {
              "name": "overlay",
              "annotation": null,
              "description": null,
              "value": "urwid.Overlay(self.box, self.bottom_w, align='left', valign='bottom', height=max_height + 2, width=max_width + 4, bottom=1)"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboostcli.keybinds.cKeybindsOverlay.__init__",
              "signature": "(self, main_loop, bottom_w, keybinds, *args, **kwargs)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "main_loop",
                  "annotation": "urwid.MainLoop",
                  "description": null,
                  "value": null
                },
                {
                  "name": "bottom_w",
                  "annotation": "urwid.Widget",
                  "description": null,
                  "value": null
                },
                {
                  "name": "keybinds",
                  "annotation": "Keybindings | tuple[Keybindings]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(\n    self,\n    main_loop: urwid.MainLoop,\n    bottom_w: urwid.Widget,\n    keybinds: Keybindings | tuple[Keybindings],\n    *args,\n    **kwargs,\n):\n    self.main_loop = main_loop\n    self.bottom_w = bottom_w\n    self.keybinds: Keybindings = keybinds\n\n    # group the keybinds by group\n    groups = {}\n    for key in keybinds:\n        if key.group not in groups:\n            groups[key.group] = []\n        groups[key.group].append(key)\n\n    # calculate the longest name and key for padding\n    longest_name = max(len(key.name) for key in keybinds)\n    longest_key = max(len(key.key_as_string()) for key in keybinds)\n\n    # construct the list entries for the pile\n    list_entries = []\n    for group, keys in groups.items():\n        if group:\n            list_entries.append(urwid.Divider(\"-\"))\n            list_entries.append(\n                urwid.Padding(urwid.Text((\"8-bold\", group.capitalize()), align=\"center\")),\n            )\n        list_entries.extend(\n            [\n                urwid.Columns(\n                    [\n                        (longest_name, urwid.Text((\"4\", key.name), align=\"left\")),\n                        (\n                            longest_key,\n                            urwid.Text((\"3-bold\", key.key_as_string()), align=\"right\"),\n                        ),\n                        (\n                            \"pack\",\n                            urwid.Padding(\n                                urwid.Text((\"\", key.description)),\n                                width=min(\n                                    Caller.main_loop.screen.get_cols_rows()[0] // 3,\n                                    len(key.description),\n                                ),\n                            ),\n                        ),\n                        (\n                            \"weight\",\n                            1,\n                            urwid.Text(\n                                (\n                                    \"3\",\n                                    \"[\" + \", \".join(key.aliases) + \"]\" if key.aliases else \"\",\n                                ),\n                                align=\"right\",\n                            ),\n                        ),\n                    ],\n                    dividechars=2,\n                )\n                for key in keys\n            ]\n        )\n\n    # calculate the max width and height of the columns for the sizing of the overlay\n    max_width = max(w.pack(())[0] for w in list_entries if urwid.FIXED in w.sizing())\n    max_height = sum(\n        w.pack((max_width,))[1] for w in list_entries if urwid.FIXED in w.sizing()\n    ) + sum(1 for w in list_entries if urwid.FIXED not in w.sizing())\n\n    self.box = cRoundedLineBox(\n        urwid.Padding(\n            urwid.ListBox(urwid.SimpleFocusListWalker(list_entries)), left=1, right=1\n        ),\n        focus_map=\"8\",\n        title=\"Keybinds\",\n        title_align=\"left\",\n    )\n    self.overlay = urwid.Overlay(\n        self.box,\n        self.bottom_w,\n        align=\"left\",\n        valign=\"bottom\",\n        height=max_height + 2,  # +2 for border\n        width=max_width + 4,  # +2 for padding, +2 for border\n        bottom=1,\n    )\n    super().__init__(self.overlay, *args, **kwargs)"
            },
            "toggle": {
              "name": "toggle",
              "path": "bamboostcli.keybinds.cKeybindsOverlay.toggle",
              "signature": "(self) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def toggle(self) -> None:\n    if self.is_visible and self.main_loop.widget == self:\n        self.main_loop.widget = self.bottom_w\n        self.is_visible = False\n    else:\n        self.main_loop.widget = self\n        self.is_visible = True"
            },
            "keypress": {
              "name": "keypress",
              "path": "bamboostcli.keybinds.cKeybindsOverlay.keypress",
              "signature": "(self, size, key) -> str | None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "size",
                  "annotation": "tuple[] | tuple[int] | tuple[int, int]",
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str | None",
                "description": null
              },
              "docstring": [],
              "source": "def keypress(self, size: tuple[()] | tuple[int] | tuple[int, int], key: str) -> str | None:\n    if key in (\"esc\", \"q\"):\n        # Set the widget of loop back to the original widget\n        return self.toggle()\n\n    # all other keypresses are passed to the widget below\n    return self.bottom_w.keypress(size, key)"
            }
          },
          "source": "class cKeybindsOverlay(urwid.Frame):\n    \"\"\"Displays the keybindings in an overlay\n\n    Args:\n        main_loop (urwid.MainLoop): The main loop (Caller.main_loop)\n        keybinds (Keybinds): The keybindings to be displayed\n    \"\"\"\n\n    _sizing = frozenset([\"box\"])\n    is_visible: bool = False\n\n    def __init__(\n        self,\n        main_loop: urwid.MainLoop,\n        bottom_w: urwid.Widget,\n        keybinds: Keybindings | tuple[Keybindings],\n        *args,\n        **kwargs,\n    ):\n        self.main_loop = main_loop\n        self.bottom_w = bottom_w\n        self.keybinds: Keybindings = keybinds\n\n        # group the keybinds by group\n        groups = {}\n        for key in keybinds:\n            if key.group not in groups:\n                groups[key.group] = []\n            groups[key.group].append(key)\n\n        # calculate the longest name and key for padding\n        longest_name = max(len(key.name) for key in keybinds)\n        longest_key = max(len(key.key_as_string()) for key in keybinds)\n\n        # construct the list entries for the pile\n        list_entries = []\n        for group, keys in groups.items():\n            if group:\n                list_entries.append(urwid.Divider(\"-\"))\n                list_entries.append(\n                    urwid.Padding(urwid.Text((\"8-bold\", group.capitalize()), align=\"center\")),\n                )\n            list_entries.extend(\n                [\n                    urwid.Columns(\n                        [\n                            (longest_name, urwid.Text((\"4\", key.name), align=\"left\")),\n                            (\n                                longest_key,\n                                urwid.Text((\"3-bold\", key.key_as_string()), align=\"right\"),\n                            ),\n                            (\n                                \"pack\",\n                                urwid.Padding(\n                                    urwid.Text((\"\", key.description)),\n                                    width=min(\n                                        Caller.main_loop.screen.get_cols_rows()[0] // 3,\n                                        len(key.description),\n                                    ),\n                                ),\n                            ),\n                            (\n                                \"weight\",\n                                1,\n                                urwid.Text(\n                                    (\n                                        \"3\",\n                                        \"[\" + \", \".join(key.aliases) + \"]\" if key.aliases else \"\",\n                                    ),\n                                    align=\"right\",\n                                ),\n                            ),\n                        ],\n                        dividechars=2,\n                    )\n                    for key in keys\n                ]\n            )\n\n        # calculate the max width and height of the columns for the sizing of the overlay\n        max_width = max(w.pack(())[0] for w in list_entries if urwid.FIXED in w.sizing())\n        max_height = sum(\n            w.pack((max_width,))[1] for w in list_entries if urwid.FIXED in w.sizing()\n        ) + sum(1 for w in list_entries if urwid.FIXED not in w.sizing())\n\n        self.box = cRoundedLineBox(\n            urwid.Padding(\n                urwid.ListBox(urwid.SimpleFocusListWalker(list_entries)), left=1, right=1\n            ),\n            focus_map=\"8\",\n            title=\"Keybinds\",\n            title_align=\"left\",\n        )\n        self.overlay = urwid.Overlay(\n            self.box,\n            self.bottom_w,\n            align=\"left\",\n            valign=\"bottom\",\n            height=max_height + 2,  # +2 for border\n            width=max_width + 4,  # +2 for padding, +2 for border\n            bottom=1,\n        )\n        super().__init__(self.overlay, *args, **kwargs)\n\n    def toggle(self) -> None:\n        if self.is_visible and self.main_loop.widget == self:\n            self.main_loop.widget = self.bottom_w\n            self.is_visible = False\n        else:\n            self.main_loop.widget = self\n            self.is_visible = True\n\n    def keypress(self, size: tuple[()] | tuple[int] | tuple[int, int], key: str) -> str | None:\n        if key in (\"esc\", \"q\"):\n            # Set the widget of loop back to the original widget\n            return self.toggle()\n\n        # all other keypresses are passed to the widget below\n        return self.bottom_w.keypress(size, key)",
          "inherited_members": {}
        }
      },
      "functions": {
        "apply_user_keybinds": {
          "name": "apply_user_keybinds",
          "path": "bamboostcli.keybinds.apply_user_keybinds",
          "signature": "(keybinds, table) -> None",
          "description": "Apply user keybindings to the keybindings table.",
          "parameters": [
            {
              "name": "keybinds",
              "annotation": "Keybindings",
              "description": [
                {
                  "kind": "text",
                  "value": "The keybindings table."
                }
              ]
            },
            {
              "name": "table",
              "annotation": "str",
              "description": [
                {
                  "kind": "text",
                  "value": "The corresponding table in the toml config. E.g.\n\"database\", ..."
                }
              ]
            }
          ],
          "returns": {
            "name": "",
            "annotation": "None",
            "description": null
          },
          "docstring": [],
          "source": "def apply_user_keybinds(keybinds: Keybindings, table: str) -> None:\n    \"\"\"Apply user keybindings to the keybindings table.\n\n    Args:\n        keybinds (Keybindings): The keybindings table.\n        table (str): The corresponding table in the toml config. E.g.\n            \"database\", ...\n    \"\"\"\n    Config.load_custom_functions()\n    for name, key in Config.keybinds.get(table, {}).items():\n        if isinstance(key, dict):\n            new_keybind = Keybind(\n                name, key[\"key\"], Config.custom_functions[key[\"func\"]], \"\", group=\"custom\"\n            )\n            keybinds.add(new_keybind)\n            continue\n\n        # if just a key is given, use the default function but replace the key\n        keybinds[name].key = key"
        }
      }
    },
    "common": {
      "name": "common",
      "path": "bamboostcli.common",
      "filepath": "/home/florez/work/code/hdftui/bamboostcli/common.py",
      "description": "This module contains common classes and functions used by the TUI\napplication.",
      "docstring": [],
      "attributes": [
        {
          "name": "FIGLET",
          "annotation": null,
          "description": null,
          "value": "'\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \\n'"
        },
        {
          "name": "VERTICAL_KEYS",
          "annotation": null,
          "description": null,
          "value": "{'up', 'down', 'ctrl n', 'ctrl p', 'page up', 'page down', 'home', 'end'}"
        },
        {
          "name": "CONFIG_DIR",
          "annotation": null,
          "description": null,
          "value": "os.path.expanduser('~/.config/bamboost')"
        },
        {
          "name": "CONFIG_FILE",
          "annotation": null,
          "description": null,
          "value": "os.path.join(CONFIG_DIR, 'tui.toml')"
        },
        {
          "name": "CUSTOM_FUNCTIONS",
          "annotation": null,
          "description": null,
          "value": "os.path.join(CONFIG_DIR, 'custom_functions.py')"
        },
        {
          "name": "config",
          "annotation": null,
          "description": null,
          "value": "tomllib.load(f)"
        },
        {
          "name": "color_map",
          "annotation": null,
          "description": null,
          "value": "{1: 'black', 2: 'dark red', 3: 'dark green', 4: 'brown', 5: 'dark blue', 6: 'dark magenta', 7: 'dark cyan', 8: 'light gray', 9: 'dark gray', 10: 'light red', 11: 'light green', 12: 'yellow', 13: 'light blue', 14: 'light magenta', 15: 'light cyan', 16: 'white'}"
        },
        {
          "name": "palette",
          "annotation": "list",
          "description": null,
          "value": "[]"
        }
      ],
      "modules": {},
      "classes": {
        "Caller": {
          "name": "Caller",
          "path": "bamboostcli.common.Caller",
          "description": "Caller holds the main urwid loop and a widget stack. It manages the flow\nof pages and widgets, e.g. which is on top and which should be shown when a\nwidget is exited.",
          "parameters": [],
          "attributes": [
            {
              "name": "widget_stack",
              "annotation": null,
              "description": "A list of widgets that are currently in the stack.",
              "value": "[]"
            },
            {
              "name": "main_loop",
              "annotation": "urwid.MainLoop",
              "description": "The main loop of the urwid application.",
              "value": "None"
            }
          ],
          "docstring": [],
          "functions": {
            "enter_widget": {
              "name": "enter_widget",
              "path": "bamboostcli.common.Caller.enter_widget",
              "signature": "(cls, widget)",
              "description": "Enters a new widget into the widget stack and sets it as the main\nwidget in the main loop.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "widget",
                  "annotation": "urwid.Widget",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The widget to enter into the widget stack."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@classmethod\ndef enter_widget(cls, widget: urwid.Widget):\n    \"\"\"Enters a new widget into the widget stack and sets it as the main\n    widget in the main loop.\n\n    Args:\n        widget (urwid.Widget): The widget to enter into the widget stack.\n    \"\"\"\n    cls.widget_stack.append(widget)\n    cls.main_loop.widget = widget"
            },
            "exit_widget": {
              "name": "exit_widget",
              "path": "bamboostcli.common.Caller.exit_widget",
              "signature": "(cls)",
              "description": "Exits the current widget by removing it from the widget stack and\nsetting the previous widget as the main widget in the main loop.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [
                {
                  "kind": "raises",
                  "value": [
                    {
                      "annotation": "urwid.ExitMainLoop",
                      "description": "If there are no more widgets in the stack,\nraises an ExitMainLoop exception to exit the main loop."
                    }
                  ]
                }
              ],
              "source": "@classmethod\ndef exit_widget(cls):\n    \"\"\"Exits the current widget by removing it from the widget stack and\n    setting the previous widget as the main widget in the main loop.\n\n    Raises:\n        urwid.ExitMainLoop: If there are no more widgets in the stack,\n            raises an ExitMainLoop exception to exit the main loop.\n    \"\"\"\n    if len(cls.widget_stack) <= 1:\n        raise urwid.ExitMainLoop()\n    cls.widget_stack.pop()\n    cls.main_loop.widget = cls.widget_stack[-1]"
            }
          },
          "source": "class Caller:\n    \"\"\"Caller holds the main urwid loop and a widget stack. It manages the flow\n    of pages and widgets, e.g. which is on top and which should be shown when a\n    widget is exited.\n\n    Attributes:\n        widget_stack: A list of widgets that are currently in the stack.\n        main_loop: The main loop of the urwid application.\n    \"\"\"\n\n    widget_stack = []\n    main_loop: urwid.MainLoop = None\n\n    @classmethod\n    def enter_widget(cls, widget: urwid.Widget):\n        \"\"\"Enters a new widget into the widget stack and sets it as the main\n        widget in the main loop.\n\n        Args:\n            widget (urwid.Widget): The widget to enter into the widget stack.\n        \"\"\"\n        cls.widget_stack.append(widget)\n        cls.main_loop.widget = widget\n\n    @classmethod\n    def exit_widget(cls):\n        \"\"\"Exits the current widget by removing it from the widget stack and\n        setting the previous widget as the main widget in the main loop.\n\n        Raises:\n            urwid.ExitMainLoop: If there are no more widgets in the stack,\n                raises an ExitMainLoop exception to exit the main loop.\n        \"\"\"\n        if len(cls.widget_stack) <= 1:\n            raise urwid.ExitMainLoop()\n        cls.widget_stack.pop()\n        cls.main_loop.widget = cls.widget_stack[-1]",
          "inherited_members": {}
        },
        "Config": {
          "name": "Config",
          "path": "bamboostcli.common.Config",
          "description": "Namespace for configuration settings from the user config file\n\"~/.config/bamboost/tui.toml\".",
          "parameters": [],
          "attributes": [
            {
              "name": "keybinds",
              "annotation": "dict",
              "description": "Parsed dictionary of the [keybinds] table from the config\nfile.",
              "value": "{}"
            },
            {
              "name": "theme",
              "annotation": "str",
              "description": "The theme to use for the application. (Not used yet)",
              "value": "'default'"
            },
            {
              "name": "custom_functions",
              "annotation": "dict",
              "description": "A namespace for custom functions defined in the\ncustom functions file.",
              "value": "{}"
            },
            {
              "name": "table",
              "annotation": "dict",
              "description": null,
              "value": "{}"
            }
          ],
          "docstring": [],
          "functions": {
            "load_custom_functions": {
              "name": "load_custom_functions",
              "path": "bamboostcli.common.Config.load_custom_functions",
              "signature": "(cls)",
              "description": "Read the custom functions file and execute it to define the custom\nfunctions. The global namespace of the custom functions file is set to\nthe `custom_functions` dictionary of this class.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "@classmethod\ndef load_custom_functions(cls):\n    \"\"\"Read the custom functions file and execute it to define the custom\n    functions. The global namespace of the custom functions file is set to\n    the `custom_functions` dictionary of this class.\n    \"\"\"\n    for file in chain(cls.keybinds.get(\"custom_files\", []), [CUSTOM_FUNCTIONS]):\n        if not os.path.exists(file):\n            continue\n        with open(file, \"r\") as f:\n            custom_functions = f.read()\n        exec(custom_functions, cls.custom_functions)"
            }
          },
          "source": "class Config:\n    \"\"\"\n    Namespace for configuration settings from the user config file\n    \"~/.config/bamboost/tui.toml\".\n\n    Attributes:\n        keybinds: Parsed dictionary of the [keybinds] table from the config\n            file.\n        theme: The theme to use for the application. (Not used yet)\n        custom_functions: A namespace for custom functions defined in the\n            custom functions file.\n    \"\"\"\n\n    keybinds: dict[str, str] = {}\n    theme: str = \"default\"\n    custom_functions: dict = {}\n    table: dict = {}\n\n    @classmethod\n    def load_custom_functions(cls):\n        \"\"\"Read the custom functions file and execute it to define the custom\n        functions. The global namespace of the custom functions file is set to\n        the `custom_functions` dictionary of this class.\n        \"\"\"\n        for file in chain(cls.keybinds.get(\"custom_files\", []), [CUSTOM_FUNCTIONS]):\n            if not os.path.exists(file):\n                continue\n            with open(file, \"r\") as f:\n                custom_functions = f.read()\n            exec(custom_functions, cls.custom_functions)",
          "inherited_members": {}
        },
        "Spinner": {
          "name": "Spinner",
          "path": "bamboostcli.common.Spinner",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "attr_map",
              "annotation": "str",
              "description": null,
              "value": "None"
            },
            {
              "name": "focus_map",
              "annotation": "str",
              "description": null,
              "value": "None"
            },
            {
              "name": "kwargs",
              "annotation": null,
              "description": null,
              "value": "{}"
            }
          ],
          "attributes": [
            {
              "name": "spinner",
              "annotation": null,
              "description": null,
              "value": "['|', '/', '-', '\\\\']"
            },
            {
              "name": "frame",
              "annotation": null,
              "description": null,
              "value": "0"
            },
            {
              "name": "on",
              "annotation": null,
              "description": null,
              "value": "False"
            },
            {
              "name": "spinner_speed",
              "annotation": null,
              "description": null,
              "value": "kwargs.get('speed', 0.1)"
            },
            {
              "name": "caption",
              "annotation": null,
              "description": null,
              "value": "kwargs.get('caption', '')"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboostcli.common.Spinner.__init__",
              "signature": "(self, attr_map=None, focus_map=None, **kwargs)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "attr_map",
                  "annotation": "str",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "focus_map",
                  "annotation": "str",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, attr_map: str = None, focus_map: str = None, **kwargs):\n    self.spinner = [\"|\", \"/\", \"-\", \"\\\\\"]\n    self.frame = 0\n    self.on = False\n    self.spinner_speed = kwargs.get(\"speed\", 0.1)\n    self.caption = kwargs.get(\"caption\", \"\")\n    super().__init__(urwid.Text(\"\", align=kwargs.get(\"align\", \"left\")), attr_map, focus_map)"
            },
            "__enter__": {
              "name": "__enter__",
              "path": "bamboostcli.common.Spinner.__enter__",
              "signature": "(self)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __enter__(self):\n    return self.start()"
            },
            "__exit__": {
              "name": "__exit__",
              "path": "bamboostcli.common.Spinner.__exit__",
              "signature": "(self, exc_type, exc_value, traceback)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "exc_type",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "exc_value",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "traceback",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def __exit__(self, exc_type, exc_value, traceback):\n    self.stop()"
            },
            "update_spinner": {
              "name": "update_spinner",
              "path": "bamboostcli.common.Spinner.update_spinner",
              "signature": "(self, loop, user_data=None)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "loop",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "user_data",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def update_spinner(self, loop, user_data=None):\n    if self.on:\n        self.frame = (self.frame + 1) % len(self.spinner)\n        self.base_widget.set_text(\"\".join((self.caption, self.spinner[self.frame])))\n        loop.set_alarm_in(self.spinner_speed, self.update_spinner)"
            },
            "start": {
              "name": "start",
              "path": "bamboostcli.common.Spinner.start",
              "signature": "(self) -> Spinner",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bamboostcli.common.Spinner",
                "description": null
              },
              "docstring": [],
              "source": "def start(self) -> Spinner:\n    self.on = True\n    self.update_spinner(Caller.main_loop)\n    return self"
            },
            "stop": {
              "name": "stop",
              "path": "bamboostcli.common.Spinner.stop",
              "signature": "(self) -> Spinner",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bamboostcli.common.Spinner",
                "description": null
              },
              "docstring": [],
              "source": "def stop(self) -> Spinner:\n    self.base_widget.set_text(\"\")\n    self.on = False\n    return self"
            }
          },
          "source": "class Spinner(urwid.AttrMap):\n    def __init__(self, attr_map: str = None, focus_map: str = None, **kwargs):\n        self.spinner = [\"|\", \"/\", \"-\", \"\\\\\"]\n        self.frame = 0\n        self.on = False\n        self.spinner_speed = kwargs.get(\"speed\", 0.1)\n        self.caption = kwargs.get(\"caption\", \"\")\n        super().__init__(urwid.Text(\"\", align=kwargs.get(\"align\", \"left\")), attr_map, focus_map)\n\n    def __enter__(self):\n        return self.start()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.stop()\n\n    def update_spinner(self, loop, user_data=None):\n        if self.on:\n            self.frame = (self.frame + 1) % len(self.spinner)\n            self.base_widget.set_text(\"\".join((self.caption, self.spinner[self.frame])))\n            loop.set_alarm_in(self.spinner_speed, self.update_spinner)\n\n    def start(self) -> Spinner:\n        self.on = True\n        self.update_spinner(Caller.main_loop)\n        return self\n\n    def stop(self) -> Spinner:\n        self.base_widget.set_text(\"\")\n        self.on = False\n        return self",
          "inherited_members": {}
        }
      },
      "functions": {
        "redirect_stdout": {
          "name": "redirect_stdout",
          "path": "bamboostcli.common.redirect_stdout",
          "signature": "(new_stdout='devnull')",
          "description": null,
          "parameters": [
            {
              "name": "new_stdout",
              "annotation": null,
              "description": null,
              "value": "'devnull'"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "@contextmanager\ndef redirect_stdout(new_stdout=\"devnull\"):\n    if new_stdout == \"devnull\":\n        new_stdout = open(os.devnull, \"w\")\n    original_stdout = sys.stdout\n    sys.stdout = new_stdout\n    try:\n        yield None\n    finally:\n        new_stdout.close()\n        sys.stdout = original_stdout"
        },
        "redirect_allout": {
          "name": "redirect_allout",
          "path": "bamboostcli.common.redirect_allout",
          "signature": "(new_stdout='devnull')",
          "description": null,
          "parameters": [
            {
              "name": "new_stdout",
              "annotation": null,
              "description": null,
              "value": "'devnull'"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "@contextmanager\ndef redirect_allout(new_stdout=\"devnull\"):\n    if new_stdout == \"devnull\":\n        new_stdout = open(os.devnull, \"w\")\n    original_stdout = sys.stdout\n    original_stderr = sys.stderr\n    sys.stdout = new_stdout\n    sys.stderr = new_stdout\n    try:\n        yield None\n    finally:\n        new_stdout.close()\n        sys.stdout = original_stdout\n        sys.stderr = original_stderr"
        }
      }
    },
    "app": {
      "name": "app",
      "path": "bamboostcli.app",
      "filepath": "/home/florez/work/code/hdftui/bamboostcli/app.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {},
      "classes": {},
      "functions": {
        "main": {
          "name": "main",
          "path": "bamboostcli.app.main",
          "signature": "()",
          "description": null,
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def main():\n    if not sys.stdin.isatty():\n        path = input()\n        sys.stdin = open(\"/dev/tty\", \"r\")\n    else:\n        parser = argparse.ArgumentParser(description=\"bamboostcli\")\n        parser.add_argument(\n            \"-v\",\n            \"--version\",\n            action=\"version\",\n            version=f\"bamboost {bamboost.__version__}; bamboostcli {__version__}\",\n        )\n        parser.add_argument(\n            \"-r\", \"--remote\", action=\"store_true\", help=\"Directly open default remote database.\"\n        )\n        parser.add_argument(\n            \"-l\", \"--locking\", action=\"store_true\", help=\"Enable custom locking of h5 files.\"\n        )\n        parser.add_argument(\"path\", nargs=\"?\", help=\"Path to directly open a bamboost database.\")\n        args = parser.parse_args()\n        path = args.path\n\n        if args.locking:\n            from bamboost.extensions.use_locking import use_locking\n\n            use_locking(\"exclusive\")\n\n    if sys.stdout.isatty():\n        Caller.OUTPIPE = False\n    else:\n        Caller.OUTPIPE = True\n\n    if args.remote:\n        first_remote = Remote.list()[0]\n        remote_index = IndexRemote(remote=Remote(first_remote, skip_update=True))\n        ui = cPopup(\n            remote_index,\n            title=f\"Remote databases [{first_remote}] - ctrl + r to fetch index\",\n        )\n        enter_main_loop(ui)\n        return\n\n    if path is not None:\n        # Filter the databases which have the given path as a parent\n        # If only 1 database is found, open it directly\n        # If multiple databases are found, show a list of them\n\n        path = os.path.abspath(path)\n        index = IndexAPI().fetch(\"SELECT id, path FROM dbindex\")\n        candidates = {\n            id: str(Path(val).relative_to(Path(path)))\n            for id, val in index\n            if Path(path) in [*Path(val).parents, Path(val)]\n        }\n\n        if len(candidates) == 1:\n            id = next(iter(candidates))\n            ui = Database(id, bamboost.Manager(uid=id))\n            enter_main_loop(ui)\n            return\n\n        if len(candidates) > 1:\n\n            def cb(action_item: cActionItem):\n                id = action_item.content[0]\n                ui = Database(id, bamboost.Manager(uid=id))\n                Caller.widget_stack.pop()\n                Caller.enter_widget(ui)\n\n            items = [cActionItem(candidate, callback=cb) for candidate in candidates.items()]\n            ui = cPopup(\n                cListBoxSelectionCharacter(\n                    items, attr_map={0: \"5\", 1: \"8\"}, focus_map={0: \"5-bold\", 1: \"8-bold\"}\n                ),\n                height=len(candidates),\n                title=\"Select a database\",\n            )\n            enter_main_loop(ui)\n            return\n\n    enter_main_loop(WelcomeUI().frame)"
        },
        "enter_main_loop": {
          "name": "enter_main_loop",
          "path": "bamboostcli.app.enter_main_loop",
          "signature": "(widget, screen=None)",
          "description": null,
          "parameters": [
            {
              "name": "widget",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "screen",
              "annotation": null,
              "description": null,
              "value": "None"
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def enter_main_loop(widget, screen=None):\n    screen = urwid.raw_display.Screen(input=sys.stdin, output=sys.stderr)\n    Caller.main_loop = urwid.MainLoop(widget, palette, unhandled_input=exit, screen=screen)\n    Caller.main_loop.handle_mouse = True\n    Caller.main_loop.screen.set_terminal_properties(colors=256)\n    Caller.widget_stack.append(widget)\n    Caller.main_loop.run()"
        },
        "exit": {
          "name": "exit",
          "path": "bamboostcli.app.exit",
          "signature": "(key)",
          "description": null,
          "parameters": [
            {
              "name": "key",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def exit(key):\n    if key == \"q\":\n        Caller.exit_widget()\n    elif key == \"Q\":\n        raise urwid.ExitMainLoop()"
        }
      }
    },
    "parser": {
      "name": "parser",
      "path": "bamboostcli.parser",
      "filepath": "/home/florez/work/code/hdftui/bamboostcli/parser/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "parser": {
          "name": "parser",
          "path": "bamboostcli.parser.parser",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/parser/parser.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "ArgumentParser": {
              "name": "ArgumentParser",
              "path": "bamboostcli.parser.parser.ArgumentParser",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "completer",
                  "annotation": null,
                  "description": null,
                  "value": "argcomplete.finders.CompletionFinder(self)"
                },
                {
                  "name": "prefix",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.parser.parser.ArgumentParser.__init__",
                  "signature": "(self, *args, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.completer = argcomplete.finders.CompletionFinder(self)"
                },
                "set_prefix": {
                  "name": "set_prefix",
                  "path": "bamboostcli.parser.parser.ArgumentParser.set_prefix",
                  "signature": "(self, prefix)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "prefix",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def set_prefix(self, prefix):\n    self._prefix = prefix"
                },
                "current_suggestions": {
                  "name": "current_suggestions",
                  "path": "bamboostcli.parser.parser.ArgumentParser.current_suggestions",
                  "signature": "(self, text)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "text",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def current_suggestions(self, text):\n    # preprend prefix to text\n    text = self.prefix + text\n\n    # split text into parts\n    cword_prequote, cword_prefix, cword_suffix, comp_words, first_colon_pos = (\n        argcomplete.lexers.split_line(text)\n    )\n    # inject dummy word at 0\n    comp_words.insert(0, \"dummy\")\n    matches = self.completer._get_completions(\n        comp_words, cword_prefix, cword_prequote, first_colon_pos\n    )\n\n    # remove options (--) if not started with it\n    if not cword_prefix.startswith(\"-\"):\n        matches = [m for m in matches if not m.startswith(\"-\")]\n    return sorted(matches, key=lambda x: len(x))"
                },
                "eval": {
                  "name": "eval",
                  "path": "bamboostcli.parser.parser.ArgumentParser.eval",
                  "signature": "(self, text)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "text",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def eval(self, text):\n    # preprend prefix to text\n    text = self.prefix + text\n    args = self.parse_args(text.split())"
                },
                "parse_string": {
                  "name": "parse_string",
                  "path": "bamboostcli.parser.parser.ArgumentParser.parse_string",
                  "signature": "(self, text)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "text",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse_string(self, text):\n    # preprend prefix to text\n    text = self.prefix + text\n    arg_list = text.split()\n    return self.parse_args(arg_list)"
                }
              },
              "source": "class ArgumentParser(argparse.ArgumentParser):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.completer = argcomplete.finders.CompletionFinder(self)\n\n    def set_prefix(self, prefix):\n        self._prefix = prefix\n\n    @property\n    def prefix(self):\n        if hasattr(self, \"_prefix\"):\n            return self._prefix\n        self._prefix = \"\"\n        return self._prefix\n\n    def current_suggestions(self, text):\n        # preprend prefix to text\n        text = self.prefix + text\n\n        # split text into parts\n        cword_prequote, cword_prefix, cword_suffix, comp_words, first_colon_pos = (\n            argcomplete.lexers.split_line(text)\n        )\n        # inject dummy word at 0\n        comp_words.insert(0, \"dummy\")\n        matches = self.completer._get_completions(\n            comp_words, cword_prefix, cword_prequote, first_colon_pos\n        )\n\n        # remove options (--) if not started with it\n        if not cword_prefix.startswith(\"-\"):\n            matches = [m for m in matches if not m.startswith(\"-\")]\n        return sorted(matches, key=lambda x: len(x))\n\n    def eval(self, text):\n        # preprend prefix to text\n        text = self.prefix + text\n        args = self.parse_args(text.split())\n\n    def parse_string(self, text):\n        # preprend prefix to text\n        text = self.prefix + text\n        arg_list = text.split()\n        return self.parse_args(arg_list)",
              "inherited_members": {}
            }
          },
          "functions": {}
        }
      },
      "classes": {},
      "functions": {}
    },
    "widgets": {
      "name": "widgets",
      "path": "bamboostcli.widgets",
      "filepath": "/home/florez/work/code/hdftui/bamboostcli/widgets/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "autocomplete_edit": {
          "name": "autocomplete_edit",
          "path": "bamboostcli.widgets.autocomplete_edit",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/widgets/autocomplete_edit.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "AutocompleteEdit": {
              "name": "AutocompleteEdit",
              "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteEdit",
              "description": "Edit widget with autocomplete suggestions. Need custom container to display popup,\nwhich controls the rendering of the screen.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "suggestions",
                  "annotation": "Iterable",
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "ATTRS",
                  "annotation": null,
                  "description": null,
                  "value": "('0-reverse', '4-reverse-bold')"
                },
                {
                  "name": "all_suggestions",
                  "annotation": null,
                  "description": null,
                  "value": "suggestions"
                },
                {
                  "name": "suggestions",
                  "annotation": null,
                  "description": null,
                  "value": "self.all_suggestions"
                },
                {
                  "name": "popup",
                  "annotation": null,
                  "description": null,
                  "value": "cw.cListBox(urwid.SimpleFocusListWalker([]), wrap=False)"
                },
                {
                  "name": "show_popup",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteEdit.__init__",
                  "signature": "(self, suggestions, *args, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "suggestions",
                      "annotation": "Iterable",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, suggestions: Iterable, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.all_suggestions = suggestions\n    self.suggestions = self.all_suggestions\n    self.popup = cw.cListBox(urwid.SimpleFocusListWalker([]), wrap=False)\n    self.show_popup = False"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteEdit.keypress",
                  "signature": "(self, size, key)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size, key):\n    if key == \"tab\":\n        # Use Tab key to select suggestions\n        if not self.show_popup:\n            return None\n        self.set_edit_text(self.popup.get_focus()[0].base_widget.text)\n        self.set_edit_pos(len(self.edit_text))\n        self.show_popup = False\n    elif key == \"<0>\":\n        # Ctrl + Space to toggle popup\n        self.show_popup = not self.show_popup\n        if self.show_popup:\n            self._update_popup(force_show=True)\n    elif key in VERTICAL_KEYS and self.show_popup:\n        self.popup.keypress((size[0], 1), key)\n    else:\n        super().keypress(size, key)\n        self._update_popup()"
                },
                "_update_popup": {
                  "name": "_update_popup",
                  "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteEdit._update_popup",
                  "signature": "(self, force_show=False) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "force_show",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _update_popup(self, force_show: bool = False) -> None:\n    # Logic to update and display popup with suggestions\n    if not force_show:\n        self.show_popup = self.edit_text != \"\"\n    self.suggestions = {s for s in self.suggestions if s.startswith(self.edit_text)}\n    if not self.suggestions:\n        self.show_popup = False\n    self.popup.body = urwid.SimpleFocusListWalker(\n        [\n            urwid.AttrMap(urwid.Padding(urwid.Text(s), left=1), *self.ATTRS)\n            for s in self.suggestions\n        ]\n    )"
                }
              },
              "source": "class AutocompleteEdit(cw.cEdit):\n    \"\"\"Edit widget with autocomplete suggestions. Need custom container to display popup,\n    which controls the rendering of the screen.\n\n    Args:\n        caption (str): The caption to display (e.g. \":\")\n        edit_text (str): The initial text\n        ...\n    \"\"\"\n\n    ATTRS = (\"0-reverse\", \"4-reverse-bold\")\n\n    def __init__(self, suggestions: Iterable, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.all_suggestions = suggestions\n        self.suggestions = self.all_suggestions\n        self.popup = cw.cListBox(urwid.SimpleFocusListWalker([]), wrap=False)\n        self.show_popup = False\n\n    def keypress(self, size, key):\n        if key == \"tab\":\n            # Use Tab key to select suggestions\n            if not self.show_popup:\n                return None\n            self.set_edit_text(self.popup.get_focus()[0].base_widget.text)\n            self.set_edit_pos(len(self.edit_text))\n            self.show_popup = False\n        elif key == \"<0>\":\n            # Ctrl + Space to toggle popup\n            self.show_popup = not self.show_popup\n            if self.show_popup:\n                self._update_popup(force_show=True)\n        elif key in VERTICAL_KEYS and self.show_popup:\n            self.popup.keypress((size[0], 1), key)\n        else:\n            super().keypress(size, key)\n            self._update_popup()\n\n    def _update_popup(self, force_show: bool = False) -> None:\n        # Logic to update and display popup with suggestions\n        if not force_show:\n            self.show_popup = self.edit_text != \"\"\n        self.suggestions = {s for s in self.suggestions if s.startswith(self.edit_text)}\n        if not self.suggestions:\n            self.show_popup = False\n        self.popup.body = urwid.SimpleFocusListWalker(\n            [\n                urwid.AttrMap(urwid.Padding(urwid.Text(s), left=1), *self.ATTRS)\n                for s in self.suggestions\n            ]\n        )",
              "inherited_members": {
                "bamboostcli.widgets.custom_widgets.cEdit": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cEdit.signals"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cEdit.callback"
                  }
                ]
              }
            },
            "AutocompleteContainer": {
              "name": "AutocompleteContainer",
              "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer",
              "description": "Custom container to hold the auto complete edit widget. Make sure the edit widget is\na part of the container (e.g. in the footer of a frame)",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "edit",
                  "annotation": "AutocompleteEdit",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The edit widget with autocomplete suggestions"
                    }
                  ]
                },
                {
                  "name": "container",
                  "annotation": "urwid.Widget",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The main container to be rendered"
                    }
                  ]
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "edit",
                  "annotation": null,
                  "description": null,
                  "value": "edit"
                },
                {
                  "name": "container",
                  "annotation": null,
                  "description": null,
                  "value": "container"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer.__init__",
                  "signature": "(self, edit, container, *args, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "edit",
                      "annotation": "AutocompleteEdit",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "container",
                      "annotation": "urwid.Widget",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, edit: AutocompleteEdit, container: urwid.Widget, *args, **kwargs):\n    self.edit = edit\n    self.container = container\n    super().__init__(self.container)"
                },
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer.render",
                  "signature": "(self, size, focus=False) -> urwid.CompositeCanvas",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": null,
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "urwid.CompositeCanvas",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus=False) -> urwid.CompositeCanvas:\n    # Render the main frame\n    canvas = super().render(size, focus)\n    canvas = urwid.CompositeCanvas(canvas)\n    canvas.set_depends([self.edit, self.edit.popup])\n\n    if not self.edit.show_popup:\n        return canvas\n\n    # Get the number of entries in the popup\n    entries = len(self.edit.popup.body)\n    if entries == 0:\n        return canvas\n\n    # Size and position the popup above the cursor\n    # x, _ = self.edit.position_coords(size[0] - 20, self.edit.edit_pos)\n    if not self.get_cursor_coords(size):\n        return canvas\n    x, y = self.get_cursor_coords(size)\n    height = min(entries, 20, y)\n    width = max(len(s) for s in self.edit.suggestions) + 2\n\n    # Overlay the popup on the main frame\n    canvas.overlay(\n        self.edit.popup.render((width, height), focus=focus),\n        x,\n        y - height,\n    )\n\n    return canvas"
                }
              },
              "source": "class AutocompleteContainer(urwid.WidgetWrap):\n    \"\"\"\n    Custom container to hold the auto complete edit widget. Make sure the edit widget is\n    a part of the container (e.g. in the footer of a frame)\n\n    Args:\n        edit (AutocompleteEdit): The edit widget with autocomplete suggestions\n        container (urwid.Widget): The main container to be rendered\n    \"\"\"\n\n    def __init__(self, edit: AutocompleteEdit, container: urwid.Widget, *args, **kwargs):\n        self.edit = edit\n        self.container = container\n        super().__init__(self.container)\n\n    def render(self, size, focus=False) -> urwid.CompositeCanvas:\n        # Render the main frame\n        canvas = super().render(size, focus)\n        canvas = urwid.CompositeCanvas(canvas)\n        canvas.set_depends([self.edit, self.edit.popup])\n\n        if not self.edit.show_popup:\n            return canvas\n\n        # Get the number of entries in the popup\n        entries = len(self.edit.popup.body)\n        if entries == 0:\n            return canvas\n\n        # Size and position the popup above the cursor\n        # x, _ = self.edit.position_coords(size[0] - 20, self.edit.edit_pos)\n        if not self.get_cursor_coords(size):\n            return canvas\n        x, y = self.get_cursor_coords(size)\n        height = min(entries, 20, y)\n        width = max(len(s) for s in self.edit.suggestions) + 2\n\n        # Overlay the popup on the main frame\n        canvas.overlay(\n            self.edit.popup.render((width, height), focus=focus),\n            x,\n            y - height,\n        )\n\n        return canvas",
              "inherited_members": {}
            }
          },
          "functions": {
            "main": {
              "name": "main",
              "path": "bamboostcli.widgets.autocomplete_edit.main",
              "signature": "()",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def main():\n\n    Caller.main_loop = urwid.MainLoop(urwid.SolidFill(\" \"), palette)\n    suggestions = [\n        \"apple\",\n        \"banana\",\n        \"cherry\",\n        \"date\",\n        \"elderberry\",\n        \"fig\",\n        \"grape\",\n        \"apple pie\",\n        \"android\",\n    ]\n    edit = AutocompleteEdit(suggestions, \":\")\n    frame = AutocompleteContainer(edit, urwid.Filler(edit))\n    Caller.main_loop.widget = frame\n    Caller.main_loop.run()"
            }
          }
        },
        "command_line": {
          "name": "command_line",
          "path": "bamboostcli.widgets.command_line",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/widgets/command_line.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "CommandLine": {
              "name": "CommandLine",
              "path": "bamboostcli.widgets.command_line.CommandLine",
              "description": "Command line widget. Inherits from AutocompleteEdit and cEditHistory to\nenable completion and history.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "parser",
                  "annotation": "ArgumentParser",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The parser to use for the command line"
                    }
                  ]
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "caption",
                  "annotation": "str",
                  "description": null,
                  "value": "':'"
                },
                {
                  "name": "prefix",
                  "annotation": "str",
                  "description": null,
                  "value": "''"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "_selectable",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "signals",
                  "annotation": null,
                  "description": null,
                  "value": "['release_focus', 'execute_command']"
                },
                {
                  "name": "options",
                  "annotation": null,
                  "description": "some options for the command line",
                  "value": "{'caption': caption, 'prefix': prefix}"
                },
                {
                  "name": "parser",
                  "annotation": null,
                  "description": "The parser to use for the command line",
                  "value": "parser"
                },
                {
                  "name": "suggestions",
                  "annotation": "Iterable",
                  "description": "The current suggestions for the command line",
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.command_line.CommandLine.__init__",
                  "signature": "(self, parser, *args, *, caption=':', prefix='', **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parser",
                      "annotation": "ArgumentParser",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "caption",
                      "annotation": "str",
                      "description": null,
                      "value": "':'"
                    },
                    {
                      "name": "prefix",
                      "annotation": "str",
                      "description": null,
                      "value": "''"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(\n    self,\n    parser: ArgumentParser,\n    *args,\n    caption: str = \":\",\n    prefix: str = \"\",\n    **kwargs,\n):\n    self.options = {\"caption\": caption, \"prefix\": prefix}\n    self.parser = parser\n    # self.suggestions = self.parser.functions\n    self.suggestions = []\n    super().__init__(self.suggestions, caption, *args, **kwargs)"
                },
                "_reset": {
                  "name": "_reset",
                  "path": "bamboostcli.widgets.command_line.CommandLine._reset",
                  "signature": "(self) -> None",
                  "description": "Reset the command line",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _reset(self) -> None:\n    \"\"\"\n    Reset the command line\n    \"\"\"\n    self.parser._reset()\n    self.set_edit_text(self.options[\"prefix\"] + \"\")"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.command_line.CommandLine.keypress",
                  "signature": "(self, size, key)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size, key):\n    if key == \"enter\":\n        if self.edit_text == \"q\":\n            Caller.exit_widget()\n            return None\n\n        # Append the command to the history and emit the release_focus signal\n        self.history.append(self.edit_text)\n        urwid.emit_signal(self, \"execute_command\", self.edit_text)\n\n    elif key == \"esc\":\n        urwid.emit_signal(self, \"release_focus\")\n\n    # elif key == \"backspace\" and self.edit_text == \"\":\n    #     urwid.emit_signal(self, \"release_focus\")\n\n    elif key == \"tab\":  # accept the suggestion\n        if not self.show_popup:\n            return None\n        new_text = self.popup.get_focus()[0].base_widget.text.strip()\n        self.edit_text = \" \".join(re.split(r\"\\s+\", self.edit_text)[:-1] + [new_text]) + \" \"\n        self.edit_pos = len(self.edit_text)\n        self.suggestions = self.parser.current_suggestions(self.edit_text)\n\n    elif key == \"<0>\":  # Ctrl + Space to toggle popup\n        self.show_popup = not self.show_popup\n        if self.show_popup:\n            self.suggestions = self.parser.current_suggestions(self.edit_text)\n\n    elif key not in VERTICAL_KEYS | {\"<0>\"}:  # type letter and update suggestions\n        super().keypress(size, key)\n        self.suggestions = self.parser.current_suggestions(self.edit_text)\n    else:\n        super().keypress(size, key)"
                },
                "_update_popup": {
                  "name": "_update_popup",
                  "path": "bamboostcli.widgets.command_line.CommandLine._update_popup",
                  "signature": "(self, *args, **kwargs) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _update_popup(self, *args, **kwargs) -> None:\n    # Logic to update and display popup with suggestions\n    if not self.show_popup and self.edit_text != \"\":\n        self.show_popup = True\n    if not self.suggestions:\n        self.show_popup = False\n    self.popup.body = urwid.SimpleFocusListWalker(\n        [\n            urwid.AttrMap(urwid.Padding(urwid.Text(s), left=1), *self.ATTRS)\n            for s in self.suggestions\n        ]\n    )"
                }
              },
              "source": "class CommandLine(AutocompleteEdit, cEditHistory):\n    \"\"\"\n    Command line widget. Inherits from AutocompleteEdit and cEditHistory to\n    enable completion and history.\n\n    Args:\n        parser: The parser to use for the command line\n\n    Attributes:\n        options: some options for the command line\n        parser: The parser to use for the command line\n        suggestions: The current suggestions for the command line\n    \"\"\"\n\n    _selectable = True\n    signals = [\"release_focus\", \"execute_command\"]\n\n    def __init__(\n        self,\n        parser: ArgumentParser,\n        *args,\n        caption: str = \":\",\n        prefix: str = \"\",\n        **kwargs,\n    ):\n        self.options = {\"caption\": caption, \"prefix\": prefix}\n        self.parser = parser\n        # self.suggestions = self.parser.functions\n        self.suggestions = []\n        super().__init__(self.suggestions, caption, *args, **kwargs)\n\n    @property\n    def suggestions(self) -> Iterable[str]:\n        return self._suggestions\n\n    @suggestions.setter\n    def suggestions(self, suggestions: Iterable[str]) -> None:\n        self._suggestions = suggestions\n        try:\n            self._update_popup()\n        except AttributeError:\n            pass\n\n    def _reset(self) -> None:\n        \"\"\"\n        Reset the command line\n        \"\"\"\n        self.parser._reset()\n        self.set_edit_text(self.options[\"prefix\"] + \"\")\n\n    def keypress(self, size, key):\n        if key == \"enter\":\n            if self.edit_text == \"q\":\n                Caller.exit_widget()\n                return None\n\n            # Append the command to the history and emit the release_focus signal\n            self.history.append(self.edit_text)\n            urwid.emit_signal(self, \"execute_command\", self.edit_text)\n\n        elif key == \"esc\":\n            urwid.emit_signal(self, \"release_focus\")\n\n        # elif key == \"backspace\" and self.edit_text == \"\":\n        #     urwid.emit_signal(self, \"release_focus\")\n\n        elif key == \"tab\":  # accept the suggestion\n            if not self.show_popup:\n                return None\n            new_text = self.popup.get_focus()[0].base_widget.text.strip()\n            self.edit_text = \" \".join(re.split(r\"\\s+\", self.edit_text)[:-1] + [new_text]) + \" \"\n            self.edit_pos = len(self.edit_text)\n            self.suggestions = self.parser.current_suggestions(self.edit_text)\n\n        elif key == \"<0>\":  # Ctrl + Space to toggle popup\n            self.show_popup = not self.show_popup\n            if self.show_popup:\n                self.suggestions = self.parser.current_suggestions(self.edit_text)\n\n        elif key not in VERTICAL_KEYS | {\"<0>\"}:  # type letter and update suggestions\n            super().keypress(size, key)\n            self.suggestions = self.parser.current_suggestions(self.edit_text)\n        else:\n            super().keypress(size, key)\n\n    def _update_popup(self, *args, **kwargs) -> None:\n        # Logic to update and display popup with suggestions\n        if not self.show_popup and self.edit_text != \"\":\n            self.show_popup = True\n        if not self.suggestions:\n            self.show_popup = False\n        self.popup.body = urwid.SimpleFocusListWalker(\n            [\n                urwid.AttrMap(urwid.Padding(urwid.Text(s), left=1), *self.ATTRS)\n                for s in self.suggestions\n            ]\n        )",
              "inherited_members": {
                "bamboostcli.widgets.custom_widgets.cEditHistory": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cEditHistory.history"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cEditHistory.history_index"
                  }
                ],
                "bamboostcli.widgets.custom_widgets.cEdit": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cEdit.callback"
                  }
                ],
                "bamboostcli.widgets.autocomplete_edit.AutocompleteEdit": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteEdit.ATTRS"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteEdit.all_suggestions"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteEdit.popup"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteEdit.show_popup"
                  }
                ]
              }
            }
          },
          "functions": {}
        },
        "custom_widgets": {
          "name": "custom_widgets",
          "path": "bamboostcli.widgets.custom_widgets",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/widgets/custom_widgets.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "SELECT_CHARACTER",
              "annotation": null,
              "description": null,
              "value": "'\u276f'"
            }
          ],
          "modules": {},
          "classes": {
            "SelectionIcon": {
              "name": "SelectionIcon",
              "path": "bamboostcli.widgets.custom_widgets.SelectionIcon",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "icon",
                  "annotation": null,
                  "description": null,
                  "value": "SELECT_CHARACTER"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.custom_widgets.SelectionIcon.__init__",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self):\n    self.icon = SELECT_CHARACTER\n    super().__init__(self.icon, align=\"center\")"
                },
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.custom_widgets.SelectionIcon.render",
                  "signature": "(self, size, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": null,
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus=False):\n    if focus:\n        self.set_text((\"4\", self.icon))\n    else:\n        self.set_text(\" \")\n    return super().render(size, focus)"
                }
              },
              "source": "class SelectionIcon(urwid.Text):\n    def __init__(self):\n        self.icon = SELECT_CHARACTER\n        super().__init__(self.icon, align=\"center\")\n\n    def render(self, size, focus=False):\n        if focus:\n            self.set_text((\"4\", self.icon))\n        else:\n            self.set_text(\" \")\n        return super().render(size, focus)",
              "inherited_members": {}
            },
            "cListBox": {
              "name": "cListBox",
              "path": "bamboostcli.widgets.custom_widgets.cListBox",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "wrap",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "keymap_jk",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "_sizing",
                  "annotation": null,
                  "description": null,
                  "value": "frozenset(['box', 'flow'])"
                },
                {
                  "name": "wrap",
                  "annotation": null,
                  "description": null,
                  "value": "wrap"
                },
                {
                  "name": "keymap_jk",
                  "annotation": null,
                  "description": null,
                  "value": "keymap_jk"
                },
                {
                  "name": "keybinds",
                  "annotation": null,
                  "description": null,
                  "value": "Keybindings(self).new('down', 'j', cListBox._navigate_down, 'Move focus down', ['down', 'ctrl n']).new('up', 'k', cListBox._navigate_up, 'Move focus up', ['up', 'ctrl p']).new('start', ['g', 'g'], lambda self: self.set_focus(0), 'Move focus to the start').new('end', 'G', lambda self: self.set_focus(len(self.body) - 1), 'Move focus to the end')"
                },
                {
                  "name": "focused_text",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.custom_widgets.cListBox.__init__",
                  "signature": "(self, *args, *, wrap=False, keymap_jk=False, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "wrap",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    },
                    {
                      "name": "keymap_jk",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, *args, wrap: bool = False, keymap_jk: bool = False, **kwargs):\n    self.wrap = wrap\n    self.keymap_jk = keymap_jk\n    super().__init__(*args, **kwargs)\n\n    # fmt: off\n    self.keybinds = (\n        Keybindings(self)\n        .new(\"down\", \"j\", cListBox._navigate_down, \"Move focus down\", [\"down\", \"ctrl n\"])\n        .new(\"up\", \"k\", cListBox._navigate_up, \"Move focus up\", [\"up\", \"ctrl p\"])\n        .new(\"start\", [\"g\", \"g\"], lambda self: self.set_focus(0), \"Move focus to the start\")\n        .new(\"end\", \"G\", lambda self: self.set_focus(len(self.body) - 1), \"Move focus to the end\")\n    )\n    # fmt: on\n    self.keybinds.resolve_mapping()"
                },
                "_navigate_down": {
                  "name": "_navigate_down",
                  "path": "bamboostcli.widgets.custom_widgets.cListBox._navigate_down",
                  "signature": "(self, *args) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _navigate_down(self, *args) -> None:\n    try:\n        self.set_focus(self.focus_position + 1, \"above\")\n    except IndexError:\n        pass"
                },
                "_navigate_up": {
                  "name": "_navigate_up",
                  "path": "bamboostcli.widgets.custom_widgets.cListBox._navigate_up",
                  "signature": "(self, *args) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _navigate_up(self, *args) -> None:\n    try:\n        if self.focus_position > 0:\n            self.set_focus(self.focus_position - 1, \"below\")\n    except IndexError:\n        pass"
                },
                "rows": {
                  "name": "rows",
                  "path": "bamboostcli.widgets.custom_widgets.cListBox.rows",
                  "signature": "(self, size, focus)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def rows(self, size, focus):\n    return len(self.body)"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.custom_widgets.cListBox.keypress",
                  "signature": "(self, size, key) -> Union",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Union",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple, key: str) -> Union[str, None]:\n    from bamboostcli.keybinds import cKeybindsOverlay\n\n    if key == \"?\":\n        if not hasattr(self, \"_help_widget\"):\n            self._help_widget = cKeybindsOverlay(\n                Caller.main_loop, Caller.widget_stack[-1], self.keybinds\n            )\n        self._help_widget.toggle()\n        return\n\n    if key in self.keybinds.keys():\n        self.keybinds.call(size, key)\n        return\n\n    self.keybinds.reset_submap()\n    return super().keypress(size, key)"
                }
              },
              "source": "class cListBox(urwid.ListBox):\n    _sizing = frozenset([\"box\", \"flow\"])\n\n    def __init__(self, *args, wrap: bool = False, keymap_jk: bool = False, **kwargs):\n        self.wrap = wrap\n        self.keymap_jk = keymap_jk\n        super().__init__(*args, **kwargs)\n\n        # fmt: off\n        self.keybinds = (\n            Keybindings(self)\n            .new(\"down\", \"j\", cListBox._navigate_down, \"Move focus down\", [\"down\", \"ctrl n\"])\n            .new(\"up\", \"k\", cListBox._navigate_up, \"Move focus up\", [\"up\", \"ctrl p\"])\n            .new(\"start\", [\"g\", \"g\"], lambda self: self.set_focus(0), \"Move focus to the start\")\n            .new(\"end\", \"G\", lambda self: self.set_focus(len(self.body) - 1), \"Move focus to the end\")\n        )\n        # fmt: on\n        self.keybinds.resolve_mapping()\n\n    def _navigate_down(self, *args) -> None:\n        try:\n            self.set_focus(self.focus_position + 1, \"above\")\n        except IndexError:\n            pass\n\n    def _navigate_up(self, *args) -> None:\n        try:\n            if self.focus_position > 0:\n                self.set_focus(self.focus_position - 1, \"below\")\n        except IndexError:\n            pass\n\n    def rows(self, size, focus):\n        return len(self.body)\n\n    @property\n    def focused_text(self) -> str:\n        return self.get_focus()[0].base_widget.text\n\n    def keypress(self, size: tuple, key: str) -> Union[str, None]:\n        from bamboostcli.keybinds import cKeybindsOverlay\n\n        if key == \"?\":\n            if not hasattr(self, \"_help_widget\"):\n                self._help_widget = cKeybindsOverlay(\n                    Caller.main_loop, Caller.widget_stack[-1], self.keybinds\n                )\n            self._help_widget.toggle()\n            return\n\n        if key in self.keybinds.keys():\n            self.keybinds.call(size, key)\n            return\n\n        self.keybinds.reset_submap()\n        return super().keypress(size, key)",
              "inherited_members": {}
            },
            "cEdit": {
              "name": "cEdit",
              "path": "bamboostcli.widgets.custom_widgets.cEdit",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "callback",
                  "annotation": "callable",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "signals",
                  "annotation": null,
                  "description": null,
                  "value": "['release_focus', 'execute_command', 'set_footer']"
                },
                {
                  "name": "callback",
                  "annotation": null,
                  "description": null,
                  "value": "callback"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.custom_widgets.cEdit.__init__",
                  "signature": "(self, *args, *, callback=None, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "callback",
                      "annotation": "callable",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, *args, callback: callable = None, **kwargs):\n    self.callback = callback\n    super().__init__(*args, **kwargs)"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.custom_widgets.cEdit.keypress",
                  "signature": "(self, size, key) -> Union",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Union",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple, key: str) -> Union[str, None]:\n    if key == \"meta backspace\":\n        # Logic to delete the word before the cursor\n        new_pos = (\n            self.edit_text.rfind(\" \", 0, self.edit_pos - 1) + 1 if self.edit_pos > 0 else 0\n        )\n        new_text = self.edit_text[:new_pos] + self.edit_text[self.edit_pos :]\n        self.set_edit_text(new_text)\n        self.set_edit_pos(new_pos)\n    elif key == \"esc\":\n        Caller.exit_widget()\n    elif key == \"enter\":\n        if self.callback is not None:\n            self.callback(self.edit_text)\n            return\n        return super().keypress(size, key)\n\n    else:\n        return super().keypress(size, key)"
                }
              },
              "source": "class cEdit(urwid.Edit):\n    signals = [\"release_focus\", \"execute_command\", \"set_footer\"]\n\n    def __init__(self, *args, callback: callable = None, **kwargs):\n        self.callback = callback\n        super().__init__(*args, **kwargs)\n\n    def keypress(self, size: tuple, key: str) -> Union[str, None]:\n        if key == \"meta backspace\":\n            # Logic to delete the word before the cursor\n            new_pos = (\n                self.edit_text.rfind(\" \", 0, self.edit_pos - 1) + 1 if self.edit_pos > 0 else 0\n            )\n            new_text = self.edit_text[:new_pos] + self.edit_text[self.edit_pos :]\n            self.set_edit_text(new_text)\n            self.set_edit_pos(new_pos)\n        elif key == \"esc\":\n            Caller.exit_widget()\n        elif key == \"enter\":\n            if self.callback is not None:\n                self.callback(self.edit_text)\n                return\n            return super().keypress(size, key)\n\n        else:\n            return super().keypress(size, key)",
              "inherited_members": {}
            },
            "cEditHistory": {
              "name": "cEditHistory",
              "path": "bamboostcli.widgets.custom_widgets.cEditHistory",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "history",
                  "annotation": null,
                  "description": null,
                  "value": "['']"
                },
                {
                  "name": "history_index",
                  "annotation": "int",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.custom_widgets.cEditHistory.__init__",
                  "signature": "(self, *args, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, *args, **kwargs):\n    self.history = [\"\"]\n    self.history_index = 0\n    super().__init__(*args, **kwargs)"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.custom_widgets.cEditHistory.keypress",
                  "signature": "(self, size, key) -> str | None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str | None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple[int], key: str) -> str | None:\n    if key in {\"up\", \"ctrl p\"}:\n        # Move up the history\n        if self.history_index < len(self.history) - 1:\n            self.history_index += 1\n            text = self.history[-self.history_index]\n            self.set_edit_text(text)\n            self.set_edit_pos(len(text))\n    elif key in {\"down\", \"ctrl n\"}:\n        # Move down the history\n        self.history_index -= 1\n        text = self.history[-self.history_index]\n        self.set_edit_text(text)\n        self.set_edit_pos(len(text))\n    else:\n        return super().keypress(size, key)"
                }
              },
              "source": "class cEditHistory(urwid.Edit):\n    def __init__(self, *args, **kwargs):\n        self.history = [\"\"]\n        self.history_index = 0\n        super().__init__(*args, **kwargs)\n\n    @property\n    def history_index(self) -> int:\n        return self._history_index\n\n    @history_index.setter\n    def history_index(self, value: int) -> None:\n        if value < 0:\n            self._history_index = 0\n        elif value > len(self.history):\n            self._history_index = len(self.history)\n        else:\n            self._history_index = value\n\n    def keypress(self, size: tuple[int], key: str) -> str | None:\n        if key in {\"up\", \"ctrl p\"}:\n            # Move up the history\n            if self.history_index < len(self.history) - 1:\n                self.history_index += 1\n                text = self.history[-self.history_index]\n                self.set_edit_text(text)\n                self.set_edit_pos(len(text))\n        elif key in {\"down\", \"ctrl n\"}:\n            # Move down the history\n            self.history_index -= 1\n            text = self.history[-self.history_index]\n            self.set_edit_text(text)\n            self.set_edit_pos(len(text))\n        else:\n            return super().keypress(size, key)",
              "inherited_members": {}
            },
            "cConfirmDialog": {
              "name": "cConfirmDialog",
              "path": "bamboostcli.widgets.custom_widgets.cConfirmDialog",
              "description": "A dialog box for confirming an action.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "main_loop",
                  "annotation": "urwid.MainLoop",
                  "description": null,
                  "value": null
                },
                {
                  "name": "text",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "callback",
                  "annotation": "callable",
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "_selectable",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "main_loop",
                  "annotation": null,
                  "description": null,
                  "value": "main_loop"
                },
                {
                  "name": "bottom_w",
                  "annotation": null,
                  "description": null,
                  "value": "main_loop.widget"
                },
                {
                  "name": "text",
                  "annotation": null,
                  "description": null,
                  "value": "text"
                },
                {
                  "name": "callback",
                  "annotation": null,
                  "description": null,
                  "value": "callback"
                },
                {
                  "name": "yes_button",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Button('Yes', on_press=self.yes)"
                },
                {
                  "name": "no_button",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Button('No', on_press=self.no)"
                },
                {
                  "name": "buttons",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Columns([self.no_button, self.yes_button], dividechars=2)"
                },
                {
                  "name": "box",
                  "annotation": null,
                  "description": null,
                  "value": "cRoundedLineBox(urwid.Pile([urwid.Text(text), self.buttons]), focus_map='2', title='Confirmation')"
                },
                {
                  "name": "overlay",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Overlay(self.box, self.bottom_w, align='center', width='pack', valign='middle', height='pack')"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.custom_widgets.cConfirmDialog.__init__",
                  "signature": "(self, main_loop, text, callback, *args, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "main_loop",
                      "annotation": "urwid.MainLoop",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "text",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "callback",
                      "annotation": "callable",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, main_loop: urwid.MainLoop, text: str, callback: callable, *args, **kwargs):\n    self.main_loop = main_loop\n    self.bottom_w = main_loop.widget\n    self.text = text\n    self.callback = callback\n    self.yes_button = urwid.Button(\"Yes\", on_press=self.yes)\n    self.no_button = urwid.Button(\"No\", on_press=self.no)\n    self.buttons = urwid.Columns([self.no_button, self.yes_button], dividechars=2)\n    self.box = cRoundedLineBox(\n        urwid.Pile([urwid.Text(text), self.buttons]),\n        focus_map=\"2\",\n        title=\"Confirmation\",\n    )\n    self.overlay = urwid.Overlay(\n        self.box,\n        self.bottom_w,\n        align=\"center\",\n        width=\"pack\",\n        valign=\"middle\",\n        height=\"pack\",\n    )\n    super().__init__(self.overlay, *args, **kwargs)"
                },
                "yes": {
                  "name": "yes",
                  "path": "bamboostcli.widgets.custom_widgets.cConfirmDialog.yes",
                  "signature": "(self, button) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "button",
                      "annotation": "urwid.Button",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def yes(self, button: urwid.Button) -> None:\n    Caller.exit_widget()\n    self.callback()\n    return"
                },
                "no": {
                  "name": "no",
                  "path": "bamboostcli.widgets.custom_widgets.cConfirmDialog.no",
                  "signature": "(self, button) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "button",
                      "annotation": "urwid.Button",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def no(self, button: urwid.Button) -> None:\n    Caller.exit_widget()\n    return"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.custom_widgets.cConfirmDialog.keypress",
                  "signature": "(self, size, key) -> str | None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple[] | tuple[int] | tuple[int, int]",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str | None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple[()] | tuple[int] | tuple[int, int], key: str) -> str | None:\n    if key in (\"esc\", \"q\"):\n        # Set the widget of loop back to the original widget\n        Caller.exit_widget()\n        return\n    if key == \"l\":\n        return super().keypress(size, \"right\")\n    if key == \"h\":\n        return super().keypress(size, \"left\")\n\n    return super().keypress(size, key)"
                }
              },
              "source": "class cConfirmDialog(urwid.Frame):\n    \"\"\"A dialog box for confirming an action.\n\n    Args:\n        - main_loop (urwid.MainLoop): The main loop (Caller.main_loop)\n        - text (str): The text to display in the dialog box.\n        - callback (callable): The callback function to be called when the \"Yes\"\n          button is pressed.\n    \"\"\"\n\n    _selectable = True\n\n    def __init__(self, main_loop: urwid.MainLoop, text: str, callback: callable, *args, **kwargs):\n        self.main_loop = main_loop\n        self.bottom_w = main_loop.widget\n        self.text = text\n        self.callback = callback\n        self.yes_button = urwid.Button(\"Yes\", on_press=self.yes)\n        self.no_button = urwid.Button(\"No\", on_press=self.no)\n        self.buttons = urwid.Columns([self.no_button, self.yes_button], dividechars=2)\n        self.box = cRoundedLineBox(\n            urwid.Pile([urwid.Text(text), self.buttons]),\n            focus_map=\"2\",\n            title=\"Confirmation\",\n        )\n        self.overlay = urwid.Overlay(\n            self.box,\n            self.bottom_w,\n            align=\"center\",\n            width=\"pack\",\n            valign=\"middle\",\n            height=\"pack\",\n        )\n        super().__init__(self.overlay, *args, **kwargs)\n\n    def yes(self, button: urwid.Button) -> None:\n        Caller.exit_widget()\n        self.callback()\n        return\n\n    def no(self, button: urwid.Button) -> None:\n        Caller.exit_widget()\n        return\n\n    def keypress(self, size: tuple[()] | tuple[int] | tuple[int, int], key: str) -> str | None:\n        if key in (\"esc\", \"q\"):\n            # Set the widget of loop back to the original widget\n            Caller.exit_widget()\n            return\n        if key == \"l\":\n            return super().keypress(size, \"right\")\n        if key == \"h\":\n            return super().keypress(size, \"left\")\n\n        return super().keypress(size, key)",
              "inherited_members": {}
            },
            "cActionItem": {
              "name": "cActionItem",
              "path": "bamboostcli.widgets.custom_widgets.cActionItem",
              "description": "A custom widget class for action items in an Urwid application.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "content",
                  "annotation": "str | Iterable",
                  "description": null,
                  "value": null
                },
                {
                  "name": "callback",
                  "annotation": "callable",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "_sizing",
                  "annotation": null,
                  "description": null,
                  "value": "frozenset(['box'])"
                },
                {
                  "name": "_selectable",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "signals",
                  "annotation": null,
                  "description": null,
                  "value": "['set_footer']"
                },
                {
                  "name": "DIVIDECHARS",
                  "annotation": null,
                  "description": null,
                  "value": "2"
                },
                {
                  "name": "content",
                  "annotation": null,
                  "description": null,
                  "value": "[content] if isinstance(content, str) else content"
                },
                {
                  "name": "_callback",
                  "annotation": null,
                  "description": null,
                  "value": "callback"
                },
                {
                  "name": "column_widths",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                },
                {
                  "name": "column_attr_map",
                  "annotation": null,
                  "description": null,
                  "value": "{None: 'default'}"
                },
                {
                  "name": "column_focus_map",
                  "annotation": null,
                  "description": null,
                  "value": "{None: 'bold'}"
                },
                {
                  "name": "widget",
                  "annotation": "urwid.Columns",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.custom_widgets.cActionItem.__init__",
                  "signature": "(self, content, callback=None) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "content",
                      "annotation": "str | Iterable",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "callback",
                      "annotation": "callable",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, content: str | Iterable, callback: callable = None) -> None:\n    self.content = [content] if isinstance(content, str) else content\n    self._callback = callback\n    self.column_widths = {}\n    self.column_attr_map = {None: \"default\"}\n    self.column_focus_map = {None: \"bold\"}\n\n    self._invalidate()\n    super().__init__()"
                },
                "_invalidate": {
                  "name": "_invalidate",
                  "path": "bamboostcli.widgets.custom_widgets.cActionItem._invalidate",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _invalidate(self):\n    self.widget = urwid.AttrMap(\n        urwid.Columns(\n            [(\"fixed\", 1, SelectionIcon())]\n            + [self._render_column(i, text) for i, text in enumerate(self.content)],\n            dividechars=self.DIVIDECHARS,\n        ),\n        self.column_attr_map,\n        self.column_focus_map,\n    )\n    return super()._invalidate()"
                },
                "rows": {
                  "name": "rows",
                  "path": "bamboostcli.widgets.custom_widgets.cActionItem.rows",
                  "signature": "(self, size, focus)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def rows(self, size, focus):\n    return self.widget.rows(size, focus)"
                },
                "callback": {
                  "name": "callback",
                  "path": "bamboostcli.widgets.custom_widgets.cActionItem.callback",
                  "signature": "(self) -> Callable",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Callable",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def callback(self) -> Callable:\n    return self._callback(self) or (lambda *args: None)"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.custom_widgets.cActionItem.keypress",
                  "signature": "(self, size, key)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size, key):\n    if key == \"enter\":\n        self.callback()\n        return\n    return key"
                },
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.custom_widgets.cActionItem.render",
                  "signature": "(self, size, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": null,
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus=False):\n    # Before render, the rows() method is called by urwid!\n    # Therefore, we don't need to update the widget here again but only in rows()\n    return self.widget.render(size, focus)"
                },
                "_render_column": {
                  "name": "_render_column",
                  "path": "bamboostcli.widgets.custom_widgets.cActionItem._render_column",
                  "signature": "(self, i, text, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "i",
                      "annotation": "int",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "text",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _render_column(self, i: int, text: str, focus: bool = False):\n    sizing = urwid.WEIGHT\n    if hasattr(self, \"_column_sizing\") and self._column_sizing:\n        sizing = self._column_sizing[i]\n\n    align = urwid.LEFT\n    if hasattr(self, \"_column_align\") and self._column_align:\n        align = self._column_align[i]\n\n    if self.column_widths and (i == 0 or sizing == urwid.FIXED):\n        return (\n            \"fixed\",\n            self.column_widths[i],\n            urwid.AttrMap(urwid.Text(text, align=align), i),\n        )\n\n    if sizing == urwid.PACK:\n        return (sizing, urwid.AttrMap(urwid.Text(text, align=align), i))\n\n    return (\n        \"weight\",\n        1,\n        urwid.AttrMap(urwid.Text(text, align=align, wrap=\"clip\"), i),\n    )"
                }
              },
              "source": "class cActionItem(urwid.Widget):\n    \"\"\"A custom widget class for action items in an Urwid application.\n\n    Args:\n        - content (str | Iterable): The content to be displayed in the widget.\n          Can be a list of strings.\n        - callback (callable, optional): The callback function to be called\n          when the widget is activated. The callback function takes the widget\n          as an argument.\n    \"\"\"\n\n    _sizing = frozenset([\"box\"])\n    _selectable = True\n    signals = [\"set_footer\"]\n\n    DIVIDECHARS = 2\n\n    def __init__(self, content: str | Iterable, callback: callable = None) -> None:\n        self.content = [content] if isinstance(content, str) else content\n        self._callback = callback\n        self.column_widths = {}\n        self.column_attr_map = {None: \"default\"}\n        self.column_focus_map = {None: \"bold\"}\n\n        self._invalidate()\n        super().__init__()\n\n    def _invalidate(self):\n        self.widget = urwid.AttrMap(\n            urwid.Columns(\n                [(\"fixed\", 1, SelectionIcon())]\n                + [self._render_column(i, text) for i, text in enumerate(self.content)],\n                dividechars=self.DIVIDECHARS,\n            ),\n            self.column_attr_map,\n            self.column_focus_map,\n        )\n        return super()._invalidate()\n\n    def rows(self, size, focus):\n        return self.widget.rows(size, focus)\n\n    def callback(self) -> Callable:\n        return self._callback(self) or (lambda *args: None)\n\n    def keypress(self, size, key):\n        if key == \"enter\":\n            self.callback()\n            return\n        return key\n\n    @property\n    def widget(self) -> urwid.Columns:\n        return self._widget\n\n    @widget.setter\n    def widget(self, value: urwid.Columns) -> None:\n        self._widget = value\n\n    def render(self, size, focus=False):\n        # Before render, the rows() method is called by urwid!\n        # Therefore, we don't need to update the widget here again but only in rows()\n        return self.widget.render(size, focus)\n\n    def _render_column(self, i: int, text: str, focus: bool = False):\n        sizing = urwid.WEIGHT\n        if hasattr(self, \"_column_sizing\") and self._column_sizing:\n            sizing = self._column_sizing[i]\n\n        align = urwid.LEFT\n        if hasattr(self, \"_column_align\") and self._column_align:\n            align = self._column_align[i]\n\n        if self.column_widths and (i == 0 or sizing == urwid.FIXED):\n            return (\n                \"fixed\",\n                self.column_widths[i],\n                urwid.AttrMap(urwid.Text(text, align=align), i),\n            )\n\n        if sizing == urwid.PACK:\n            return (sizing, urwid.AttrMap(urwid.Text(text, align=align), i))\n\n        return (\n            \"weight\",\n            1,\n            urwid.AttrMap(urwid.Text(text, align=align, wrap=\"clip\"), i),\n        )",
              "inherited_members": {}
            },
            "cListBoxSelectionCharacter": {
              "name": "cListBoxSelectionCharacter",
              "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter",
              "description": "A custom list box widget for selecting from a list of items with a focus\ncharacter.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "items",
                  "annotation": "List",
                  "description": null,
                  "value": null
                },
                {
                  "name": "attr_map",
                  "annotation": "dict",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "focus_map",
                  "annotation": "dict",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "always_in_focus",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "headers",
                  "annotation": "List",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "_column_widths",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                },
                {
                  "name": "_headers",
                  "annotation": null,
                  "description": null,
                  "value": "headers"
                },
                {
                  "name": "_column_sizing",
                  "annotation": null,
                  "description": null,
                  "value": "kwargs.pop('column_sizing', None)"
                },
                {
                  "name": "_column_align",
                  "annotation": null,
                  "description": null,
                  "value": "kwargs.pop('column_align', None)"
                },
                {
                  "name": "_items",
                  "annotation": null,
                  "description": null,
                  "value": "items"
                },
                {
                  "name": "_always_in_focus",
                  "annotation": null,
                  "description": null,
                  "value": "always_in_focus"
                },
                {
                  "name": "_listwalker",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.SimpleFocusListWalker(self.items)"
                },
                {
                  "name": "items",
                  "annotation": "List",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "kwargs",
                    "description": "- column_sizing (List[str]): A list of strings specifying the sizing\n  of the columns. Defaults to None.\n- column_align (List[str]): A list of strings specifying the alignment\n  of the columns. Defaults to None."
                  },
                  "title": "Kwargs"
                }
              ],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter.__init__",
                  "signature": "(self, items, attr_map=None, focus_map=None, always_in_focus=False, headers=None, *args, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "items",
                      "annotation": "List",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "attr_map",
                      "annotation": "dict",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "focus_map",
                      "annotation": "dict",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "always_in_focus",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    },
                    {
                      "name": "headers",
                      "annotation": "List",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(\n    self,\n    items: List[cActionItem],\n    attr_map: dict = None,\n    focus_map: dict = None,\n    always_in_focus: bool = False,\n    headers: List[str] = None,\n    *args,\n    **kwargs,\n):\n    # get the length of the longest key per column\n    self._column_widths = {}\n    for item in items:\n        if isinstance(item.content, str):\n            item.content = [item.content]\n        for i, content in enumerate(item.content):\n            self._column_widths[i] = max(self._column_widths.get(i, 0), len(str(content)))\n    if headers:\n        self._headers = headers\n        for i, header in enumerate(headers):\n            self._column_widths[i] = max(self._column_widths.get(i, 0), len(header))\n\n    # get column sizing if specified\n    self._column_sizing = kwargs.pop(\"column_sizing\", None)\n    # get column alignment if specified\n    self._column_align = kwargs.pop(\"column_align\", None)\n\n    for item in items:\n        item.column_widths = self._column_widths\n        if attr_map:\n            item.column_attr_map = attr_map\n        if focus_map:\n            item.column_focus_map = focus_map\n        item._column_sizing = self._column_sizing\n        item._column_align = self._column_align\n        item._invalidate()\n\n    self._items = items\n    self._always_in_focus = always_in_focus\n    self._listwalker = urwid.SimpleFocusListWalker(self.items)\n    super().__init__(self._listwalker, *args, **kwargs, keymap_jk=True)"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter.keypress",
                  "signature": "(self, size, key) -> Union",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Union",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple[int], key: str) -> Union[str, None]:\n    return super().keypress(size, key)"
                },
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter.render",
                  "signature": "(self, size, focus) -> Tuple",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": "bool",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Tuple",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size: tuple[int], focus: bool) -> Tuple[int, int]:\n    if self._always_in_focus:\n        focus = True\n    return super().render(size, focus)"
                }
              },
              "source": "class cListBoxSelectionCharacter(cListBox):\n    \"\"\"A custom list box widget for selecting from a list of items with a focus\n    character.\n\n    Args:\n        - items (List[cActionItem]): A list of cActionItem objects representing\n          the items in the list box.\n        - attr_map (List[Tuple[str]]): A list of tuples specifying the\n          attribute mappings for columns. Defaults to None.\n        - always_in_focus (bool): Whether the list box should always be in\n          focus. Defaults to False.\n        - headers (List[str]): A list of strings specifying the headers for the\n          columns to calculate the column widths. Defaults to None.\n\n    Kwargs:\n        - column_sizing (List[str]): A list of strings specifying the sizing\n          of the columns. Defaults to None.\n        - column_align (List[str]): A list of strings specifying the alignment\n          of the columns. Defaults to None.\n\n    Attributes:\n        - _column_widths (Dict[int, int]): A dictionary mapping column index to\n          the width of the longest content in that column. items\n          (List[cActionItem]): A list of cActionItem objects representing the\n          items in the list box.\n        - _listwalker (urwid.SimpleFocusListWalker): A SimpleFocusListWalker\n          object for navigating the list items.\n    \"\"\"\n\n    def __init__(\n        self,\n        items: List[cActionItem],\n        attr_map: dict = None,\n        focus_map: dict = None,\n        always_in_focus: bool = False,\n        headers: List[str] = None,\n        *args,\n        **kwargs,\n    ):\n        # get the length of the longest key per column\n        self._column_widths = {}\n        for item in items:\n            if isinstance(item.content, str):\n                item.content = [item.content]\n            for i, content in enumerate(item.content):\n                self._column_widths[i] = max(self._column_widths.get(i, 0), len(str(content)))\n        if headers:\n            self._headers = headers\n            for i, header in enumerate(headers):\n                self._column_widths[i] = max(self._column_widths.get(i, 0), len(header))\n\n        # get column sizing if specified\n        self._column_sizing = kwargs.pop(\"column_sizing\", None)\n        # get column alignment if specified\n        self._column_align = kwargs.pop(\"column_align\", None)\n\n        for item in items:\n            item.column_widths = self._column_widths\n            if attr_map:\n                item.column_attr_map = attr_map\n            if focus_map:\n                item.column_focus_map = focus_map\n            item._column_sizing = self._column_sizing\n            item._column_align = self._column_align\n            item._invalidate()\n\n        self._items = items\n        self._always_in_focus = always_in_focus\n        self._listwalker = urwid.SimpleFocusListWalker(self.items)\n        super().__init__(self._listwalker, *args, **kwargs, keymap_jk=True)\n\n    @property\n    def items(self) -> List[cActionItem]:\n        return self._items\n\n    @items.setter\n    def items(self, value: List[cActionItem]) -> None:\n        self._items = value\n        self.body[:] = value\n\n    def keypress(self, size: tuple[int], key: str) -> Union[str, None]:\n        return super().keypress(size, key)\n\n    def render(self, size: tuple[int], focus: bool) -> Tuple[int, int]:\n        if self._always_in_focus:\n            focus = True\n        return super().render(size, focus)",
              "inherited_members": {
                "bamboostcli.widgets.custom_widgets.cListBox": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox._sizing"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.wrap"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.keymap_jk"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.keybinds"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox._navigate_down"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox._navigate_up"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.rows"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.focused_text"
                  }
                ]
              }
            },
            "cPopup": {
              "name": "cPopup",
              "path": "bamboostcli.widgets.custom_widgets.cPopup",
              "description": "A custom Popup widget with a title, frame and footer.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "widget",
                  "annotation": "urwid.Widget",
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "_widget",
                  "annotation": null,
                  "description": null,
                  "value": "widget"
                },
                {
                  "name": "_frame",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Frame(urwid.Padding(widget, left=1, right=1), footer=urwid.Pile([urwid.Divider('\u2500'), urwid.Padding(urwid.Text(('2', kwargs.pop('footer'))), left=1, right=1)]), focus_part='body')"
                }
              ],
              "docstring": [
                {
                  "kind": "other parameters",
                  "value": [
                    {
                      "name": "-",
                      "annotation": "height (int",
                      "description": "The height of the popup."
                    },
                    {
                      "name": "-",
                      "annotation": "footer (str",
                      "description": "The text to display in the footer."
                    },
                    {
                      "name": "-",
                      "annotation": "align (str",
                      "description": "The alignment of the popup."
                    },
                    {
                      "name": "-",
                      "annotation": "width (tuple[str, int]",
                      "description": "The width of the popup."
                    },
                    {
                      "name": "-",
                      "annotation": "valign (str",
                      "description": "The vertical alignment of the popup."
                    },
                    {
                      "name": "-",
                      "annotation": "min_height (int",
                      "description": "The minimum height of the popup."
                    },
                    {
                      "name": "-",
                      "annotation": "title (str",
                      "description": "The title of the popup."
                    },
                    {
                      "name": "-",
                      "annotation": "title_align (str",
                      "description": "The alignment of the title."
                    },
                    {
                      "name": "-",
                      "annotation": "focus_map (str",
                      "description": "The focus map for the popup."
                    }
                  ]
                }
              ],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.custom_widgets.cPopup.__init__",
                  "signature": "(self, widget, *args, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "widget",
                      "annotation": "urwid.Widget",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, widget: urwid.Widget, *args, **kwargs):\n    if \"height\" in kwargs:\n        if isinstance(kwargs[\"height\"], int):\n            kwargs[\"height\"] += 4\n\n    kwargs.setdefault(\"footer\", \"Enter: Open | Esc: Close\")\n    kwargs.setdefault(\"align\", \"center\")\n    kwargs.setdefault(\"width\", (\"relative\", 80))\n    kwargs.setdefault(\"valign\", \"middle\")\n    kwargs.setdefault(\"height\", (\"relative\", 50))\n    kwargs.setdefault(\"min_height\", 5)\n    kwargs.setdefault(\"title\", \"\")\n    kwargs.setdefault(\"title_align\", \"left\")\n    kwargs.setdefault(\"focus_map\", \"8\")\n\n    self._widget = widget\n    self._frame = urwid.Frame(\n        urwid.Padding(widget, left=1, right=1),\n        footer=urwid.Pile(\n            [\n                urwid.Divider(\"\\u2500\"),\n                urwid.Padding(urwid.Text((\"2\", kwargs.pop(\"footer\"))), left=1, right=1),\n            ]\n        ),\n        focus_part=\"body\",\n    )\n\n    box = cRoundedLineBox(\n        self._frame,\n        title=kwargs.pop(\"title\"),\n        title_align=kwargs.pop(\"title_align\"),\n        focus_map=kwargs.pop(\"focus_map\"),\n    )\n\n    base_widget = Caller.main_loop.widget if Caller.main_loop else urwid.SolidFill(\" \")\n\n    super().__init__(box, base_widget, *args, **kwargs)"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.custom_widgets.cPopup.keypress",
                  "signature": "(self, size, key) -> str | None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str | None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n    return super().keypress((1,), key)"
                }
              },
              "source": "class cPopup(urwid.Overlay):\n    \"\"\"A custom Popup widget with a title, frame and footer.\n\n    Args:\n        - widget (urwid.Widget): The main widget to display in the popup.\n        - *args: Additional positional arguments.\n        - **kwargs: Additional keyword arguments.\n\n    Keyword Arguments:\n        - height (int): The height of the popup.\n        - footer (str): The text to display in the footer.\n        - align (str): The alignment of the popup.\n        - width (tuple[str, int]): The width of the popup.\n        - valign (str): The vertical alignment of the popup.\n        - min_height (int): The minimum height of the popup.\n        - title (str): The title of the popup.\n        - title_align (str): The alignment of the title.\n        - focus_map (str): The focus map for the popup.\n    \"\"\"\n\n    def __init__(self, widget: urwid.Widget, *args, **kwargs):\n        if \"height\" in kwargs:\n            if isinstance(kwargs[\"height\"], int):\n                kwargs[\"height\"] += 4\n\n        kwargs.setdefault(\"footer\", \"Enter: Open | Esc: Close\")\n        kwargs.setdefault(\"align\", \"center\")\n        kwargs.setdefault(\"width\", (\"relative\", 80))\n        kwargs.setdefault(\"valign\", \"middle\")\n        kwargs.setdefault(\"height\", (\"relative\", 50))\n        kwargs.setdefault(\"min_height\", 5)\n        kwargs.setdefault(\"title\", \"\")\n        kwargs.setdefault(\"title_align\", \"left\")\n        kwargs.setdefault(\"focus_map\", \"8\")\n\n        self._widget = widget\n        self._frame = urwid.Frame(\n            urwid.Padding(widget, left=1, right=1),\n            footer=urwid.Pile(\n                [\n                    urwid.Divider(\"\\u2500\"),\n                    urwid.Padding(urwid.Text((\"2\", kwargs.pop(\"footer\"))), left=1, right=1),\n                ]\n            ),\n            focus_part=\"body\",\n        )\n\n        box = cRoundedLineBox(\n            self._frame,\n            title=kwargs.pop(\"title\"),\n            title_align=kwargs.pop(\"title_align\"),\n            focus_map=kwargs.pop(\"focus_map\"),\n        )\n\n        base_widget = Caller.main_loop.widget if Caller.main_loop else urwid.SolidFill(\" \")\n\n        super().__init__(box, base_widget, *args, **kwargs)\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        return super().keypress((1,), key)",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "index": {
          "name": "index",
          "path": "bamboostcli.widgets.index",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/widgets/index.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "Index": {
              "name": "Index",
              "path": "bamboostcli.widgets.index.Index",
              "description": "Index widget for displaying a list of known databases.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "data",
                  "annotation": "dict",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "signals",
                  "annotation": null,
                  "description": null,
                  "value": "['set_footer']"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.index.Index.__init__",
                  "signature": "(self, data) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, data: dict) -> None:\n    self._initialize(data)\n    super().__init__(\n        urwid.Padding(self.table, left=2, right=2),\n        urwid.Padding(self.header, left=2, right=2),\n        self.footer,\n        focus_part=\"footer\",\n    )"
                },
                "_initialize": {
                  "name": "_initialize",
                  "path": "bamboostcli.widgets.index.Index._initialize",
                  "signature": "(self, data) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _initialize(self, data: dict) -> None:\n    # Get the last modified time of each databasse\n    mtime = {key: os.path.getmtime(path) for key, path in data.items()}\n\n    self.data = {}\n    self.data = self._process_data(data, mtime)\n\n    def bold_text(text, *args, **kwargs):\n        return urwid.AttrWrap(urwid.Text(text, *args, **kwargs), \"bold\")\n\n    self.table = cListBoxSelectionCharacter(\n        [self._create_item(key) for key in self.data],\n        {0: \"5\", 1: \"default\", 2: \"6\", 3: \"default\", 4: \"3\"},\n        {0: \"5-bold\", 1: \"bold\", 2: \"6-bold\", 3: \"bold\", 4: \"3-bold\"},\n        always_in_focus=True,\n        column_sizing=[urwid.FIXED, urwid.FIXED, urwid.FIXED, urwid.WEIGHT, urwid.FIXED],\n        column_align=[urwid.LEFT, urwid.RIGHT, urwid.RIGHT, urwid.RIGHT, urwid.RIGHT],\n        headers=[\"UID\", \"Entries\", \"Size\", \"Path\", \"Last Modified\"],\n    )\n    self.headers = urwid.Columns(\n        [(\"fixed\", 1, urwid.Text(\" \"))]\n        + [\n            (sizing, width, bold_text(text, align=align))\n            for sizing, width, text, align in zip(\n                self.table._column_sizing,\n                self.table._column_widths.values(),\n                self.table._headers,\n                self.table._column_align,\n            )\n        ],\n        dividechars=self.table.items[0].DIVIDECHARS,\n    )\n    self.header = urwid.Pile([urwid.Divider(), self.headers, urwid.Divider()])\n    self.footer = urwid.Filler(\n        urwid.Padding(cEdit(\"Search: \", \"\", align=\"left\"), left=3), top=1, bottom=1\n    )\n    urwid.connect_signal(self.footer.base_widget, \"change\", self.on_search_change)\n\n    # Load the sizes of the databases in a separate thread to decrease loading time\n    def get_sizes():\n        for key in data:\n            self.data[key][\"size\"] = (\n                subprocess.check_output([\"du\", \"-sh\", data[key]]).split()[0].decode(\"utf-8\")\n            )\n        for item in self.table.body:\n            item.content[2] = str(self.data[item.content[0]][\"size\"])\n            item._invalidate()\n        Caller.main_loop.draw_screen()\n\n    threading.Thread(target=get_sizes).start()"
                },
                "_process_data": {
                  "name": "_process_data",
                  "path": "bamboostcli.widgets.index.Index._process_data",
                  "signature": "(self, data, mtime) -> dict",
                  "description": "Process the given data and mtime dictionaries to create a new\ndictionary with additional information.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "mtime",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "dict",
                    "description": "- dict: A new dictionary with keys from mtime sorted in descending\norder of modification time. Each key in the new dictionary\ncontains a sub-dictionary with the following keys:\n- \"path\": The original path from the data dictionary.\n- \"mtime\": The modification time from the mtime dictionary.\n- \"entries\": The number of subdirectories in the path.\n- \"size\": The size of the path in a human-readable format."
                  },
                  "docstring": [
                    {
                      "kind": "raises",
                      "value": [
                        {
                          "annotation": "-subprocess.CalledProcessError",
                          "description": "If an error occurs while running\nthe 'du' command to get the size of the path."
                        }
                      ]
                    }
                  ],
                  "source": "def _process_data(self, data: dict, mtime: dict) -> dict:\n    \"\"\"\n    Process the given data and mtime dictionaries to create a new\n    dictionary with additional information.\n\n    Parameters:\n        - data (dict): A dictionary containing keys as paths and values as\n          corresponding data.\n        - mtime (dict): A dictionary containing keys as paths and values as\n          corresponding modification times.\n\n    Returns:\n        - dict: A new dictionary with keys from mtime sorted in descending\n          order of modification time. Each key in the new dictionary\n          contains a sub-dictionary with the following keys:\n            - \"path\": The original path from the data dictionary.\n            - \"mtime\": The modification time from the mtime dictionary.\n            - \"entries\": The number of subdirectories in the path.\n            - \"size\": The size of the path in a human-readable format.\n\n    Raises:\n        - subprocess.CalledProcessError: If an error occurs while running\n          the 'du' command to get the size of the path.\n    \"\"\"\n    new_data = {\n        key: {\n            \"path\": data[key],\n            \"mtime\": mtime[key],\n            \"entries\": len(\n                [i for i in os.listdir(data[key]) if os.path.isdir(os.path.join(data[key], i))]\n            ),\n            \"size\": \"...\",\n        }\n        for key in sorted(mtime, key=mtime.get, reverse=True)\n    }\n    return new_data"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.index.Index.keypress",
                  "signature": "(self, size, key) -> str | None",
                  "description": "Process keypress events for the current widget.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The size of the widget."
                        }
                      ]
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The key that was pressed."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str | None",
                    "description": "str | None: The result of processing the keypress event."
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n    \"\"\"Process keypress events for the current widget.\n\n    Args:\n        size (tuple[int, int]): The size of the widget.\n        key (str): The key that was pressed.\n\n    Returns:\n        str | None: The result of processing the keypress event.\n    \"\"\"\n    if key in (\"ctrl n\", \"ctrl p\", \"up\", \"down\"):\n        return self.table.keypress(size, key)\n    if key == \"enter\":\n        # check if something is selected\n        if not self.table.focus:\n            return\n        # get UID of the selected action item\n        item = self.table.focus.base_widget.content[0]\n\n        def load_data():\n            with Spinner(caption=f\"[ID: {item}] Reading data \") as spinner:\n                loading_widget = urwid.Overlay(\n                    cRoundedLineBox(spinner, focus_map=\"default\"),\n                    Caller.main_loop.widget,\n                    \"center\",\n                    (\"relative\", 50),\n                    \"middle\",\n                    (\"pack\"),\n                )\n                Caller.enter_widget(loading_widget)\n\n                # Create databaase widget\n                database = Database(item, bamboost.Manager(uid=item))\n                # Exit the loading widget\n                Caller.exit_widget()\n\n            Caller.enter_widget(database)\n\n        threading.Thread(target=load_data).start()\n\n        return\n    return super().keypress(size, key)"
                },
                "on_search_change": {
                  "name": "on_search_change",
                  "path": "bamboostcli.widgets.index.Index.on_search_change",
                  "signature": "(self, edit, new_edit_text)",
                  "description": "Updates the table body based on a fuzzy search of the new edit\ntext.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "edit",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "new_edit_text",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": "- None"
                  },
                  "docstring": [],
                  "source": "def on_search_change(self, edit, new_edit_text):\n    \"\"\"Updates the table body based on a fuzzy search of the new edit\n    text.\n\n    Arguments:\n        - edit (str): The current edit text in the search bar.\n        - new_edit_text (str): The new edit text entered by the user.\n\n    Returns:\n        - None\n    \"\"\"\n    filtered = self.fuzzy_search(new_edit_text)\n    self.table.body[:] = filtered\n    if filtered:\n        self.table.focus_position = 0"
                },
                "fuzzy_search": {
                  "name": "fuzzy_search",
                  "path": "bamboostcli.widgets.index.Index.fuzzy_search",
                  "signature": "(self, query)",
                  "description": "Perform a fuzzy search on the data based on the given query.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "query",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": "- list: A list of items that match the fuzzy search criteria."
                  },
                  "docstring": [
                    {
                      "kind": "text",
                      "value": "This method takes a query string and performs a fuzzy search on the\ndata stored in the object. If the query string is empty, it will return\nall items in the data. Otherwise, it will return items that have a\npartial ratio match of greater than 70 with the query string."
                    }
                  ],
                  "source": "def fuzzy_search(self, query):\n    \"\"\"Perform a fuzzy search on the data based on the given query.\n\n    Args:\n        - query (str): The query string to search for.\n\n    Returns:\n        - list: A list of items that match the fuzzy search criteria.\n\n    Raises:\n        - None\n\n    This method takes a query string and performs a fuzzy search on the\n    data stored in the object. If the query string is empty, it will return\n    all items in the data. Otherwise, it will return items that have a\n    partial ratio match of greater than 70 with the query string.\n    \"\"\"\n    # item: list[uid, entries, size, path, mtime]\n    if query == \"\":\n        return [item for item in self.table.items]\n\n    res = [item for item in self.table.items if fuzz.partial_ratio(item.content[3], query) > 70]\n    return res"
                },
                "_create_item": {
                  "name": "_create_item",
                  "path": "bamboostcli.widgets.index.Index._create_item",
                  "signature": "(self, uid) -> list",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "list",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _create_item(self, uid) -> list:\n    item = [\n        uid,\n        self.data[uid][\"entries\"],\n        self.data[uid][\"size\"],\n        self.data[uid][\"path\"],\n        datetime.fromtimestamp(self.data[uid][\"mtime\"]).strftime(\"%Y-%m-%d %H:%M:%S\"),\n    ]\n    return cActionItem([str(i) for i in item])"
                }
              },
              "source": "class Index(urwid.Frame):\n    \"\"\"Index widget for displaying a list of known databases.\n\n    Arguments:\n        - data (dict): A dictionary containing keys as unique identifiers and\n          values as corresponding paths.\n\n    Attributes:\n        - data (dict): A dictionary containing keys as unique identifiers and\n          values as corresponding paths.\n        - headers (urwid.Columns): A widget containing the headers for the\n          table.\n        - table (CustomListBox): A list box widget containing the data.\n        - header (urwid.Pile): A pile widget for the headers with spacing.\n        - footer (urwid.Filler): A filler widget containing the search bar.\n    \"\"\"\n\n    signals = [\"set_footer\"]\n\n    def __init__(self, data: dict) -> None:\n        self._initialize(data)\n        super().__init__(\n            urwid.Padding(self.table, left=2, right=2),\n            urwid.Padding(self.header, left=2, right=2),\n            self.footer,\n            focus_part=\"footer\",\n        )\n\n    def _initialize(self, data: dict) -> None:\n        # Get the last modified time of each databasse\n        mtime = {key: os.path.getmtime(path) for key, path in data.items()}\n\n        self.data = {}\n        self.data = self._process_data(data, mtime)\n\n        def bold_text(text, *args, **kwargs):\n            return urwid.AttrWrap(urwid.Text(text, *args, **kwargs), \"bold\")\n\n        self.table = cListBoxSelectionCharacter(\n            [self._create_item(key) for key in self.data],\n            {0: \"5\", 1: \"default\", 2: \"6\", 3: \"default\", 4: \"3\"},\n            {0: \"5-bold\", 1: \"bold\", 2: \"6-bold\", 3: \"bold\", 4: \"3-bold\"},\n            always_in_focus=True,\n            column_sizing=[urwid.FIXED, urwid.FIXED, urwid.FIXED, urwid.WEIGHT, urwid.FIXED],\n            column_align=[urwid.LEFT, urwid.RIGHT, urwid.RIGHT, urwid.RIGHT, urwid.RIGHT],\n            headers=[\"UID\", \"Entries\", \"Size\", \"Path\", \"Last Modified\"],\n        )\n        self.headers = urwid.Columns(\n            [(\"fixed\", 1, urwid.Text(\" \"))]\n            + [\n                (sizing, width, bold_text(text, align=align))\n                for sizing, width, text, align in zip(\n                    self.table._column_sizing,\n                    self.table._column_widths.values(),\n                    self.table._headers,\n                    self.table._column_align,\n                )\n            ],\n            dividechars=self.table.items[0].DIVIDECHARS,\n        )\n        self.header = urwid.Pile([urwid.Divider(), self.headers, urwid.Divider()])\n        self.footer = urwid.Filler(\n            urwid.Padding(cEdit(\"Search: \", \"\", align=\"left\"), left=3), top=1, bottom=1\n        )\n        urwid.connect_signal(self.footer.base_widget, \"change\", self.on_search_change)\n\n        # Load the sizes of the databases in a separate thread to decrease loading time\n        def get_sizes():\n            for key in data:\n                self.data[key][\"size\"] = (\n                    subprocess.check_output([\"du\", \"-sh\", data[key]]).split()[0].decode(\"utf-8\")\n                )\n            for item in self.table.body:\n                item.content[2] = str(self.data[item.content[0]][\"size\"])\n                item._invalidate()\n            Caller.main_loop.draw_screen()\n\n        threading.Thread(target=get_sizes).start()\n\n    def _process_data(self, data: dict, mtime: dict) -> dict:\n        \"\"\"\n        Process the given data and mtime dictionaries to create a new\n        dictionary with additional information.\n\n        Parameters:\n            - data (dict): A dictionary containing keys as paths and values as\n              corresponding data.\n            - mtime (dict): A dictionary containing keys as paths and values as\n              corresponding modification times.\n\n        Returns:\n            - dict: A new dictionary with keys from mtime sorted in descending\n              order of modification time. Each key in the new dictionary\n              contains a sub-dictionary with the following keys:\n                - \"path\": The original path from the data dictionary.\n                - \"mtime\": The modification time from the mtime dictionary.\n                - \"entries\": The number of subdirectories in the path.\n                - \"size\": The size of the path in a human-readable format.\n\n        Raises:\n            - subprocess.CalledProcessError: If an error occurs while running\n              the 'du' command to get the size of the path.\n        \"\"\"\n        new_data = {\n            key: {\n                \"path\": data[key],\n                \"mtime\": mtime[key],\n                \"entries\": len(\n                    [i for i in os.listdir(data[key]) if os.path.isdir(os.path.join(data[key], i))]\n                ),\n                \"size\": \"...\",\n            }\n            for key in sorted(mtime, key=mtime.get, reverse=True)\n        }\n        return new_data\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        \"\"\"Process keypress events for the current widget.\n\n        Args:\n            size (tuple[int, int]): The size of the widget.\n            key (str): The key that was pressed.\n\n        Returns:\n            str | None: The result of processing the keypress event.\n        \"\"\"\n        if key in (\"ctrl n\", \"ctrl p\", \"up\", \"down\"):\n            return self.table.keypress(size, key)\n        if key == \"enter\":\n            # check if something is selected\n            if not self.table.focus:\n                return\n            # get UID of the selected action item\n            item = self.table.focus.base_widget.content[0]\n\n            def load_data():\n                with Spinner(caption=f\"[ID: {item}] Reading data \") as spinner:\n                    loading_widget = urwid.Overlay(\n                        cRoundedLineBox(spinner, focus_map=\"default\"),\n                        Caller.main_loop.widget,\n                        \"center\",\n                        (\"relative\", 50),\n                        \"middle\",\n                        (\"pack\"),\n                    )\n                    Caller.enter_widget(loading_widget)\n\n                    # Create databaase widget\n                    database = Database(item, bamboost.Manager(uid=item))\n                    # Exit the loading widget\n                    Caller.exit_widget()\n\n                Caller.enter_widget(database)\n\n            threading.Thread(target=load_data).start()\n\n            return\n        return super().keypress(size, key)\n\n    def on_search_change(self, edit, new_edit_text):\n        \"\"\"Updates the table body based on a fuzzy search of the new edit\n        text.\n\n        Arguments:\n            - edit (str): The current edit text in the search bar.\n            - new_edit_text (str): The new edit text entered by the user.\n\n        Returns:\n            - None\n        \"\"\"\n        filtered = self.fuzzy_search(new_edit_text)\n        self.table.body[:] = filtered\n        if filtered:\n            self.table.focus_position = 0\n\n    def fuzzy_search(self, query):\n        \"\"\"Perform a fuzzy search on the data based on the given query.\n\n        Args:\n            - query (str): The query string to search for.\n\n        Returns:\n            - list: A list of items that match the fuzzy search criteria.\n\n        Raises:\n            - None\n\n        This method takes a query string and performs a fuzzy search on the\n        data stored in the object. If the query string is empty, it will return\n        all items in the data. Otherwise, it will return items that have a\n        partial ratio match of greater than 70 with the query string.\n        \"\"\"\n        # item: list[uid, entries, size, path, mtime]\n        if query == \"\":\n            return [item for item in self.table.items]\n\n        res = [item for item in self.table.items if fuzz.partial_ratio(item.content[3], query) > 70]\n        return res\n\n    def _create_item(self, uid) -> list:\n        item = [\n            uid,\n            self.data[uid][\"entries\"],\n            self.data[uid][\"size\"],\n            self.data[uid][\"path\"],\n            datetime.fromtimestamp(self.data[uid][\"mtime\"]).strftime(\"%Y-%m-%d %H:%M:%S\"),\n        ]\n        return cActionItem([str(i) for i in item])",
              "inherited_members": {}
            },
            "IndexRemote": {
              "name": "IndexRemote",
              "path": "bamboostcli.widgets.index.IndexRemote",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "remote",
                  "annotation": "Remote",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "remote",
                  "annotation": null,
                  "description": null,
                  "value": "remote"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.index.IndexRemote.__init__",
                  "signature": "(self, *args, *, remote) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "remote",
                      "annotation": "Remote",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, *args, remote: Remote) -> None:\n    self.remote = remote\n    data = remote.read_table().set_index(\"id\").to_dict()[\"path\"]\n    super().__init__(data)"
                },
                "_initialize": {
                  "name": "_initialize",
                  "path": "bamboostcli.widgets.index.IndexRemote._initialize",
                  "signature": "(self, data) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _initialize(self, data: dict) -> None:\n    self.data = data\n\n    def bold_text(text, *args, **kwargs):\n        return urwid.AttrWrap(urwid.Text(text, *args, **kwargs), \"bold\")\n\n    self.table = cListBoxSelectionCharacter(\n        [self._create_item(key) for key in self.data],\n        {0: \"5\", 1: \"default\"},\n        {0: \"5-bold\", 1: \"bold\"},\n        always_in_focus=True,\n        column_sizing=[urwid.FIXED, urwid.WEIGHT],\n        column_align=[urwid.LEFT, urwid.RIGHT],\n        headers=[\"UID\", \"Path\"],\n    )\n    self.headers = urwid.Columns(\n        [(\"fixed\", 1, urwid.Text(\" \"))]\n        + [\n            (sizing, width, bold_text(text, align=align))\n            for sizing, width, text, align in zip(\n                self.table._column_sizing,\n                self.table._column_widths.values(),\n                self.table._headers,\n                self.table._column_align,\n            )\n        ],\n        dividechars=self.table.items[0].DIVIDECHARS,\n    )\n    self.header = urwid.Pile([urwid.Divider(), self.headers, urwid.Divider()])\n    self.footer = urwid.Filler(\n        urwid.Padding(cEdit(\"Search: \", \"\", align=\"left\"), left=3), top=1, bottom=1\n    )\n    urwid.connect_signal(self.footer.base_widget, \"change\", self.on_search_change)"
                },
                "_create_item": {
                  "name": "_create_item",
                  "path": "bamboostcli.widgets.index.IndexRemote._create_item",
                  "signature": "(self, uid) -> list",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "list",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _create_item(self, uid) -> list:\n    item = [\n        uid,\n        self.data[uid],\n    ]\n    return cActionItem([str(i) for i in item])"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.index.IndexRemote.keypress",
                  "signature": "(self, size, key) -> Union",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Union",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple, key: str) -> Union[str, None]:\n    if key == \"enter\":\n        # check if something is selected\n        if not self.table.focus:\n            return\n        # get UID of the selected action item\n        item = self.table.focus.base_widget.content[0]\n\n        def load_data():\n            with Spinner(caption=f\"[ID: {item}] Reading data \") as spinner:\n                loading_widget = urwid.Overlay(\n                    cRoundedLineBox(spinner, focus_map=\"default\"),\n                    Caller.main_loop.widget,\n                    \"center\",\n                    (\"relative\", 50),\n                    \"middle\",\n                    (\"pack\"),\n                )\n                Caller.enter_widget(loading_widget)\n\n                # Create databaase widget\n                database = Database(item, self.remote[item])\n                # Exit the loading widget\n                Caller.exit_widget()\n\n            Caller.enter_widget(database)\n\n        threading.Thread(target=load_data).start()\n\n        return\n\n    if key == \"ctrl r\":\n        def read_process_output(widget):\n            with Spinner(caption=\"Downloading index file \") as spinner:\n                Caller.widget_stack[-1]._frame.footer.contents[1] = (spinner, (\"pack\", None))\n                # download the index file\n                with self.remote.fetch_index() as process:\n                    for line in process.stdout:\n                        widget.set_text(widget.text + line)\n                        Caller.main_loop.draw_screen()\n                Caller.exit_widget()\n                Caller.main_loop.draw_screen()\n\n        text_widget = urwid.Text(\"\")\n        popup = cPopup(urwid.Filler(text_widget, valign=urwid.TOP), title=\"Downloading index file\", footer=\"\")\n        Caller.enter_widget(popup)\n        Caller.main_loop.draw_screen()\n        threading.Thread(target=read_process_output, args=(text_widget,)).start()\n        return\n\n    return super().keypress(size, key)"
                },
                "fuzzy_search": {
                  "name": "fuzzy_search",
                  "path": "bamboostcli.widgets.index.IndexRemote.fuzzy_search",
                  "signature": "(self, query)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "query",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def fuzzy_search(self, query):\n    # item: list[uid, path]\n    if query == \"\":\n        return [item for item in self.table.items]\n\n    res = [item for item in self.table.items if fuzz.partial_ratio(item.content[1], query) > 70]\n    return res"
                }
              },
              "source": "class IndexRemote(Index):\n\n    def __init__(self, *args, remote: Remote) -> None:\n        self.remote = remote\n        data = remote.read_table().set_index(\"id\").to_dict()[\"path\"]\n        super().__init__(data)\n\n    def _initialize(self, data: dict) -> None:\n        self.data = data\n\n        def bold_text(text, *args, **kwargs):\n            return urwid.AttrWrap(urwid.Text(text, *args, **kwargs), \"bold\")\n\n        self.table = cListBoxSelectionCharacter(\n            [self._create_item(key) for key in self.data],\n            {0: \"5\", 1: \"default\"},\n            {0: \"5-bold\", 1: \"bold\"},\n            always_in_focus=True,\n            column_sizing=[urwid.FIXED, urwid.WEIGHT],\n            column_align=[urwid.LEFT, urwid.RIGHT],\n            headers=[\"UID\", \"Path\"],\n        )\n        self.headers = urwid.Columns(\n            [(\"fixed\", 1, urwid.Text(\" \"))]\n            + [\n                (sizing, width, bold_text(text, align=align))\n                for sizing, width, text, align in zip(\n                    self.table._column_sizing,\n                    self.table._column_widths.values(),\n                    self.table._headers,\n                    self.table._column_align,\n                )\n            ],\n            dividechars=self.table.items[0].DIVIDECHARS,\n        )\n        self.header = urwid.Pile([urwid.Divider(), self.headers, urwid.Divider()])\n        self.footer = urwid.Filler(\n            urwid.Padding(cEdit(\"Search: \", \"\", align=\"left\"), left=3), top=1, bottom=1\n        )\n        urwid.connect_signal(self.footer.base_widget, \"change\", self.on_search_change)\n\n    def _create_item(self, uid) -> list:\n        item = [\n            uid,\n            self.data[uid],\n        ]\n        return cActionItem([str(i) for i in item])\n\n    def keypress(self, size: tuple, key: str) -> Union[str, None]:\n        if key == \"enter\":\n            # check if something is selected\n            if not self.table.focus:\n                return\n            # get UID of the selected action item\n            item = self.table.focus.base_widget.content[0]\n\n            def load_data():\n                with Spinner(caption=f\"[ID: {item}] Reading data \") as spinner:\n                    loading_widget = urwid.Overlay(\n                        cRoundedLineBox(spinner, focus_map=\"default\"),\n                        Caller.main_loop.widget,\n                        \"center\",\n                        (\"relative\", 50),\n                        \"middle\",\n                        (\"pack\"),\n                    )\n                    Caller.enter_widget(loading_widget)\n\n                    # Create databaase widget\n                    database = Database(item, self.remote[item])\n                    # Exit the loading widget\n                    Caller.exit_widget()\n\n                Caller.enter_widget(database)\n\n            threading.Thread(target=load_data).start()\n\n            return\n\n        if key == \"ctrl r\":\n            def read_process_output(widget):\n                with Spinner(caption=\"Downloading index file \") as spinner:\n                    Caller.widget_stack[-1]._frame.footer.contents[1] = (spinner, (\"pack\", None))\n                    # download the index file\n                    with self.remote.fetch_index() as process:\n                        for line in process.stdout:\n                            widget.set_text(widget.text + line)\n                            Caller.main_loop.draw_screen()\n                    Caller.exit_widget()\n                    Caller.main_loop.draw_screen()\n\n            text_widget = urwid.Text(\"\")\n            popup = cPopup(urwid.Filler(text_widget, valign=urwid.TOP), title=\"Downloading index file\", footer=\"\")\n            Caller.enter_widget(popup)\n            Caller.main_loop.draw_screen()\n            threading.Thread(target=read_process_output, args=(text_widget,)).start()\n            return\n\n        return super().keypress(size, key)\n\n    def fuzzy_search(self, query):\n        # item: list[uid, path]\n        if query == \"\":\n            return [item for item in self.table.items]\n\n        res = [item for item in self.table.items if fuzz.partial_ratio(item.content[1], query) > 70]\n        return res",
              "inherited_members": {
                "bamboostcli.widgets.index.Index": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.index.Index.signals"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.index.Index._process_data"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.index.Index.on_search_change"
                  }
                ]
              }
            }
          },
          "functions": {}
        },
        "rounded_line_box": {
          "name": "rounded_line_box",
          "path": "bamboostcli.widgets.rounded_line_box",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/widgets/rounded_line_box.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "cRoundedLineBox": {
              "name": "cRoundedLineBox",
              "path": "bamboostcli.widgets.rounded_line_box.cRoundedLineBox",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "attr_map",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "focus_map",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "widget",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.LineBox(*args, tlcorner=urwid.LineBox.Symbols.LIGHT.TOP_LEFT_ROUNDED, trcorner=urwid.LineBox.Symbols.LIGHT.TOP_RIGHT_ROUNDED, blcorner=urwid.LineBox.Symbols.LIGHT.BOTTOM_LEFT_ROUNDED, brcorner=urwid.LineBox.Symbols.LIGHT.BOTTOM_RIGHT_ROUNDED, **kwargs)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.rounded_line_box.cRoundedLineBox.__init__",
                  "signature": "(self, *args, *, attr_map=None, focus_map=None, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "attr_map",
                      "annotation": null,
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "focus_map",
                      "annotation": null,
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, *args, attr_map=None, focus_map=None, **kwargs):\n    self.widget = urwid.LineBox(\n        *args,\n        tlcorner=urwid.LineBox.Symbols.LIGHT.TOP_LEFT_ROUNDED,\n        trcorner=urwid.LineBox.Symbols.LIGHT.TOP_RIGHT_ROUNDED,\n        blcorner=urwid.LineBox.Symbols.LIGHT.BOTTOM_LEFT_ROUNDED,\n        brcorner=urwid.LineBox.Symbols.LIGHT.BOTTOM_RIGHT_ROUNDED,\n        **kwargs,\n    )\n    if attr_map is None:\n        attr_map = \"default\"\n    if focus_map is None:\n        focus_map = \"green_box\"\n    super().__init__(self.widget, attr_map, focus_map)"
                },
                "__getattr__": {
                  "name": "__getattr__",
                  "path": "bamboostcli.widgets.rounded_line_box.cRoundedLineBox.__getattr__",
                  "signature": "(self, name)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getattr__(self, name: str):\n    return self.widget.base_widget.__getattribute__(name)"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.rounded_line_box.cRoundedLineBox.keypress",
                  "signature": "(self, size, key) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple[()], key: str) -> str:\n    return super().keypress(size, key)"
                }
              },
              "source": "class cRoundedLineBox(urwid.AttrWrap):\n    def __init__(self, *args, attr_map=None, focus_map=None, **kwargs):\n        self.widget = urwid.LineBox(\n            *args,\n            tlcorner=urwid.LineBox.Symbols.LIGHT.TOP_LEFT_ROUNDED,\n            trcorner=urwid.LineBox.Symbols.LIGHT.TOP_RIGHT_ROUNDED,\n            blcorner=urwid.LineBox.Symbols.LIGHT.BOTTOM_LEFT_ROUNDED,\n            brcorner=urwid.LineBox.Symbols.LIGHT.BOTTOM_RIGHT_ROUNDED,\n            **kwargs,\n        )\n        if attr_map is None:\n            attr_map = \"default\"\n        if focus_map is None:\n            focus_map = \"green_box\"\n        super().__init__(self.widget, attr_map, focus_map)\n\n    def __getattr__(self, name: str):\n        return self.widget.base_widget.__getattribute__(name)\n\n    def keypress(self, size: tuple[()], key: str) -> str:\n        return super().keypress(size, key)",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "table": {
          "name": "table",
          "path": "bamboostcli.widgets.table",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/widgets/table.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "DIVIDE_CHARS",
              "annotation": null,
              "description": null,
              "value": "2"
            },
            {
              "name": "SORT_CHARACTERS",
              "annotation": null,
              "description": null,
              "value": "{True: '\u25b2', False: '\u25bc'}"
            },
            {
              "name": "SELECT_CHARACTER",
              "annotation": null,
              "description": null,
              "value": "'\u276f'"
            },
            {
              "name": "data",
              "annotation": null,
              "description": null,
              "value": "{'id': [1, 2, 3, 4, 5], 'time_stamp': pd.to_datetime(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05']), 'status': ['Running', 'Finished', 'Failed', 'Started', 'Completed'], 'value': [1.0, 2.0, 3.0, 4.0, 5.0], 'array': [np.array([1, 2, 3]), np.array([4, 5, 6]), np.array([7, 8, 9]), np.array([10, 11, 12]), np.array([13, 14, 15])], 'submitted': [True, False, True, False, True]}"
            },
            {
              "name": "df",
              "annotation": null,
              "description": null,
              "value": "pd.DataFrame(data)"
            },
            {
              "name": "table",
              "annotation": null,
              "description": null,
              "value": "Table(df)"
            },
            {
              "name": "main_loop",
              "annotation": null,
              "description": null,
              "value": "urwid.MainLoop(table, palette=palette)"
            }
          ],
          "modules": {},
          "classes": {
            "Part": {
              "name": "Part",
              "path": "bamboostcli.widgets.table.Part",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "PINNED",
                  "annotation": null,
                  "description": null,
                  "value": "1"
                },
                {
                  "name": "SCROLLABLE",
                  "annotation": null,
                  "description": null,
                  "value": "3"
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class Part(Enum):\n    # Enum for the focus part of the row widget\n    # the value is the focus_col of the Columns widget\n    PINNED = 1\n    SCROLLABLE = 3",
              "inherited_members": {}
            },
            "SortOrder": {
              "name": "SortOrder",
              "path": "bamboostcli.widgets.table.SortOrder",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "ASCENDING",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "DESCENDING",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class SortOrder(Enum):\n    ASCENDING = True\n    DESCENDING = False",
              "inherited_members": {}
            },
            "ColumnsAlwaysFocused": {
              "name": "ColumnsAlwaysFocused",
              "path": "bamboostcli.widgets.table.ColumnsAlwaysFocused",
              "description": "A Columns widget that always renders with focus.",
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.table.ColumnsAlwaysFocused.render",
                  "signature": "(self, size, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus: bool = False):\n    return super().render(size, focus=True)"
                }
              },
              "source": "class ColumnsAlwaysFocused(urwid.Columns):\n    \"\"\"A Columns widget that always renders with focus.\"\"\"\n\n    def render(self, size, focus: bool = False):\n        return super().render(size, focus=True)",
              "inherited_members": {}
            },
            "SelectionIcon": {
              "name": "SelectionIcon",
              "path": "bamboostcli.widgets.table.SelectionIcon",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "focus_cb",
                  "annotation": "callable",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "icon",
                  "annotation": null,
                  "description": null,
                  "value": "SELECT_CHARACTER"
                },
                {
                  "name": "focus_cb",
                  "annotation": null,
                  "description": null,
                  "value": "focus_cb"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.table.SelectionIcon.__init__",
                  "signature": "(self, focus_cb)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus_cb",
                      "annotation": "callable",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, focus_cb: callable):\n    self.icon = SELECT_CHARACTER\n    self.focus_cb = focus_cb\n    super().__init__(self.icon, align=\"center\")"
                },
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.table.SelectionIcon.render",
                  "signature": "(self, size, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": null,
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus=False):\n    if self.focus_cb():\n        self.set_text((\"4\", self.icon))\n    else:\n        self.set_text(\" \")\n    return super().render(size, focus)"
                }
              },
              "source": "class SelectionIcon(urwid.Text):\n    # Icon to indicate the selected row\n    # focus_cb is a callback to check if the row the icon belongs to is focused\n    def __init__(self, focus_cb: callable):\n        self.icon = SELECT_CHARACTER\n        self.focus_cb = focus_cb\n        super().__init__(self.icon, align=\"center\")\n\n    def render(self, size, focus=False):\n        if self.focus_cb():\n            self.set_text((\"4\", self.icon))\n        else:\n            self.set_text(\" \")\n        return super().render(size, focus)",
              "inherited_members": {}
            },
            "ColumnFocusIndicator": {
              "name": "ColumnFocusIndicator",
              "path": "bamboostcli.widgets.table.ColumnFocusIndicator",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "table",
                  "annotation": "Table",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "_icons",
                  "annotation": null,
                  "description": null,
                  "value": "{SortOrder.ASCENDING: '\u25b2', SortOrder.DESCENDING: '\u25bc'}"
                },
                {
                  "name": "table",
                  "annotation": null,
                  "description": null,
                  "value": "table"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.table.ColumnFocusIndicator.__init__",
                  "signature": "(self, table)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "table",
                      "annotation": "Table",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, table: Table):\n    self.table = table\n    super().__init__(\"a\", align=\"center\")"
                },
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.table.ColumnFocusIndicator.render",
                  "signature": "(self, size, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": null,
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus=False):\n    if focus:\n        self.set_text((\"4\", self._icons[self.table._sort_order]))\n    else:\n        self.set_text(\" \")\n    return super().render(size, focus)"
                }
              },
              "source": "class ColumnFocusIndicator(urwid.Text):\n    _icons = {\n        SortOrder.ASCENDING: \"\\u25b2\",\n        SortOrder.DESCENDING: \"\\u25bc\",\n    }\n\n    def __init__(self, table: Table):\n        self.table = table\n        super().__init__(\"a\", align=\"center\")\n\n    def render(self, size, focus=False):\n        if focus:\n            self.set_text((\"4\", self._icons[self.table._sort_order]))\n        else:\n            self.set_text(\" \")\n        return super().render(size, focus)",
              "inherited_members": {}
            },
            "Table": {
              "name": "Table",
              "path": "bamboostcli.widgets.table.Table",
              "description": "Table widget for displaying a pandas DataFrame. The table is displayed as a\nurwid.Frame with the Header being the column names and the body being the data.\nEach row is a Row widget is derived from urwid.Columns and contains a list of\ncells. Each cell is a urwid.Text widget.\n\nAttrMap is used for styling the table.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "df",
                  "annotation": "pd.DataFrame",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "signals",
                  "annotation": null,
                  "description": null,
                  "value": "['enter_file', 'set_footer']"
                },
                {
                  "name": "_df",
                  "annotation": null,
                  "description": null,
                  "value": "df"
                },
                {
                  "name": "_filtered_df",
                  "annotation": null,
                  "description": null,
                  "value": "df"
                },
                {
                  "name": "_column_sizes",
                  "annotation": null,
                  "description": null,
                  "value": "self._get_column_sizes(df)"
                },
                {
                  "name": "_sort_column",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "_focus_column",
                  "annotation": null,
                  "description": null,
                  "value": "'time_stamp'"
                },
                {
                  "name": "_sort_order",
                  "annotation": null,
                  "description": null,
                  "value": "SortOrder.ASCENDING"
                },
                {
                  "name": "columns",
                  "annotation": null,
                  "description": null,
                  "value": "np.array(df.columns.tolist())"
                },
                {
                  "name": "pinned_columns",
                  "annotation": "np.ndarray",
                  "description": null,
                  "value": null
                },
                {
                  "name": "scrollable_columns",
                  "annotation": "np.ndarray",
                  "description": null,
                  "value": null
                },
                {
                  "name": "keybinds",
                  "annotation": null,
                  "description": null,
                  "value": "Keybindings(self, group='table').new('right', 'l', Table.navigate_right, 'Navigate right', ['right', 'ctrl f']).new('left', 'h', Table.navigate_left, 'Navigate left', ['left', 'ctrl b']).new('sort', 's', lambda *_: self.sort(self._get_column_name_in_focus()), 'Sort column in focus').new('reset', 'r', Table.reset, 'Reset table').new('enter', 'enter', Table.enter, 'Enter hdfview')"
                },
                {
                  "name": "_rows",
                  "annotation": "dict",
                  "description": null,
                  "value": "{record['id']: RowEntry(self, record)for record in df.to_records(index=False)}"
                },
                {
                  "name": "entries",
                  "annotation": null,
                  "description": null,
                  "value": "cListBox(urwid.SimpleFocusListWalker(self._id_list_to_rows(df['id'].values)))"
                },
                {
                  "name": "headers",
                  "annotation": null,
                  "description": null,
                  "value": "RowHeader(self, df.columns)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.table.Table.__init__",
                  "signature": "(self, df) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "df",
                      "annotation": "pd.DataFrame",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, df: pd.DataFrame) -> None:\n    self._df = df\n    # Store a copy of the dataframe to apply filters and sorting\n    self._filtered_df = df\n\n    self._column_sizes = self._get_column_sizes(df)\n    self._sort_column = None\n    self._focus_column = \"time_stamp\"\n    self._sort_order = SortOrder.ASCENDING\n\n    self.columns = np.array(df.columns.tolist())  # columns ordered as in the DataFrame\n    self.pinned_columns = [\"id\"]\n    self.scrollable_columns = [col for col in df.columns if col not in self.pinned_columns]\n\n    # fmt: off\n    self.keybinds = (\n        Keybindings(self, group=\"table\")\n        .new(\"right\", \"l\", Table.navigate_right, \"Navigate right\", [\"right\", \"ctrl f\"])\n        .new(\"left\", \"h\", Table.navigate_left, \"Navigate left\", [\"left\", \"ctrl b\"])\n        .new(\"sort\", \"s\", lambda *_: self.sort(self._get_column_name_in_focus()), \"Sort column in focus\")\n        .new(\"reset\", \"r\", Table.reset, \"Reset table\")\n        .new(\"enter\", \"enter\", Table.enter, \"Enter hdfview\")\n    ) \n    # fmt: on\n\n    # Shelf of all rows\n    self._rows: dict[str, RowEntry] = {\n        record[\"id\"]: RowEntry(self, record) for record in df.to_records(index=False)\n    }\n    self.entries = cListBox(urwid.SimpleFocusListWalker(self._id_list_to_rows(df[\"id\"].values)))\n    self.headers = RowHeader(self, df.columns)\n\n    apply_user_keybinds(self.keybinds, \"table\")\n    # merge keybinds from self.entries and assign to group table\n    self.keybinds.merge(self.entries.keybinds, group=\"table\")\n    self.keybinds.resolve_mapping()\n\n    super().__init__(\n        self.entries,\n        header=urwid.Pile([self.headers, urwid.Divider(\"\\u2500\")]),\n        focus_part=\"body\",\n    )"
                },
                "_id_list_to_rows": {
                  "name": "_id_list_to_rows",
                  "path": "bamboostcli.widgets.table.Table._id_list_to_rows",
                  "signature": "(self, id_list) -> list",
                  "description": "Returns a list of rows for the given list of ids.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "id_list",
                      "annotation": "list",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "list",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _id_list_to_rows(self, id_list: list[str]) -> list[RowEntry]:\n    \"\"\"Returns a list of rows for the given list of ids.\"\"\"\n    return [self._rows[id] for id in id_list]"
                },
                "_invalidate": {
                  "name": "_invalidate",
                  "path": "bamboostcli.widgets.table.Table._invalidate",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _invalidate(self) -> None:\n    self._column_sizes = self._get_column_sizes(self._df)\n    self.entries._invalidate()\n    return super()._invalidate()"
                },
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.table.Table.render",
                  "signature": "(self, size, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus: bool = False):\n    # Always render the table with focus\n    return super().render(size, focus=True)"
                },
                "loc": {
                  "name": "loc",
                  "path": "bamboostcli.widgets.table.Table.loc",
                  "signature": "(self, id) -> RowEntry",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "id",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboostcli.widgets.table.RowEntry",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def loc(self, id: str) -> RowEntry:\n    return self._rows[id]"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.widgets.table.Table.keypress",
                  "signature": "(self, size, key) -> str | None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str | None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n    if key in self.keybinds.keys():\n        self.keybinds.call(key, size=size)\n        return\n    self.keybinds.reset_submap()\n    return super().keypress(size, key)"
                },
                "_get_column_sizes": {
                  "name": "_get_column_sizes",
                  "path": "bamboostcli.widgets.table.Table._get_column_sizes",
                  "signature": "(self, df, max_column_width=30) -> dict",
                  "description": "Calculate the maximum width of each column in the DataFrame. This is used to set\nthe width of each cell in the table. The maximum width is calculated by taking the\nlength of the column name and the length of the longest entry in the column.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "df",
                      "annotation": "pd.DataFrame",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "max_column_width",
                      "annotation": "int",
                      "description": null,
                      "value": "30"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "dict",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_column_sizes(self, df: pd.DataFrame, max_column_width: int = 30) -> dict:\n    \"\"\"Calculate the maximum width of each column in the DataFrame. This is used to set\n    the width of each cell in the table. The maximum width is calculated by taking the\n    length of the column name and the length of the longest entry in the column.\n\n    Args:\n        - df (pd.DataFrame): The DataFrame to calculate the column sizes for.\n    \"\"\"\n    column_sizes = dict()\n    for col in df.columns:\n        max_length = len(col)\n        for entry in df[col].values:\n            if isinstance(entry, np.ndarray) and (entry.size > 6 or entry.ndim > 1):\n                max_length = max(max_length, len(f\"Array {entry.shape}\"))\n            elif isinstance(entry, np.datetime64):\n                max_length = 19\n            else:\n                max_length = max(max_length, len(str(entry)))\n\n        # Ignore max-column-width for certain columns\n        if col in Config.table.get('no-cutoff-columns', []):\n            column_sizes[col] = max_length\n        else:\n            column_sizes[col] = min(max_length, max_column_width)\n    return column_sizes"
                },
                "_get_column_name_in_focus": {
                  "name": "_get_column_name_in_focus",
                  "path": "bamboostcli.widgets.table.Table._get_column_name_in_focus",
                  "signature": "(self) -> str",
                  "description": "Returns the name of the column in focus.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_column_name_in_focus(self) -> str:\n    \"\"\"Returns the name of the column in focus.\"\"\"\n    return self.headers.get_column_name_in_focus()"
                },
                "_get_entry_in_focus": {
                  "name": "_get_entry_in_focus",
                  "path": "bamboostcli.widgets.table.Table._get_entry_in_focus",
                  "signature": "(self) -> np.record",
                  "description": "Returns the column name of the column in focus.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "numpy.record",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_entry_in_focus(self) -> np.record:\n    \"\"\"Returns the column name of the column in focus.\"\"\"\n    return self.entries.focus.record"
                },
                "navigate_right": {
                  "name": "navigate_right",
                  "path": "bamboostcli.widgets.table.Table.navigate_right",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def navigate_right(self) -> None:\n    for row in chain(self.entries.body, [self.headers]):\n        row.navigate_right()"
                },
                "navigate_left": {
                  "name": "navigate_left",
                  "path": "bamboostcli.widgets.table.Table.navigate_left",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def navigate_left(self) -> None:\n    for row in chain(self.entries.body, [self.headers]):\n        row.navigate_left()"
                },
                "enter": {
                  "name": "enter",
                  "path": "bamboostcli.widgets.table.Table.enter",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def enter(self) -> None:\n    id = self._get_entry_in_focus()[\"id\"]\n    urwid.emit_signal(self, \"enter_file\", id)"
                },
                "go_to_column": {
                  "name": "go_to_column",
                  "path": "bamboostcli.widgets.table.Table.go_to_column",
                  "signature": "(self, column, **kwargs) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "column",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def go_to_column(self, column: str, **kwargs) -> None:\n    if column in self._pinned_columns:\n        index = np.where(self.pinned_columns == column)[0][0]\n        part = Part.PINNED\n    elif column in self.scrollable_columns:\n        index = np.where(self.scrollable_columns == column)[0][0]\n        part = Part.SCROLLABLE\n    else:\n        raise KeyError(f\"Column {column} is not displayed\")\n\n    self._focus_column = column\n    for row in chain(self.entries.body, [self.headers]):\n        row.set_focus(part, int(index))"
                },
                "reset_data": {
                  "name": "reset_data",
                  "path": "bamboostcli.widgets.table.Table.reset_data",
                  "signature": "(self, df) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "df",
                      "annotation": "pd.DataFrame",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def reset_data(self, df: pd.DataFrame) -> None:\n    self._df = df\n    self._filtered_df = df\n    self._rows = {record[\"id\"]: RowEntry(self, record) for record in df.to_records(index=False)}\n    self.entries.body[:] = self._id_list_to_rows(df[\"id\"].values)\n    self.headers._invalidate()"
                },
                "sort": {
                  "name": "sort",
                  "path": "bamboostcli.widgets.table.Table.sort",
                  "signature": "(self, column, **kwargs) -> None",
                  "description": "Sort the table by the given column.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "column",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def sort(self, column: str, **kwargs) -> None:\n    \"\"\"Sort the table by the given column.\"\"\"\n    close = kwargs.get(\"close\", None)\n    reverse = kwargs.get(\"reverse\", None)\n\n    self.go_to_column(column)\n\n    if close is not None:\n        return self.sort_closest(column, **kwargs)\n\n    if reverse is None:\n        self._sort_order = SortOrder(not self._sort_order.value)\n        reverse = self._sort_order.value\n\n    # Sort the DataFrame by the given column\n    self._filtered_df = self._filtered_df.sort_values(column, ascending=reverse)\n    # Update the rows in the table\n    self.entries.body[:] = self._id_list_to_rows(self._filtered_df[\"id\"].values)\n    self.headers._invalidate()"
                },
                "sort_closest": {
                  "name": "sort_closest",
                  "path": "bamboostcli.widgets.table.Table.sort_closest",
                  "signature": "(self, column, **kwargs) -> None",
                  "description": "Sort by the closest value in a column",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "column",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def sort_closest(self, column: str, **kwargs) -> None:\n    \"\"\"Sort by the closest value in a column\"\"\"\n    value = kwargs[\"close\"]\n    value = float(value) if value.replace(\".\", \"\", 1).isdigit() else value\n    try:\n        self._filtered_df = self._df.iloc[(self._df[column] - value).abs().argsort()]\n        self.entries.body[:] = self._id_list_to_rows(self._filtered_df[\"id\"].values)\n    except KeyError:\n        raise KeyError(f\"Column {column} does not exist\")"
                },
                "reset": {
                  "name": "reset",
                  "path": "bamboostcli.widgets.table.Table.reset",
                  "signature": "(self, **kwargs) -> None",
                  "description": "Reset the table to the original DataFrame.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def reset(self, **kwargs) -> None:\n    \"\"\"Reset the table to the original DataFrame.\"\"\"\n    self._filtered_df = self._df\n    self.entries.body[:] = self._id_list_to_rows(self._df[\"id\"].values)\n    self.go_to_column(self._get_column_name_in_focus())\n    self.headers._invalidate()"
                },
                "filter": {
                  "name": "filter",
                  "path": "bamboostcli.widgets.table.Table.filter",
                  "signature": "(self, column, **kwargs) -> None",
                  "description": "Filter by a column",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "column",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The column to filter by."
                        }
                      ]
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": [
                        {
                          "kind": "text",
                          "value": "these are the arguments parsed by argparse from the string\ninput in the command line."
                        }
                      ],
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def filter(self, column: str, **kwargs) -> None:\n    \"\"\"Filter by a column\n\n    Args:\n        column (str): The column to filter by.\n        kwargs: these are the arguments parsed by argparse from the string\n            input in the command line.\n    \"\"\"\n    self.go_to_column(column)\n\n    def filter_op(op: str, val: str, as_string: bool = False) -> pd.DataFrame:\n        if not as_string:\n            try:\n                val = float(val)\n            except ValueError:\n                pass\n        if op == \"eq\":\n            return self._filtered_df[self._filtered_df[column] == val]\n        elif op == \"ne\":\n            return self._filtered_df[self._filtered_df[column] != val]\n        elif op == \"gt\":\n            return self._filtered_df[self._filtered_df[column] > val]\n        elif op == \"lt\":\n            return self._filtered_df[self._filtered_df[column] < val]\n        elif op == \"ge\":\n            return self._filtered_df[self._filtered_df[column] >= val]\n        elif op == \"le\":\n            return self._filtered_df[self._filtered_df[column] <= val]\n        elif op == \"contains\":\n            return self._filtered_df[self._filtered_df[column].str.contains(val, case=False)]\n        else:\n            return self._filtered_df\n\n    as_string = kwargs.pop(\"as_string\", False)\n    for opt, value in kwargs.items():\n        if value is not None:\n            self._filtered_df = filter_op(opt, value, as_string)\n            self.entries.body[:] = self._id_list_to_rows(self._filtered_df[\"id\"].values)"
                },
                "pin_column": {
                  "name": "pin_column",
                  "path": "bamboostcli.widgets.table.Table.pin_column",
                  "signature": "(self, column) -> None",
                  "description": "Pin a column to the left.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "column",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def pin_column(self, column: str) -> None:\n    \"\"\"Pin a column to the left.\"\"\"\n    if column in self._pinned_columns:\n        self._pinned_columns.remove(column)\n        self._scrollable_columns.add(column)\n    else:\n        self._scrollable_columns.remove(column)\n        self._pinned_columns.add(column)\n    for row in chain(self.entries.body, [self.headers]):\n        row._invalidate()"
                }
              },
              "source": "class Table(urwid.Frame):\n    \"\"\"Table widget for displaying a pandas DataFrame. The table is displayed as a\n    urwid.Frame with the Header being the column names and the body being the data.\n    Each row is a Row widget is derived from urwid.Columns and contains a list of\n    cells. Each cell is a urwid.Text widget.\n\n    AttrMap is used for styling the table.\n\n\n    \"\"\"\n\n    signals = [\n        \"enter_file\",\n        \"set_footer\",\n    ]\n\n    def __init__(self, df: pd.DataFrame) -> None:\n        self._df = df\n        # Store a copy of the dataframe to apply filters and sorting\n        self._filtered_df = df\n\n        self._column_sizes = self._get_column_sizes(df)\n        self._sort_column = None\n        self._focus_column = \"time_stamp\"\n        self._sort_order = SortOrder.ASCENDING\n\n        self.columns = np.array(df.columns.tolist())  # columns ordered as in the DataFrame\n        self.pinned_columns = [\"id\"]\n        self.scrollable_columns = [col for col in df.columns if col not in self.pinned_columns]\n\n        # fmt: off\n        self.keybinds = (\n            Keybindings(self, group=\"table\")\n            .new(\"right\", \"l\", Table.navigate_right, \"Navigate right\", [\"right\", \"ctrl f\"])\n            .new(\"left\", \"h\", Table.navigate_left, \"Navigate left\", [\"left\", \"ctrl b\"])\n            .new(\"sort\", \"s\", lambda *_: self.sort(self._get_column_name_in_focus()), \"Sort column in focus\")\n            .new(\"reset\", \"r\", Table.reset, \"Reset table\")\n            .new(\"enter\", \"enter\", Table.enter, \"Enter hdfview\")\n        ) \n        # fmt: on\n\n        # Shelf of all rows\n        self._rows: dict[str, RowEntry] = {\n            record[\"id\"]: RowEntry(self, record) for record in df.to_records(index=False)\n        }\n        self.entries = cListBox(urwid.SimpleFocusListWalker(self._id_list_to_rows(df[\"id\"].values)))\n        self.headers = RowHeader(self, df.columns)\n\n        apply_user_keybinds(self.keybinds, \"table\")\n        # merge keybinds from self.entries and assign to group table\n        self.keybinds.merge(self.entries.keybinds, group=\"table\")\n        self.keybinds.resolve_mapping()\n\n        super().__init__(\n            self.entries,\n            header=urwid.Pile([self.headers, urwid.Divider(\"\\u2500\")]),\n            focus_part=\"body\",\n        )\n\n    def _id_list_to_rows(self, id_list: list[str]) -> list[RowEntry]:\n        \"\"\"Returns a list of rows for the given list of ids.\"\"\"\n        return [self._rows[id] for id in id_list]\n\n    def _invalidate(self) -> None:\n        self._column_sizes = self._get_column_sizes(self._df)\n        self.entries._invalidate()\n        return super()._invalidate()\n\n    def render(self, size, focus: bool = False):\n        # Always render the table with focus\n        return super().render(size, focus=True)\n\n    @property\n    def pinned_columns(self) -> np.ndarray:\n        return self.columns[np.isin(self.columns, list(self._pinned_columns))]\n\n    @pinned_columns.setter\n    def pinned_columns(self, columns: Set[str]) -> None:\n        self._pinned_columns = set(columns)\n        if not hasattr(self, \"entries\"):\n            return\n\n        for row in chain(self.entries.body, [self.headers]):\n            row._invalidate()\n\n    @property\n    def scrollable_columns(self) -> np.ndarray:\n        return self.columns[np.isin(self.columns, list(self._scrollable_columns))]\n\n    @scrollable_columns.setter\n    def scrollable_columns(self, columns: Set[str]) -> None:\n        self._scrollable_columns = set(columns)\n        if not hasattr(self, \"entries\"):\n            return\n\n        for row in chain(self.entries.body, [self.headers]):\n            row._invalidate()\n\n    def loc(self, id: str) -> RowEntry:\n        return self._rows[id]\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        if key in self.keybinds.keys():\n            self.keybinds.call(key, size=size)\n            return\n        self.keybinds.reset_submap()\n        return super().keypress(size, key)\n\n    def _get_column_sizes(self, df: pd.DataFrame, max_column_width: int = 30) -> dict:\n        \"\"\"Calculate the maximum width of each column in the DataFrame. This is used to set\n        the width of each cell in the table. The maximum width is calculated by taking the\n        length of the column name and the length of the longest entry in the column.\n\n        Args:\n            - df (pd.DataFrame): The DataFrame to calculate the column sizes for.\n        \"\"\"\n        column_sizes = dict()\n        for col in df.columns:\n            max_length = len(col)\n            for entry in df[col].values:\n                if isinstance(entry, np.ndarray) and (entry.size > 6 or entry.ndim > 1):\n                    max_length = max(max_length, len(f\"Array {entry.shape}\"))\n                elif isinstance(entry, np.datetime64):\n                    max_length = 19\n                else:\n                    max_length = max(max_length, len(str(entry)))\n\n            # Ignore max-column-width for certain columns\n            if col in Config.table.get('no-cutoff-columns', []):\n                column_sizes[col] = max_length\n            else:\n                column_sizes[col] = min(max_length, max_column_width)\n        return column_sizes\n\n    def _get_column_name_in_focus(self) -> str:\n        \"\"\"Returns the name of the column in focus.\"\"\"\n        return self.headers.get_column_name_in_focus()\n\n    def _get_entry_in_focus(self) -> np.record:\n        \"\"\"Returns the column name of the column in focus.\"\"\"\n        return self.entries.focus.record\n\n    def navigate_right(self) -> None:\n        for row in chain(self.entries.body, [self.headers]):\n            row.navigate_right()\n\n    def navigate_left(self) -> None:\n        for row in chain(self.entries.body, [self.headers]):\n            row.navigate_left()\n\n    def enter(self) -> None:\n        id = self._get_entry_in_focus()[\"id\"]\n        urwid.emit_signal(self, \"enter_file\", id)\n\n    def go_to_column(self, column: str, **kwargs) -> None:\n        if column in self._pinned_columns:\n            index = np.where(self.pinned_columns == column)[0][0]\n            part = Part.PINNED\n        elif column in self.scrollable_columns:\n            index = np.where(self.scrollable_columns == column)[0][0]\n            part = Part.SCROLLABLE\n        else:\n            raise KeyError(f\"Column {column} is not displayed\")\n\n        self._focus_column = column\n        for row in chain(self.entries.body, [self.headers]):\n            row.set_focus(part, int(index))\n\n    def reset_data(self, df: pd.DataFrame) -> None:\n        self._df = df\n        self._filtered_df = df\n        self._rows = {record[\"id\"]: RowEntry(self, record) for record in df.to_records(index=False)}\n        self.entries.body[:] = self._id_list_to_rows(df[\"id\"].values)\n        self.headers._invalidate()\n\n    # -----------------------------------\n    # Functions for sorting and filtering\n    # -----------------------------------\n\n    def sort(self, column: str, **kwargs) -> None:\n        \"\"\"Sort the table by the given column.\"\"\"\n        close = kwargs.get(\"close\", None)\n        reverse = kwargs.get(\"reverse\", None)\n\n        self.go_to_column(column)\n\n        if close is not None:\n            return self.sort_closest(column, **kwargs)\n\n        if reverse is None:\n            self._sort_order = SortOrder(not self._sort_order.value)\n            reverse = self._sort_order.value\n\n        # Sort the DataFrame by the given column\n        self._filtered_df = self._filtered_df.sort_values(column, ascending=reverse)\n        # Update the rows in the table\n        self.entries.body[:] = self._id_list_to_rows(self._filtered_df[\"id\"].values)\n        self.headers._invalidate()\n\n    def sort_closest(self, column: str, **kwargs) -> None:\n        \"\"\"Sort by the closest value in a column\"\"\"\n        value = kwargs[\"close\"]\n        value = float(value) if value.replace(\".\", \"\", 1).isdigit() else value\n        try:\n            self._filtered_df = self._df.iloc[(self._df[column] - value).abs().argsort()]\n            self.entries.body[:] = self._id_list_to_rows(self._filtered_df[\"id\"].values)\n        except KeyError:\n            raise KeyError(f\"Column {column} does not exist\")\n\n    def reset(self, **kwargs) -> None:\n        \"\"\"Reset the table to the original DataFrame.\"\"\"\n        self._filtered_df = self._df\n        self.entries.body[:] = self._id_list_to_rows(self._df[\"id\"].values)\n        self.go_to_column(self._get_column_name_in_focus())\n        self.headers._invalidate()\n\n    def filter(self, column: str, **kwargs) -> None:\n        \"\"\"Filter by a column\n\n        Args:\n            column (str): The column to filter by.\n            kwargs: these are the arguments parsed by argparse from the string\n                input in the command line.\n        \"\"\"\n        self.go_to_column(column)\n\n        def filter_op(op: str, val: str, as_string: bool = False) -> pd.DataFrame:\n            if not as_string:\n                try:\n                    val = float(val)\n                except ValueError:\n                    pass\n            if op == \"eq\":\n                return self._filtered_df[self._filtered_df[column] == val]\n            elif op == \"ne\":\n                return self._filtered_df[self._filtered_df[column] != val]\n            elif op == \"gt\":\n                return self._filtered_df[self._filtered_df[column] > val]\n            elif op == \"lt\":\n                return self._filtered_df[self._filtered_df[column] < val]\n            elif op == \"ge\":\n                return self._filtered_df[self._filtered_df[column] >= val]\n            elif op == \"le\":\n                return self._filtered_df[self._filtered_df[column] <= val]\n            elif op == \"contains\":\n                return self._filtered_df[self._filtered_df[column].str.contains(val, case=False)]\n            else:\n                return self._filtered_df\n\n        as_string = kwargs.pop(\"as_string\", False)\n        for opt, value in kwargs.items():\n            if value is not None:\n                self._filtered_df = filter_op(opt, value, as_string)\n                self.entries.body[:] = self._id_list_to_rows(self._filtered_df[\"id\"].values)\n\n    def pin_column(self, column: str) -> None:\n        \"\"\"Pin a column to the left.\"\"\"\n        if column in self._pinned_columns:\n            self._pinned_columns.remove(column)\n            self._scrollable_columns.add(column)\n        else:\n            self._scrollable_columns.remove(column)\n            self._pinned_columns.add(column)\n        for row in chain(self.entries.body, [self.headers]):\n            row._invalidate()",
              "inherited_members": {}
            },
            "Row": {
              "name": "Row",
              "path": "bamboostcli.widgets.table.Row",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "widget",
                  "annotation": "urwid.Columns",
                  "description": null,
                  "value": null
                },
                {
                  "name": "attr_map",
                  "annotation": "dict",
                  "description": null,
                  "value": null
                },
                {
                  "name": "focus_map",
                  "annotation": "dict",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "_cells",
                  "annotation": "Dict",
                  "description": null,
                  "value": null
                },
                {
                  "name": "pinned_columns",
                  "annotation": "urwid.Columns",
                  "description": null,
                  "value": null
                },
                {
                  "name": "scrollable_columns",
                  "annotation": "urwid.Columns",
                  "description": null,
                  "value": null
                },
                {
                  "name": "_widget",
                  "annotation": "urwid.Columns",
                  "description": null,
                  "value": null
                },
                {
                  "name": "_focus_part",
                  "annotation": "Part",
                  "description": null,
                  "value": null
                },
                {
                  "name": "base_widget",
                  "annotation": "urwid.Columns",
                  "description": null,
                  "value": null
                },
                {
                  "name": "table",
                  "annotation": "Table",
                  "description": null,
                  "value": null
                },
                {
                  "name": "focus_part",
                  "annotation": "Part",
                  "description": null,
                  "value": null
                },
                {
                  "name": "focus",
                  "annotation": "urwid.Columns",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.table.Row.__init__",
                  "signature": "(self, widget, attr_map, focus_map) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "widget",
                      "annotation": "urwid.Columns",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "attr_map",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus_map",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, widget: urwid.Columns, attr_map: dict, focus_map: dict) -> None:\n    super().__init__(widget, attr_map, focus_map)\n    self.focus_part = Part.SCROLLABLE\n    self.base_widget.focus.set_focus(0)"
                },
                "_invalidate": {
                  "name": "_invalidate",
                  "path": "bamboostcli.widgets.table.Row._invalidate",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _invalidate(self) -> None:\n    self._update_sub_column_widgets()\n    return super()._invalidate()"
                },
                "set_focus": {
                  "name": "set_focus",
                  "path": "bamboostcli.widgets.table.Row.set_focus",
                  "signature": "(self, part, focus) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "part",
                      "annotation": "Part",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": "int",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def set_focus(self, part: Part, focus: int) -> None:\n    self.focus_part = part\n    self.focus.focus_position = focus"
                },
                "edit_cell_text": {
                  "name": "edit_cell_text",
                  "path": "bamboostcli.widgets.table.Row.edit_cell_text",
                  "signature": "(self, column, text) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "column",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "text",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def edit_cell_text(self, column: str, text: str) -> None:\n    self._cells[column][2].base_widget.set_text(text)"
                },
                "navigate_right": {
                  "name": "navigate_right",
                  "path": "bamboostcli.widgets.table.Row.navigate_right",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def navigate_right(self) -> None:\n    try:\n        self.focus.focus_position += 1\n    except IndexError:\n        if self.focus_part == Part.PINNED:\n            self.focus_part = Part.SCROLLABLE\n            self.scrollable_columns.focus_position = 0"
                },
                "navigate_left": {
                  "name": "navigate_left",
                  "path": "bamboostcli.widgets.table.Row.navigate_left",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def navigate_left(self) -> None:\n    try:\n        self.focus.focus_position -= 1\n    except IndexError:\n        if self.focus_part == Part.SCROLLABLE:\n            self.focus_part = Part.PINNED\n            self.focus.focus_position = len(self.pinned_columns.contents) - 1"
                },
                "_col_list_to_cells": {
                  "name": "_col_list_to_cells",
                  "path": "bamboostcli.widgets.table.Row._col_list_to_cells",
                  "signature": "(self, columns) -> list",
                  "description": "Returns a list of cells for the given list of columns.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "columns",
                      "annotation": "list",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "list",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _col_list_to_cells(self, columns: list[str]) -> list[CellEntry]:\n    \"\"\"Returns a list of cells for the given list of columns.\"\"\"\n    return [self._cells[col] for col in columns]"
                },
                "_construct_sub_column_widgets": {
                  "name": "_construct_sub_column_widgets",
                  "path": "bamboostcli.widgets.table.Row._construct_sub_column_widgets",
                  "signature": "(self) -> None",
                  "description": "Constructs the column widgets for the fixed and scrollable columns.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _construct_sub_column_widgets(self) -> None:\n    \"\"\"Constructs the column widgets for the fixed and scrollable columns.\"\"\"\n    self.pinned_columns = urwid.Columns(\n        self._col_list_to_cells(self.table.pinned_columns), dividechars=DIVIDE_CHARS\n    )\n    self.scrollable_columns = urwid.Columns(\n        self._col_list_to_cells(self.table.scrollable_columns), dividechars=DIVIDE_CHARS\n    )"
                },
                "_update_sub_column_widgets": {
                  "name": "_update_sub_column_widgets",
                  "path": "bamboostcli.widgets.table.Row._update_sub_column_widgets",
                  "signature": "(self) -> None",
                  "description": "Updates the column widgets for the fixed and scrollable columns.\nThis is used to update the column widgets when the columns are pinned or unpinned.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _update_sub_column_widgets(self) -> None:\n    \"\"\"Updates the column widgets for the fixed and scrollable columns.\n    This is used to update the column widgets when the columns are pinned or unpinned.\n    \"\"\"\n    self.pinned_columns.contents[:] = [\n        (c[2], (urwid.widget.GIVEN, c[1], False))\n        for c in self._col_list_to_cells(self.table.pinned_columns)\n    ]\n    self.scrollable_columns.contents[:] = [\n        (c[2], (urwid.widget.GIVEN, c[1], False))\n        for c in self._col_list_to_cells(self.table.scrollable_columns)\n    ]"
                }
              },
              "source": "class Row(urwid.AttrMap):\n    _cells: Dict[str, CellEntry]\n\n    pinned_columns: urwid.Columns\n    scrollable_columns: urwid.Columns\n\n    _widget: urwid.Columns\n    _focus_part: Part\n    base_widget: urwid.Columns\n    table: Table\n\n    def __init__(self, widget: urwid.Columns, attr_map: dict, focus_map: dict) -> None:\n        super().__init__(widget, attr_map, focus_map)\n        self.focus_part = Part.SCROLLABLE\n        self.base_widget.focus.set_focus(0)\n\n    def _invalidate(self) -> None:\n        self._update_sub_column_widgets()\n        return super()._invalidate()\n\n    @property\n    def focus_part(self) -> Part:\n        return self._focus_part\n\n    @focus_part.setter\n    def focus_part(self, part: Part) -> None:\n        self._focus_part = part\n        self.base_widget.focus_col = part.value\n\n    @property\n    def focus(self) -> urwid.Columns:\n        return self.base_widget.focus\n\n    def set_focus(self, part: Part, focus: int) -> None:\n        self.focus_part = part\n        self.focus.focus_position = focus\n\n    def edit_cell_text(self, column: str, text: str) -> None:\n        self._cells[column][2].base_widget.set_text(text)\n\n    def navigate_right(self) -> None:\n        try:\n            self.focus.focus_position += 1\n        except IndexError:\n            if self.focus_part == Part.PINNED:\n                self.focus_part = Part.SCROLLABLE\n                self.scrollable_columns.focus_position = 0\n\n    def navigate_left(self) -> None:\n        try:\n            self.focus.focus_position -= 1\n        except IndexError:\n            if self.focus_part == Part.SCROLLABLE:\n                self.focus_part = Part.PINNED\n                self.focus.focus_position = len(self.pinned_columns.contents) - 1\n\n    def _col_list_to_cells(self, columns: list[str]) -> list[CellEntry]:\n        \"\"\"Returns a list of cells for the given list of columns.\"\"\"\n        return [self._cells[col] for col in columns]\n\n    def _construct_sub_column_widgets(self) -> None:\n        \"\"\"Constructs the column widgets for the fixed and scrollable columns.\"\"\"\n        self.pinned_columns = urwid.Columns(\n            self._col_list_to_cells(self.table.pinned_columns), dividechars=DIVIDE_CHARS\n        )\n        self.scrollable_columns = urwid.Columns(\n            self._col_list_to_cells(self.table.scrollable_columns), dividechars=DIVIDE_CHARS\n        )\n\n    def _update_sub_column_widgets(self) -> None:\n        \"\"\"Updates the column widgets for the fixed and scrollable columns.\n        This is used to update the column widgets when the columns are pinned or unpinned.\n        \"\"\"\n        self.pinned_columns.contents[:] = [\n            (c[2], (urwid.widget.GIVEN, c[1], False))\n            for c in self._col_list_to_cells(self.table.pinned_columns)\n        ]\n        self.scrollable_columns.contents[:] = [\n            (c[2], (urwid.widget.GIVEN, c[1], False))\n            for c in self._col_list_to_cells(self.table.scrollable_columns)\n        ]",
              "inherited_members": {}
            },
            "RowEntry": {
              "name": "RowEntry",
              "path": "bamboostcli.widgets.table.RowEntry",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "table",
                  "annotation": "Table",
                  "description": null,
                  "value": null
                },
                {
                  "name": "record",
                  "annotation": "np.record",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "table",
                  "annotation": null,
                  "description": null,
                  "value": "table"
                },
                {
                  "name": "record",
                  "annotation": null,
                  "description": null,
                  "value": "record"
                },
                {
                  "name": "columns",
                  "annotation": null,
                  "description": null,
                  "value": "record.dtype.names"
                },
                {
                  "name": "_cells",
                  "annotation": null,
                  "description": null,
                  "value": "{col: CellEntry(col, record[col], self.table._column_sizes[col])for col in self.columns}"
                },
                {
                  "name": "selection_icon",
                  "annotation": null,
                  "description": null,
                  "value": "SelectionIcon(lambda: self.table.entries.focus == self)"
                },
                {
                  "name": "_widget",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Columns([('fixed', 1, self.selection_icon), ('pack', self.pinned_columns), ('fixed', 1, urwid.Text('\u2502')), self.scrollable_columns], dividechars=1)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.table.RowEntry.__init__",
                  "signature": "(self, table, record) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "table",
                      "annotation": "Table",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "record",
                      "annotation": "np.record",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, table: Table, record: np.record) -> None:\n    self.table = table\n    self.record = record\n    self.columns = record.dtype.names\n\n    # Construct cells for each column (immutable tuples of fixed width and text)\n    self._cells = {\n        col: CellEntry(col, record[col], self.table._column_sizes[col]) for col in self.columns\n    }\n    self._construct_sub_column_widgets()\n    self.selection_icon = SelectionIcon(lambda: self.table.entries.focus == self)\n\n    self._widget = urwid.Columns(\n        [\n            (\"fixed\", 1, self.selection_icon),\n            (\"pack\", self.pinned_columns),\n            (\"fixed\", 1, urwid.Text(\"\\u2502\")),\n            self.scrollable_columns,\n        ],\n        dividechars=1,\n    )\n\n    super().__init__(self._widget, *self._get_color_coding(record, self.columns))"
                },
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.table.RowEntry.render",
                  "signature": "(self, size, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus: bool = False):\n    self.selection_icon._invalidate()\n    return super().render(size, focus)"
                },
                "recreate": {
                  "name": "recreate",
                  "path": "bamboostcli.widgets.table.RowEntry.recreate",
                  "signature": "(self) -> None",
                  "description": "Reload the record from the DataFrame and update the cells.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def recreate(self) -> None:\n    \"\"\"Reload the record from the DataFrame and update the cells.\"\"\"\n    self.record = self.table._df[self.table._df[\"id\"] == self.record[\"id\"]].to_records()[0]\n    self._cells = {\n        col: CellEntry(col, self.record[col], self.table._column_sizes[col])\n        for col in self.columns\n    }\n    # Update the contents of the column widgets\n    self._update_sub_column_widgets()\n    # Update the attribute maps for this row\n    self.attr_map, self.focus_map = self._get_color_coding(self.record, self.columns)"
                },
                "_get_color_coding": {
                  "name": "_get_color_coding",
                  "path": "bamboostcli.widgets.table.RowEntry._get_color_coding",
                  "signature": "(self, record, columns) -> Tuple",
                  "description": "Returns the attribute and focus maps for the given record and columns.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "record",
                      "annotation": "np.record",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "columns",
                      "annotation": "Iterable",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Tuple",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_color_coding(self, record: np.record, columns: Iterable[str]) -> Tuple[dict, dict]:\n    \"\"\"Returns the attribute and focus maps for the given record and columns.\"\"\"\n    if Config.theme == \"highlight\":\n        hl = \"reverse\"\n    elif Config.theme == \"default\":\n        hl = \"bold\"\n\n    attr_map = dict()\n    focus_map = dict()\n    # Color the cells based on the type of the value\n    for col in columns:\n        val = record[col]\n        # Datetime\n        if isinstance(val, np.datetime64):\n            attr_map[col] = \"7\"\n            focus_map[col] = f\"7-{hl}\"\n        # None value\n        elif val is None:\n            attr_map[col] = \"9\"  # dark grey\n            focus_map[col] = f\"9-{hl}\"\n        # Numpy array\n        elif isinstance(val, np.ndarray):\n            attr_map[col] = \"6\"\n            focus_map[col] = f\"6-{hl}\"\n        # Boolean\n        elif isinstance(val, (bool, np.bool_)):\n            attr_map[col] = \"3\" if val else \"2\"\n            focus_map[col] = f\"3-{hl}\" if val else f\"2-{hl}\"\n        # Status\n        elif col == \"status\":\n            if val in {\"Running\", \"Started\"}:\n                attr_map[col] = \"4\"\n                focus_map[col] = f\"4-{hl}\"\n            elif val in {\"Finished\", \"Completed\", \"Success\"}:\n                attr_map[col] = \"3\"\n                focus_map[col] = f\"3-{hl}\"\n            elif isinstance(val, str) and (\"Failed\" in val):\n                attr_map[col] = \"2\"\n                focus_map[col] = f\"2-{hl}\"\n        elif isinstance(val, Number):\n            attr_map[col] = \"default\"\n            focus_map[col] = hl\n        elif col == \"id\":\n            attr_map[col] = \"5\"\n            focus_map[col] = f\"5-{hl}\"\n        else:\n            # default\n            attr_map[col] = \"default\"\n            focus_map[col] = hl\n\n    return attr_map, focus_map"
                }
              },
              "source": "class RowEntry(Row):\n    def __init__(self, table: Table, record: np.record) -> None:\n        self.table = table\n        self.record = record\n        self.columns = record.dtype.names\n\n        # Construct cells for each column (immutable tuples of fixed width and text)\n        self._cells = {\n            col: CellEntry(col, record[col], self.table._column_sizes[col]) for col in self.columns\n        }\n        self._construct_sub_column_widgets()\n        self.selection_icon = SelectionIcon(lambda: self.table.entries.focus == self)\n\n        self._widget = urwid.Columns(\n            [\n                (\"fixed\", 1, self.selection_icon),\n                (\"pack\", self.pinned_columns),\n                (\"fixed\", 1, urwid.Text(\"\\u2502\")),\n                self.scrollable_columns,\n            ],\n            dividechars=1,\n        )\n\n        super().__init__(self._widget, *self._get_color_coding(record, self.columns))\n\n    def render(self, size, focus: bool = False):\n        self.selection_icon._invalidate()\n        return super().render(size, focus)\n\n    def recreate(self) -> None:\n        \"\"\"Reload the record from the DataFrame and update the cells.\"\"\"\n        self.record = self.table._df[self.table._df[\"id\"] == self.record[\"id\"]].to_records()[0]\n        self._cells = {\n            col: CellEntry(col, self.record[col], self.table._column_sizes[col])\n            for col in self.columns\n        }\n        # Update the contents of the column widgets\n        self._update_sub_column_widgets()\n        # Update the attribute maps for this row\n        self.attr_map, self.focus_map = self._get_color_coding(self.record, self.columns)\n\n    def _get_color_coding(self, record: np.record, columns: Iterable[str]) -> Tuple[dict, dict]:\n        \"\"\"Returns the attribute and focus maps for the given record and columns.\"\"\"\n        if Config.theme == \"highlight\":\n            hl = \"reverse\"\n        elif Config.theme == \"default\":\n            hl = \"bold\"\n\n        attr_map = dict()\n        focus_map = dict()\n        # Color the cells based on the type of the value\n        for col in columns:\n            val = record[col]\n            # Datetime\n            if isinstance(val, np.datetime64):\n                attr_map[col] = \"7\"\n                focus_map[col] = f\"7-{hl}\"\n            # None value\n            elif val is None:\n                attr_map[col] = \"9\"  # dark grey\n                focus_map[col] = f\"9-{hl}\"\n            # Numpy array\n            elif isinstance(val, np.ndarray):\n                attr_map[col] = \"6\"\n                focus_map[col] = f\"6-{hl}\"\n            # Boolean\n            elif isinstance(val, (bool, np.bool_)):\n                attr_map[col] = \"3\" if val else \"2\"\n                focus_map[col] = f\"3-{hl}\" if val else f\"2-{hl}\"\n            # Status\n            elif col == \"status\":\n                if val in {\"Running\", \"Started\"}:\n                    attr_map[col] = \"4\"\n                    focus_map[col] = f\"4-{hl}\"\n                elif val in {\"Finished\", \"Completed\", \"Success\"}:\n                    attr_map[col] = \"3\"\n                    focus_map[col] = f\"3-{hl}\"\n                elif isinstance(val, str) and (\"Failed\" in val):\n                    attr_map[col] = \"2\"\n                    focus_map[col] = f\"2-{hl}\"\n            elif isinstance(val, Number):\n                attr_map[col] = \"default\"\n                focus_map[col] = hl\n            elif col == \"id\":\n                attr_map[col] = \"5\"\n                focus_map[col] = f\"5-{hl}\"\n            else:\n                # default\n                attr_map[col] = \"default\"\n                focus_map[col] = hl\n\n        return attr_map, focus_map",
              "inherited_members": {
                "bamboostcli.widgets.table.Row": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.pinned_columns"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.scrollable_columns"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row._focus_part"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.base_widget"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.focus_part"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row._invalidate"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.focus"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row.set_focus"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row.edit_cell_text"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row.navigate_right"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row.navigate_left"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row._col_list_to_cells"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row._construct_sub_column_widgets"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row._update_sub_column_widgets"
                  }
                ]
              }
            },
            "RowHeader": {
              "name": "RowHeader",
              "path": "bamboostcli.widgets.table.RowHeader",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "table",
                  "annotation": "Table",
                  "description": null,
                  "value": null
                },
                {
                  "name": "columns",
                  "annotation": "Iterable",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "table",
                  "annotation": null,
                  "description": null,
                  "value": "table"
                },
                {
                  "name": "columns",
                  "annotation": null,
                  "description": null,
                  "value": "columns"
                },
                {
                  "name": "_cells",
                  "annotation": null,
                  "description": null,
                  "value": "{col: CellHeader(col, self.table._column_sizes[col], table)for col in self.columns}"
                },
                {
                  "name": "_widget",
                  "annotation": null,
                  "description": null,
                  "value": "ColumnsAlwaysFocused([('fixed', 1, urwid.Text('\\n')), ('pack', self.pinned_columns), ('fixed', 1, urwid.Text('\\n\u2502')), self.scrollable_columns], dividechars=1)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.widgets.table.RowHeader.__init__",
                  "signature": "(self, table, columns) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "table",
                      "annotation": "Table",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "columns",
                      "annotation": "Iterable",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, table: Table, columns: Iterable[str]) -> None:\n    self.table = table\n    self.columns = columns\n\n    self._cells = {\n        col: CellHeader(col, self.table._column_sizes[col], table) for col in self.columns\n    }\n    self._construct_sub_column_widgets()\n\n    self._widget = ColumnsAlwaysFocused(\n        [\n            (\"fixed\", 1, urwid.Text(\"\\n\")),\n            (\"pack\", self.pinned_columns),\n            (\"fixed\", 1, urwid.Text(\"\\n\\u2502\")),\n            self.scrollable_columns,\n        ],\n        dividechars=1,\n    )\n\n    super().__init__(self._widget, None, None)"
                },
                "get_column_name_in_focus": {
                  "name": "get_column_name_in_focus",
                  "path": "bamboostcli.widgets.table.RowHeader.get_column_name_in_focus",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_column_name_in_focus(self) -> str:\n    return self.focus.focus.base_widget.contents[1][0].get_text()[0]"
                },
                "render": {
                  "name": "render",
                  "path": "bamboostcli.widgets.table.RowHeader.render",
                  "signature": "(self, size, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus: bool = False):\n    # invalidate the focus indicator\n    self.focus.focus.contents[0][0]._invalidate()\n    return super().render(size, focus)"
                }
              },
              "source": "class RowHeader(Row):\n    def __init__(self, table: Table, columns: Iterable[str]) -> None:\n        self.table = table\n        self.columns = columns\n\n        self._cells = {\n            col: CellHeader(col, self.table._column_sizes[col], table) for col in self.columns\n        }\n        self._construct_sub_column_widgets()\n\n        self._widget = ColumnsAlwaysFocused(\n            [\n                (\"fixed\", 1, urwid.Text(\"\\n\")),\n                (\"pack\", self.pinned_columns),\n                (\"fixed\", 1, urwid.Text(\"\\n\\u2502\")),\n                self.scrollable_columns,\n            ],\n            dividechars=1,\n        )\n\n        super().__init__(self._widget, None, None)\n\n    def get_column_name_in_focus(self) -> str:\n        return self.focus.focus.base_widget.contents[1][0].get_text()[0]\n\n    def render(self, size, focus: bool = False):\n        # invalidate the focus indicator\n        self.focus.focus.contents[0][0]._invalidate()\n        return super().render(size, focus)",
              "inherited_members": {
                "bamboostcli.widgets.table.Row": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.pinned_columns"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.scrollable_columns"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row._focus_part"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.base_widget"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.focus_part"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row._invalidate"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.table.Row.focus"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row.set_focus"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row.edit_cell_text"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row.navigate_right"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row.navigate_left"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row._col_list_to_cells"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row._construct_sub_column_widgets"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.table.Row._update_sub_column_widgets"
                  }
                ]
              }
            },
            "CellHeader": {
              "name": "CellHeader",
              "path": "bamboostcli.widgets.table.CellHeader",
              "description": null,
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__new__": {
                  "name": "__new__",
                  "path": "bamboostcli.widgets.table.CellHeader.__new__",
                  "signature": "(cls, column, width, table) -> CellHeader",
                  "description": null,
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "column",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "width",
                      "annotation": "int",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "table",
                      "annotation": "Table",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboostcli.widgets.table.CellHeader",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __new__(cls, column: str, width: int, table: Table) -> CellHeader:\n    widget = urwid.Text(column)\n    widget = urwid.Pile([ColumnFocusIndicator(table), widget])\n    return super().__new__(cls, (\"fixed\", width, widget))"
                }
              },
              "source": "class CellHeader(tuple):\n    def __new__(cls, column: str, width: int, table: Table) -> CellHeader:\n        widget = urwid.Text(column)\n        widget = urwid.Pile([ColumnFocusIndicator(table), widget])\n        return super().__new__(cls, (\"fixed\", width, widget))",
              "inherited_members": {}
            },
            "CellEntry": {
              "name": "CellEntry",
              "path": "bamboostcli.widgets.table.CellEntry",
              "description": null,
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__new__": {
                  "name": "__new__",
                  "path": "bamboostcli.widgets.table.CellEntry.__new__",
                  "signature": "(cls, column, value, width) -> CellEntry",
                  "description": null,
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "column",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "value",
                      "annotation": "Any",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "width",
                      "annotation": "int",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboostcli.widgets.table.CellEntry",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __new__(cls, column: str, value: Any, width: int) -> CellEntry:\n    # Cell formatting baased on the type of the value\n    if isinstance(value, np.datetime64):\n        # format the datetime\n        value = pd.to_datetime(value).strftime(\"%Y-%m-%d %H:%M:%S\")\n    elif isinstance(value, np.ndarray) and (value.size > 6 or value.ndim > 1):\n        value = f\"array {value.shape}\"\n\n    text = urwid.Text(str(value), wrap=\"ellipsis\")\n    text = urwid.AttrMap(text, column, column)\n    return super().__new__(cls, (\"fixed\", width, text))"
                }
              },
              "source": "class CellEntry(tuple):\n    def __new__(cls, column: str, value: Any, width: int) -> CellEntry:\n        # Cell formatting baased on the type of the value\n        if isinstance(value, np.datetime64):\n            # format the datetime\n            value = pd.to_datetime(value).strftime(\"%Y-%m-%d %H:%M:%S\")\n        elif isinstance(value, np.ndarray) and (value.size > 6 or value.ndim > 1):\n            value = f\"array {value.shape}\"\n\n        text = urwid.Text(str(value), wrap=\"ellipsis\")\n        text = urwid.AttrMap(text, column, column)\n        return super().__new__(cls, (\"fixed\", width, text))",
              "inherited_members": {}
            }
          },
          "functions": {}
        }
      },
      "classes": {},
      "functions": {}
    },
    "pages": {
      "name": "pages",
      "path": "bamboostcli.pages",
      "filepath": "/home/florez/work/code/hdftui/bamboostcli/pages/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "hdfview": {
          "name": "hdfview",
          "path": "bamboostcli.pages.hdfview",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/pages/hdfview.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "FOOTER",
              "annotation": null,
              "description": null,
              "value": "'q: Exit widget | Q: Quit app | ?: Keybindings | : Command | tab: Toggle focus'"
            }
          ],
          "modules": {},
          "classes": {
            "FocusedList": {
              "name": "FocusedList",
              "path": "bamboostcli.pages.hdfview.FocusedList",
              "description": "List box with a focused item even if the list is not in focus.",
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "render": {
                  "name": "render",
                  "path": "bamboostcli.pages.hdfview.FocusedList.render",
                  "signature": "(self, size, focus=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "focus",
                      "annotation": null,
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def render(self, size, focus=False):\n    return super().render(size, focus=True)"
                }
              },
              "source": "class FocusedList(urwid.ListBox):\n    \"\"\"List box with a focused item even if the list is not in focus.\"\"\"\n\n    def render(self, size, focus=False):\n        return super().render(size, focus=True)",
              "inherited_members": {}
            },
            "AttrsList": {
              "name": "AttrsList",
              "path": "bamboostcli.pages.hdfview.AttrsList",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "parent",
                  "annotation": "HDFView",
                  "description": null,
                  "value": null
                },
                {
                  "name": "attr_map",
                  "annotation": "dict",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "focus_map",
                  "annotation": "dict",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "parent",
                  "annotation": null,
                  "description": null,
                  "value": "parent"
                },
                {
                  "name": "attr_map",
                  "annotation": null,
                  "description": null,
                  "value": "attr_map"
                },
                {
                  "name": "focus_map",
                  "annotation": null,
                  "description": null,
                  "value": "focus_map"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.pages.hdfview.AttrsList.__init__",
                  "signature": "(self, parent, attr_map=None, focus_map=None)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "HDFView",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "attr_map",
                      "annotation": "dict",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "focus_map",
                      "annotation": "dict",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, parent: HDFView, attr_map: dict = None, focus_map: dict = None):\n    self.parent = parent\n    self.attr_map = attr_map\n    self.focus_map = focus_map"
                },
                "update": {
                  "name": "update",
                  "path": "bamboostcli.pages.hdfview.AttrsList.update",
                  "signature": "(self, key='')",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": "''"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def update(self, key: str = \"\"):\n    super().__init__(self._get_action_items(key), self.attr_map, self.focus_map)\n    return self"
                },
                "_get_action_items": {
                  "name": "_get_action_items",
                  "path": "bamboostcli.pages.hdfview.AttrsList._get_action_items",
                  "signature": "(self, key='')",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": "''"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_action_items(self, key: str = \"\"):\n    return [self.ActionItemPatched(i) for i in self.parent.get_attrs(key)]"
                }
              },
              "source": "class AttrsList(cw.cListBoxSelectionCharacter):\n    def __init__(self, parent: HDFView, attr_map: dict = None, focus_map: dict = None):\n        self.parent = parent\n        self.attr_map = attr_map\n        self.focus_map = focus_map\n\n    def update(self, key: str = \"\"):\n        super().__init__(self._get_action_items(key), self.attr_map, self.focus_map)\n        return self\n\n    def _get_action_items(self, key: str = \"\"):\n        return [self.ActionItemPatched(i) for i in self.parent.get_attrs(key)]\n\n    class ActionItemPatched(cw.cActionItem):\n        def rows(self, size, focus=False):\n            wide = size[0] > self.column_widths[0] * 1.8\n            self.widget = urwid.AttrMap(\n                urwid.Columns(\n                    [(\"fixed\", 1, SelectionIcon())]\n                    + [\n                        self._render_column(i, text, focus, wide)\n                        for i, text in enumerate(self.content)\n                    ],\n                    dividechars=1,\n                ),\n                self.column_attr_map,\n                self.column_focus_map,\n            )\n            return self.widget.rows(size, focus)\n\n        def render(self, size, focus=False):\n            return self.widget.render(size, focus)\n\n        def _render_column(self, i: int, text: str, focus: bool = False, wide: bool = False):\n            if i == 0 and self.column_widths and wide:\n                return (\"fixed\", self.column_widths[i], urwid.AttrMap(urwid.Text(text), i))\n\n            return (\"weight\", 1, urwid.AttrMap(urwid.Text(text), i))",
              "inherited_members": {
                "bamboostcli.widgets.custom_widgets.cListBox": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox._sizing"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.wrap"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.keymap_jk"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.keybinds"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox._navigate_down"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox._navigate_up"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.rows"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBox.focused_text"
                  }
                ],
                "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter": [
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter.keypress"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter._column_widths"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter._headers"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter._column_sizing"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter._column_align"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter._items"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter._always_in_focus"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter._listwalker"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter.items"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.custom_widgets.cListBoxSelectionCharacter.render"
                  }
                ]
              }
            },
            "HDFView": {
              "name": "HDFView",
              "path": "bamboostcli.pages.hdfview.HDFView",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "filename",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "filename",
                  "annotation": null,
                  "description": null,
                  "value": "filename"
                },
                {
                  "name": "_file_path",
                  "annotation": null,
                  "description": null,
                  "value": "os.path.abspath(filename)"
                },
                {
                  "name": "_current_dir",
                  "annotation": null,
                  "description": null,
                  "value": "[]"
                },
                {
                  "name": "_focus_stack",
                  "annotation": null,
                  "description": null,
                  "value": "[]"
                },
                {
                  "name": "current_dir_list",
                  "annotation": null,
                  "description": null,
                  "value": "FocusedList(urwid.SimpleFocusListWalker(self.get_items()))"
                },
                {
                  "name": "parent_dir_list",
                  "annotation": null,
                  "description": null,
                  "value": "FocusedList(urwid.SimpleFocusListWalker([]))"
                },
                {
                  "name": "preview",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.ListBox(urwid.SimpleListWalker([]))"
                },
                {
                  "name": "header",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Pile([urwid.AttrWrap(urwid.Text(self._file_path), 'bold'), urwid.Divider()])"
                },
                {
                  "name": "placehold_footer",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.AttrWrap(urwid.Text(FOOTER), 'footer')"
                },
                {
                  "name": "command_line",
                  "annotation": null,
                  "description": null,
                  "value": "CommandLine(ArgumentParser())"
                },
                {
                  "name": "navigator",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Columns([('weight', 1, self.current_dir_list), ('weight', 2, self.preview)], dividechars=2, focus_column=0)"
                },
                {
                  "name": "attrs_focused",
                  "annotation": null,
                  "description": null,
                  "value": "AttrsList(self, {0: '5', 1: '8'}, {0: '5-bold', 1: '8-bold'}).update(self.current_dir_list.focus.base_widget.get_text()[0])"
                },
                {
                  "name": "attrs_current_dir",
                  "annotation": null,
                  "description": null,
                  "value": "AttrsList(self, {0: '5', 1: '8'}, {0: '5-bold', 1: '8-bold'}).update()"
                },
                {
                  "name": "body",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Pile([('weight', 2, self.navigator), ('weight', 1.3, urwid.Columns([cRoundedLineBox(self.attrs_current_dir, title=f'Attributes of current directory', title_align='left', focus_map='5'), cRoundedLineBox(self.attrs_focused, title=f'Attributes of selected item', title_align='left', focus_map='5')]))])"
                },
                {
                  "name": "frame",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Frame(self.body, header=self.header, footer=self.placehold_footer, focus_part='body')"
                },
                {
                  "name": "keybinds",
                  "annotation": "Keybinds",
                  "description": null,
                  "value": "{'j': (self.navigate_down, 'Move focus down', ['ctrl n', 'down']), 'k': (self.navigate_up, 'Move focus up', ['ctrl p', 'up']), 'l': (self.navigate_enter, 'Enter directory', ['enter']), 'h': (self.navigate_exit, 'Exit directory', ['backspace']), 'q': (Caller.exit_widget, 'Exit', []), ':': (self.enter_command, 'Enter command', []), '?': (self.show_help, 'Show keybindings', []), 'tab': (self.move_focus, 'Move focus between widgets [forwards]', []), 'shift tab': (lambda: self.move_focus(backwards=True), 'Move focus between widgets [backwards]', []), 'd': (self.delete_focused, 'Delete focused item', [])}"
                },
                {
                  "name": "_keybinds",
                  "annotation": null,
                  "description": null,
                  "value": "{key: funcfor (key, (func, _, _)) in self.keybinds.items()}"
                },
                {
                  "name": "current_dir",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "parent_dir",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.pages.hdfview.HDFView.__init__",
                  "signature": "(self, filename) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "filename",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, filename: str) -> None:\n\n    self.filename = filename\n    self._file_path = os.path.abspath(filename)\n    self._current_dir = []\n    self._focus_stack = []\n\n    self.current_dir_list = FocusedList(urwid.SimpleFocusListWalker(self.get_items()))\n    self.parent_dir_list = FocusedList(urwid.SimpleFocusListWalker([]))\n    self.preview = urwid.ListBox(urwid.SimpleListWalker([]))\n\n    self.header = urwid.Pile(\n        [urwid.AttrWrap(urwid.Text(self._file_path), \"bold\"), urwid.Divider()]\n    )\n    self.placehold_footer = urwid.AttrWrap(urwid.Text(FOOTER), \"footer\")\n    self.command_line = CommandLine(ArgumentParser())\n\n    self.navigator = urwid.Columns(\n        [(\"weight\", 1, self.current_dir_list), (\"weight\", 2, self.preview)],\n        dividechars=2,\n        focus_column=0,\n    )\n    self.attrs_focused = AttrsList(self, {0: \"5\", 1: \"8\"}, {0: \"5-bold\", 1: \"8-bold\"}).update(\n        self.current_dir_list.focus.base_widget.get_text()[0]\n    )\n    self.attrs_current_dir = AttrsList(\n        self, {0: \"5\", 1: \"8\"}, {0: \"5-bold\", 1: \"8-bold\"}\n    ).update()\n\n    self.body = urwid.Pile(\n        [\n            (\"weight\", 2, self.navigator),\n            (\n                \"weight\",\n                1.3,\n                urwid.Columns(\n                    [\n                        cRoundedLineBox(\n                            self.attrs_current_dir,\n                            title=f\"Attributes of current directory\",\n                            title_align=\"left\",\n                            focus_map=\"5\",\n                        ),\n                        cRoundedLineBox(\n                            self.attrs_focused,\n                            title=f\"Attributes of selected item\",\n                            title_align=\"left\",\n                            focus_map=\"5\",\n                        ),\n                    ]\n                ),\n            ),\n        ],\n    )\n    self.frame = urwid.Frame(\n        self.body,\n        header=self.header,\n        footer=self.placehold_footer,\n        focus_part=\"body\",\n    )\n    super().__init__(self.command_line, self.frame)\n\n    # Add the keybindings\n    self.keybinds: Keybinds = {\n        \"j\": (self.navigate_down, \"Move focus down\", [\"ctrl n\", \"down\"]),\n        \"k\": (self.navigate_up, \"Move focus up\", [\"ctrl p\", \"up\"]),\n        \"l\": (self.navigate_enter, \"Enter directory\", [\"enter\"]),\n        \"h\": (self.navigate_exit, \"Exit directory\", [\"backspace\"]),\n        \"q\": (Caller.exit_widget, \"Exit\", []),\n        \":\": (self.enter_command, \"Enter command\", []),\n        \"?\": (self.show_help, \"Show keybindings\", []),\n        \"tab\": (self.move_focus, \"Move focus between widgets [forwards]\", []),\n        \"shift tab\": (\n            lambda: self.move_focus(backwards=True),\n            \"Move focus between widgets [backwards]\",\n            [],\n        ),\n        \"d\": (self.delete_focused, \"Delete focused item\", []),\n    }\n    self._keybinds = {key: func for key, (func, _, _) in self.keybinds.items()}\n    self._keybinds.update(\n        {alias: func for func, _, aliases in self.keybinds.values() for alias in aliases}\n    )\n\n    urwid.connect_signal(self.command_line, \"release_focus\", self.execute_command)"
                },
                "open_file": {
                  "name": "open_file",
                  "path": "bamboostcli.pages.hdfview.HDFView.open_file",
                  "signature": "(self, mode='r')",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "mode",
                      "annotation": "str",
                      "description": null,
                      "value": "'r'"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def open_file(self, mode: str = \"r\"):\n    return h5py.File(self._file_path, mode)"
                },
                "get_attrs": {
                  "name": "get_attrs",
                  "path": "bamboostcli.pages.hdfview.HDFView.get_attrs",
                  "signature": "(self, key)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_attrs(self, key: str):\n    with self.open_file(\"r\") as f:\n        attrs = f[f\"{self.current_dir}/{key}\"].attrs\n        if not attrs:\n            return [\"No attributes\"]\n        return [[str(i), str(j)] for i, j in attrs.items()]"
                },
                "get_items": {
                  "name": "get_items",
                  "path": "bamboostcli.pages.hdfview.HDFView.get_items",
                  "signature": "(self, dir=None)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dir",
                      "annotation": "str",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_items(self, dir: str = None):\n    if dir is None:\n        dir = self.current_dir\n\n    with self.open_file(\"r\") as f:\n        grp = f[dir]\n        if isinstance(grp, h5py.Group):\n            groups = (key for key in grp.keys() if isinstance(grp[key], h5py.Group))\n            datasets = (key for key in grp.keys() if isinstance(grp[key], h5py.Dataset))\n            g = [urwid.AttrWrap(urwid.Text(key), \"5\", \"5-reverse\") for key in groups]\n            d = [urwid.AttrWrap(urwid.Text(key), \"6\", \"6-reverse\") for key in datasets]\n            return g + d\n        elif isinstance(grp, h5py.Dataset):\n            return []\n        else:\n            return []"
                },
                "set_preview": {
                  "name": "set_preview",
                  "path": "bamboostcli.pages.hdfview.HDFView.set_preview",
                  "signature": "(self, key=None)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def set_preview(self, key: str = None):\n    if key is None:\n        key = self.current_dir_list.focus.base_widget.get_text()[0]\n\n    with self.open_file(\"r\") as f:\n        obj = f[f\"{self.current_dir}/{key}\"]\n        if isinstance(obj, h5py.Dataset):\n\n            if obj.dtype == \"O\":\n                # If the dataset is of type object, try displaying the string\n                # representation of the object\n                preview_data = urwid.Text(obj[()].decode(\"utf-8\"))\n            else:\n                # Assume it is a numeric dataset and display the first 20 rows\n                try:\n                    preview_data = urwid.Columns(\n                        [\n                            (\"fixed\", 9, urwid.Text(\"Preview:\")),\n                            urwid.Pile(\n                                [\n                                    *[\n                                        (\n                                            urwid.Columns(\n                                                [\n                                                    (\"fixed\", 7, urwid.Text(f\"{i:.3f}\"))\n                                                    for i in row\n                                                ]\n                                            )\n                                            if isinstance(row, np.ndarray)\n                                            else urwid.Text(f\"{row:.3f}\")\n                                        )\n                                        for row in obj[:20]\n                                    ],\n                                    (\n                                        urwid.Text(\"...\")\n                                        if obj.shape[0] > 20\n                                        else urwid.Text(\"\")\n                                    ),\n                                ]\n                            ),\n                        ]\n                    )\n                except:\n                    preview_data = urwid.Text(\n                        str(obj[:20]) + (\"...\" if obj.shape[0] > 20 else \"\")\n                    )\n\n            # Construct the preview list with the items\n            self.preview.body = urwid.SimpleListWalker(\n                [\n                    urwid.Text((\"6-bold\", f\"{self.current_dir}/{key}\"), wrap=\"clip\"),\n                    urwid.Divider(),\n                    urwid.Text(\n                        [\"Shape:   \", (\"bold\", f\"{obj.shape}\")],\n                        wrap=\"clip\",\n                    ),\n                    urwid.Text(\n                        [\"dtype:   \", (\"bold\", f\"{obj.dtype}\")],\n                        wrap=\"clip\",\n                    ),\n                    urwid.Divider(\"\\u2500\"),\n                    preview_data,\n                ]\n            )\n        elif isinstance(obj, h5py.Group):\n            children = self.get_items(f\"{self.current_dir}/{key}\")\n            self.preview.body = urwid.SimpleListWalker(\n                [\n                    urwid.Text((\"5-bold\", f\"{self.current_dir}/{key}\"), wrap=\"clip\"),\n                    urwid.Divider(),\n                    urwid.Pile(children) if children else urwid.Text(\"\"),\n                ]\n            )\n        else:\n            self.preview.body = urwid.SimpleListWalker([])"
                },
                "navigate_down": {
                  "name": "navigate_down",
                  "path": "bamboostcli.pages.hdfview.HDFView.navigate_down",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def navigate_down(self):\n    try:\n        self.current_dir_list.set_focus(self.current_dir_list.focus_position + 1)\n        self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n        self.set_preview()\n    except IndexError:\n        return"
                },
                "navigate_up": {
                  "name": "navigate_up",
                  "path": "bamboostcli.pages.hdfview.HDFView.navigate_up",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def navigate_up(self):\n    try:\n        self.current_dir_list.set_focus(self.current_dir_list.focus_position - 1)\n        self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n        self.set_preview()\n    except IndexError:\n        return"
                },
                "navigate_enter": {
                  "name": "navigate_enter",
                  "path": "bamboostcli.pages.hdfview.HDFView.navigate_enter",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def navigate_enter(self):\n    # If the group is empty, do nothing\n    # Or if the current item is a dataset, do nothing\n    with self.open_file(\"r\") as f:\n        obj = f[f\"{self.current_dir}/{self.current_dir_list.focus.base_widget.get_text()[0]}\"]\n        if isinstance(obj, h5py.Dataset) or not obj.keys():\n            return\n\n    self._current_dir.append(self.current_dir_list.focus.base_widget.get_text()[0])\n    self._focus_stack.append(self.current_dir_list.focus_position)\n\n    # Update the current directory list and the attributes list to reflect the new directory\n    self.current_dir_list.body = urwid.SimpleFocusListWalker(self.get_items())\n    self.current_dir_list.set_focus(0)\n    self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n\n    # Add parent dir list to navigator contents, if it doesn't exist\n    if len(self.navigator.contents) == 2:\n        self.navigator.contents.insert(0, (self.parent_dir_list, (\"weight\", 0.75, False)))\n\n    # Update the parent directory list and set the focus to the last focused item\n    self.parent_dir_list.body = urwid.SimpleFocusListWalker(self.get_items(self.parent_dir))\n    self.parent_dir_list.set_focus(self._focus_stack[-1])\n    self.set_preview()\n\n    # Set the attributes of the current directory\n    self.attrs_current_dir.update()"
                },
                "navigate_exit": {
                  "name": "navigate_exit",
                  "path": "bamboostcli.pages.hdfview.HDFView.navigate_exit",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def navigate_exit(self):\n    # If the current directory is the root, do nothing\n    if not self._current_dir:\n        return\n\n    self._current_dir.pop()\n    self.current_dir_list.body = urwid.SimpleFocusListWalker(self.get_items())\n    self.current_dir_list.set_focus(self._focus_stack.pop())\n\n    if not self._focus_stack:\n        self.parent_dir_list.body = urwid.SimpleFocusListWalker([])\n        self.navigator.contents.pop(0)  # remove parent dir list\n    else:\n        self.parent_dir_list.body = urwid.SimpleFocusListWalker(self.get_items(self.parent_dir))\n        self.parent_dir_list.set_focus(self._focus_stack[-1])\n\n    self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n    self.set_preview()\n\n    # Set the attributes of the current directory\n    self.attrs_current_dir.update()"
                },
                "show_help": {
                  "name": "show_help",
                  "path": "bamboostcli.pages.hdfview.HDFView.show_help",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def show_help(self):\n    if not hasattr(self, \"_help_widget\"):\n        self._help_widget = cKeybindsOverlay(Caller.main_loop, self.keybinds)\n    self._help_widget.toggle()"
                },
                "move_focus": {
                  "name": "move_focus",
                  "path": "bamboostcli.pages.hdfview.HDFView.move_focus",
                  "signature": "(self, backwards=False)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "backwards",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def move_focus(self, backwards: bool = False):\n    # if self.container.focus.focus == self.navigator:\n    pile = self.container.focus\n    if pile.focus_position == 0:\n        pile.focus_position = 1\n        pile.focus.focus_position = 0 if not backwards else 1\n        return\n    if pile.focus_position == 1:\n        if not backwards:\n            if pile.focus.focus_position == 0:\n                pile.focus.focus_position = 1\n            else:\n                pile.focus_position = 0\n        else:\n            if pile.focus.focus_position == 1:\n                pile.focus.focus_position = 0\n            else:\n                pile.focus_position = 0\n    return"
                },
                "delete_focused": {
                  "name": "delete_focused",
                  "path": "bamboostcli.pages.hdfview.HDFView.delete_focused",
                  "signature": "(self)",
                  "description": "Delete the focused item",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def delete_focused(self):\n    \"\"\"\n    Delete the focused item\n    \"\"\"\n    key = self.current_dir_list.focus.base_widget.get_text()[0]\n\n    def _delete() -> None:\n        with self.open_file(\"a\") as f:\n            del f[f\"{self.current_dir}/{key}\"]\n\n        _fp = self.current_dir_list.focus_position\n        self.current_dir_list.body = urwid.SimpleFocusListWalker(self.get_items())\n\n        try:\n            self.current_dir_list.set_focus(_fp - 1)\n        except IndexError:\n            pass  # leave at default position (0)\n\n        if self.current_dir_list.body:\n            self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n            self.set_preview()\n\n    ui = cw.cConfirmDialog(\n        Caller.main_loop,\n        f\"Are you sure you want to delete {self.current_dir}/{key}?\",\n        callback=_delete,\n    )\n    Caller.enter_widget(ui)"
                },
                "enter_command": {
                  "name": "enter_command",
                  "path": "bamboostcli.pages.hdfview.HDFView.enter_command",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def enter_command(self):\n    self.container.footer = self.command_line\n    self.command_line.edit_text = \"\"\n    self.container.set_focus(\"footer\")"
                },
                "execute_command": {
                  "name": "execute_command",
                  "path": "bamboostcli.pages.hdfview.HDFView.execute_command",
                  "signature": "(self, command=None) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "command",
                      "annotation": "str",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute_command(self, command: str = None) -> None:\n    if command == \"q\":\n        Caller.exit_widget()\n    else:\n        self.container.footer = self.placehold_footer\n        self.container.set_focus(\"body\")"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.pages.hdfview.HDFView.keypress",
                  "signature": "(self, size, key) -> str | None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str | None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n    if self.container.focus_part == \"footer\":\n        return self.container.footer.keypress(size, key)\n\n    if key not in {\"tab\", \"shift tab\", \"?\", \"q\"} and self.container.focus.focus_position != 0:\n        if self.container.focus.focus.focus_position == 0:\n            self.attrs_current_dir.keypress((1, 1), key)\n        else:\n            self.attrs_focused.keypress((1, 1), key)\n        return\n    if key in self._keybinds and self.container.focus_part == \"body\":\n        self._keybinds[key]()\n    else:\n        return self.container.keypress(size, key)"
                }
              },
              "source": "class HDFView(AutocompleteContainer):\n\n    def __init__(self, filename: str) -> None:\n\n        self.filename = filename\n        self._file_path = os.path.abspath(filename)\n        self._current_dir = []\n        self._focus_stack = []\n\n        self.current_dir_list = FocusedList(urwid.SimpleFocusListWalker(self.get_items()))\n        self.parent_dir_list = FocusedList(urwid.SimpleFocusListWalker([]))\n        self.preview = urwid.ListBox(urwid.SimpleListWalker([]))\n\n        self.header = urwid.Pile(\n            [urwid.AttrWrap(urwid.Text(self._file_path), \"bold\"), urwid.Divider()]\n        )\n        self.placehold_footer = urwid.AttrWrap(urwid.Text(FOOTER), \"footer\")\n        self.command_line = CommandLine(ArgumentParser())\n\n        self.navigator = urwid.Columns(\n            [(\"weight\", 1, self.current_dir_list), (\"weight\", 2, self.preview)],\n            dividechars=2,\n            focus_column=0,\n        )\n        self.attrs_focused = AttrsList(self, {0: \"5\", 1: \"8\"}, {0: \"5-bold\", 1: \"8-bold\"}).update(\n            self.current_dir_list.focus.base_widget.get_text()[0]\n        )\n        self.attrs_current_dir = AttrsList(\n            self, {0: \"5\", 1: \"8\"}, {0: \"5-bold\", 1: \"8-bold\"}\n        ).update()\n\n        self.body = urwid.Pile(\n            [\n                (\"weight\", 2, self.navigator),\n                (\n                    \"weight\",\n                    1.3,\n                    urwid.Columns(\n                        [\n                            cRoundedLineBox(\n                                self.attrs_current_dir,\n                                title=f\"Attributes of current directory\",\n                                title_align=\"left\",\n                                focus_map=\"5\",\n                            ),\n                            cRoundedLineBox(\n                                self.attrs_focused,\n                                title=f\"Attributes of selected item\",\n                                title_align=\"left\",\n                                focus_map=\"5\",\n                            ),\n                        ]\n                    ),\n                ),\n            ],\n        )\n        self.frame = urwid.Frame(\n            self.body,\n            header=self.header,\n            footer=self.placehold_footer,\n            focus_part=\"body\",\n        )\n        super().__init__(self.command_line, self.frame)\n\n        # Add the keybindings\n        self.keybinds: Keybinds = {\n            \"j\": (self.navigate_down, \"Move focus down\", [\"ctrl n\", \"down\"]),\n            \"k\": (self.navigate_up, \"Move focus up\", [\"ctrl p\", \"up\"]),\n            \"l\": (self.navigate_enter, \"Enter directory\", [\"enter\"]),\n            \"h\": (self.navigate_exit, \"Exit directory\", [\"backspace\"]),\n            \"q\": (Caller.exit_widget, \"Exit\", []),\n            \":\": (self.enter_command, \"Enter command\", []),\n            \"?\": (self.show_help, \"Show keybindings\", []),\n            \"tab\": (self.move_focus, \"Move focus between widgets [forwards]\", []),\n            \"shift tab\": (\n                lambda: self.move_focus(backwards=True),\n                \"Move focus between widgets [backwards]\",\n                [],\n            ),\n            \"d\": (self.delete_focused, \"Delete focused item\", []),\n        }\n        self._keybinds = {key: func for key, (func, _, _) in self.keybinds.items()}\n        self._keybinds.update(\n            {alias: func for func, _, aliases in self.keybinds.values() for alias in aliases}\n        )\n\n        urwid.connect_signal(self.command_line, \"release_focus\", self.execute_command)\n\n    def open_file(self, mode: str = \"r\"):\n        return h5py.File(self._file_path, mode)\n\n    @property\n    def current_dir(self):\n        if not self._current_dir:\n            return \"/\"\n        return \"/\" + \"/\".join(self._current_dir)\n\n    @property\n    def parent_dir(self):\n        if len(self._current_dir) <= 1:\n            return \"/\"\n        return \"/\" + \"/\".join(self._current_dir[:-1])\n\n    def get_attrs(self, key: str):\n        with self.open_file(\"r\") as f:\n            attrs = f[f\"{self.current_dir}/{key}\"].attrs\n            if not attrs:\n                return [\"No attributes\"]\n            return [[str(i), str(j)] for i, j in attrs.items()]\n\n    def get_items(self, dir: str = None):\n        if dir is None:\n            dir = self.current_dir\n\n        with self.open_file(\"r\") as f:\n            grp = f[dir]\n            if isinstance(grp, h5py.Group):\n                groups = (key for key in grp.keys() if isinstance(grp[key], h5py.Group))\n                datasets = (key for key in grp.keys() if isinstance(grp[key], h5py.Dataset))\n                g = [urwid.AttrWrap(urwid.Text(key), \"5\", \"5-reverse\") for key in groups]\n                d = [urwid.AttrWrap(urwid.Text(key), \"6\", \"6-reverse\") for key in datasets]\n                return g + d\n            elif isinstance(grp, h5py.Dataset):\n                return []\n            else:\n                return []\n\n    def set_preview(self, key: str = None):\n        if key is None:\n            key = self.current_dir_list.focus.base_widget.get_text()[0]\n\n        with self.open_file(\"r\") as f:\n            obj = f[f\"{self.current_dir}/{key}\"]\n            if isinstance(obj, h5py.Dataset):\n\n                if obj.dtype == \"O\":\n                    # If the dataset is of type object, try displaying the string\n                    # representation of the object\n                    preview_data = urwid.Text(obj[()].decode(\"utf-8\"))\n                else:\n                    # Assume it is a numeric dataset and display the first 20 rows\n                    try:\n                        preview_data = urwid.Columns(\n                            [\n                                (\"fixed\", 9, urwid.Text(\"Preview:\")),\n                                urwid.Pile(\n                                    [\n                                        *[\n                                            (\n                                                urwid.Columns(\n                                                    [\n                                                        (\"fixed\", 7, urwid.Text(f\"{i:.3f}\"))\n                                                        for i in row\n                                                    ]\n                                                )\n                                                if isinstance(row, np.ndarray)\n                                                else urwid.Text(f\"{row:.3f}\")\n                                            )\n                                            for row in obj[:20]\n                                        ],\n                                        (\n                                            urwid.Text(\"...\")\n                                            if obj.shape[0] > 20\n                                            else urwid.Text(\"\")\n                                        ),\n                                    ]\n                                ),\n                            ]\n                        )\n                    except:\n                        preview_data = urwid.Text(\n                            str(obj[:20]) + (\"...\" if obj.shape[0] > 20 else \"\")\n                        )\n\n                # Construct the preview list with the items\n                self.preview.body = urwid.SimpleListWalker(\n                    [\n                        urwid.Text((\"6-bold\", f\"{self.current_dir}/{key}\"), wrap=\"clip\"),\n                        urwid.Divider(),\n                        urwid.Text(\n                            [\"Shape:   \", (\"bold\", f\"{obj.shape}\")],\n                            wrap=\"clip\",\n                        ),\n                        urwid.Text(\n                            [\"dtype:   \", (\"bold\", f\"{obj.dtype}\")],\n                            wrap=\"clip\",\n                        ),\n                        urwid.Divider(\"\\u2500\"),\n                        preview_data,\n                    ]\n                )\n            elif isinstance(obj, h5py.Group):\n                children = self.get_items(f\"{self.current_dir}/{key}\")\n                self.preview.body = urwid.SimpleListWalker(\n                    [\n                        urwid.Text((\"5-bold\", f\"{self.current_dir}/{key}\"), wrap=\"clip\"),\n                        urwid.Divider(),\n                        urwid.Pile(children) if children else urwid.Text(\"\"),\n                    ]\n                )\n            else:\n                self.preview.body = urwid.SimpleListWalker([])\n\n    def navigate_down(self):\n        try:\n            self.current_dir_list.set_focus(self.current_dir_list.focus_position + 1)\n            self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n            self.set_preview()\n        except IndexError:\n            return\n\n    def navigate_up(self):\n        try:\n            self.current_dir_list.set_focus(self.current_dir_list.focus_position - 1)\n            self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n            self.set_preview()\n        except IndexError:\n            return\n\n    def navigate_enter(self):\n        # If the group is empty, do nothing\n        # Or if the current item is a dataset, do nothing\n        with self.open_file(\"r\") as f:\n            obj = f[f\"{self.current_dir}/{self.current_dir_list.focus.base_widget.get_text()[0]}\"]\n            if isinstance(obj, h5py.Dataset) or not obj.keys():\n                return\n\n        self._current_dir.append(self.current_dir_list.focus.base_widget.get_text()[0])\n        self._focus_stack.append(self.current_dir_list.focus_position)\n\n        # Update the current directory list and the attributes list to reflect the new directory\n        self.current_dir_list.body = urwid.SimpleFocusListWalker(self.get_items())\n        self.current_dir_list.set_focus(0)\n        self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n\n        # Add parent dir list to navigator contents, if it doesn't exist\n        if len(self.navigator.contents) == 2:\n            self.navigator.contents.insert(0, (self.parent_dir_list, (\"weight\", 0.75, False)))\n\n        # Update the parent directory list and set the focus to the last focused item\n        self.parent_dir_list.body = urwid.SimpleFocusListWalker(self.get_items(self.parent_dir))\n        self.parent_dir_list.set_focus(self._focus_stack[-1])\n        self.set_preview()\n\n        # Set the attributes of the current directory\n        self.attrs_current_dir.update()\n\n    def navigate_exit(self):\n        # If the current directory is the root, do nothing\n        if not self._current_dir:\n            return\n\n        self._current_dir.pop()\n        self.current_dir_list.body = urwid.SimpleFocusListWalker(self.get_items())\n        self.current_dir_list.set_focus(self._focus_stack.pop())\n\n        if not self._focus_stack:\n            self.parent_dir_list.body = urwid.SimpleFocusListWalker([])\n            self.navigator.contents.pop(0)  # remove parent dir list\n        else:\n            self.parent_dir_list.body = urwid.SimpleFocusListWalker(self.get_items(self.parent_dir))\n            self.parent_dir_list.set_focus(self._focus_stack[-1])\n\n        self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n        self.set_preview()\n\n        # Set the attributes of the current directory\n        self.attrs_current_dir.update()\n\n    def show_help(self):\n        if not hasattr(self, \"_help_widget\"):\n            self._help_widget = cKeybindsOverlay(Caller.main_loop, self.keybinds)\n        self._help_widget.toggle()\n\n    def move_focus(self, backwards: bool = False):\n        # if self.container.focus.focus == self.navigator:\n        pile = self.container.focus\n        if pile.focus_position == 0:\n            pile.focus_position = 1\n            pile.focus.focus_position = 0 if not backwards else 1\n            return\n        if pile.focus_position == 1:\n            if not backwards:\n                if pile.focus.focus_position == 0:\n                    pile.focus.focus_position = 1\n                else:\n                    pile.focus_position = 0\n            else:\n                if pile.focus.focus_position == 1:\n                    pile.focus.focus_position = 0\n                else:\n                    pile.focus_position = 0\n        return\n\n    def delete_focused(self):\n        \"\"\"\n        Delete the focused item\n        \"\"\"\n        key = self.current_dir_list.focus.base_widget.get_text()[0]\n\n        def _delete() -> None:\n            with self.open_file(\"a\") as f:\n                del f[f\"{self.current_dir}/{key}\"]\n\n            _fp = self.current_dir_list.focus_position\n            self.current_dir_list.body = urwid.SimpleFocusListWalker(self.get_items())\n\n            try:\n                self.current_dir_list.set_focus(_fp - 1)\n            except IndexError:\n                pass  # leave at default position (0)\n\n            if self.current_dir_list.body:\n                self.attrs_focused.update(self.current_dir_list.focus.base_widget.get_text()[0])\n                self.set_preview()\n\n        ui = cw.cConfirmDialog(\n            Caller.main_loop,\n            f\"Are you sure you want to delete {self.current_dir}/{key}?\",\n            callback=_delete,\n        )\n        Caller.enter_widget(ui)\n\n    def enter_command(self):\n        self.container.footer = self.command_line\n        self.command_line.edit_text = \"\"\n        self.container.set_focus(\"footer\")\n\n    def execute_command(self, command: str = None) -> None:\n        if command == \"q\":\n            Caller.exit_widget()\n        else:\n            self.container.footer = self.placehold_footer\n            self.container.set_focus(\"body\")\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        if self.container.focus_part == \"footer\":\n            return self.container.footer.keypress(size, key)\n\n        if key not in {\"tab\", \"shift tab\", \"?\", \"q\"} and self.container.focus.focus_position != 0:\n            if self.container.focus.focus.focus_position == 0:\n                self.attrs_current_dir.keypress((1, 1), key)\n            else:\n                self.attrs_focused.keypress((1, 1), key)\n            return\n        if key in self._keybinds and self.container.focus_part == \"body\":\n            self._keybinds[key]()\n        else:\n            return self.container.keypress(size, key)",
              "inherited_members": {
                "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer.edit"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer.container"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer.render"
                  }
                ]
              }
            }
          },
          "functions": {
            "main": {
              "name": "main",
              "path": "bamboostcli.pages.hdfview.main",
              "signature": "()",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def main():\n    import sys\n\n    if len(sys.argv) != 2:\n        print(\"Usage: hdfview <filename>\")\n        sys.exit(1)\n    filename = sys.argv[1]\n\n    main_widget = HDFView(filename)\n    Caller.main_loop = urwid.MainLoop(urwid.Pile([]), palette)\n    Caller.main_loop.widget = main_widget\n    Caller.main_loop.screen.set_terminal_properties(colors=256)\n    Caller.widget_stack.append(main_widget)\n    Caller.main_loop.run()"
            }
          }
        },
        "welcome": {
          "name": "welcome",
          "path": "bamboostcli.pages.welcome",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/pages/welcome.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "FOOTER",
              "annotation": null,
              "description": null,
              "value": "urwid.AttrWrap(urwid.Text('q: Exit widget | Q: Quit app | enter: Enter | ?: Keybindings', align='left'), 'footer')"
            }
          ],
          "modules": {},
          "classes": {
            "WelcomeUI": {
              "name": "WelcomeUI",
              "path": "bamboostcli.pages.welcome.WelcomeUI",
              "description": "Welcome screen of the app. Displays a figlet logo and a list of options to choose from.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "welcome",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.AttrMap(urwid.Text(FIGLET, align='center', wrap='clip'), '8')"
                },
                {
                  "name": "listbox",
                  "annotation": null,
                  "description": null,
                  "value": "cListBoxSelectionCharacter([cActionItem(['Index', 'Show all known databases and enter selected'], callback=self._cb_load_index), cActionItem(['Remote', 'Show index of remote databases'], callback=self._cb_load_remote), cActionItem(['Scan paths', 'Scan specified paths in config file for new databases'], callback=self._cb_scan), cActionItem(['Change config', 'Open the config file in default editor'], callback=self._cb_open_config), cActionItem(['Exit', 'Quit the app'], callback=self._cb_exit)], attr_map={0: '5', 1: 'default'}, focus_map={0: '5-bold', 1: 'bold'})"
                },
                {
                  "name": "frame",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Frame(urwid.Pile([('weight', 1, urwid.Filler(self.welcome, valign='bottom', bottom=4)), ('pack', urwid.Filler(urwid.Padding(self.listbox, width=('relative', 1), min_width=sum(self.listbox._column_widths.values()) + 5, align='center'), valign='bottom', height=len(self.listbox.items))), ('weight', 1, urwid.Filler(urwid.Text(('9', 'developed with \u2764 \\n2024, Flavio Lorez and contributors\\nhttps://gitlab.com/cmbm-ethz/bamboost'), align='center'), valign='middle'))]), footer=FOOTER)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.pages.welcome.WelcomeUI.__init__",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self) -> None:\n    self.welcome = urwid.AttrMap(urwid.Text(FIGLET, align=\"center\", wrap=\"clip\"), \"8\")\n    self.listbox = cListBoxSelectionCharacter(\n        [\n            cActionItem(\n                [\"Index\", \"Show all known databases and enter selected\"],\n                callback=self._cb_load_index,\n            ),\n            cActionItem(\n                [\"Remote\", \"Show index of remote databases\"],\n                callback=self._cb_load_remote,\n            ),\n            cActionItem(\n                [\"Scan paths\", \"Scan specified paths in config file for new databases\"],\n                callback=self._cb_scan,\n            ),\n            cActionItem(\n                [\"Change config\", \"Open the config file in default editor\"],\n                callback=self._cb_open_config,\n            ),\n            cActionItem([\"Exit\", \"Quit the app\"], callback=self._cb_exit),\n        ],\n        attr_map={0: \"5\", 1: \"default\"},\n        focus_map={0: \"5-bold\", 1: \"bold\"},\n    )\n    self.frame = urwid.Frame(\n        urwid.Pile(\n            [\n                (\"weight\", 1, urwid.Filler(self.welcome, valign=\"bottom\", bottom=4)),\n                (\n                    \"pack\",\n                    urwid.Filler(\n                        urwid.Padding(\n                            self.listbox,\n                            width=(\"relative\", 1),\n                            min_width=sum(self.listbox._column_widths.values()) + 5,\n                            align=\"center\",\n                        ),\n                        valign=\"bottom\",\n                        height=len(self.listbox.items),\n                    ),\n                ),\n                (\n                    \"weight\",\n                    1,\n                    urwid.Filler(\n                        urwid.Text(\n                            (\n                                \"9\",\n                                (\n                                    \"developed with \u2764 \\n\"\n                                    \"2024, Flavio Lorez and contributors\\n\"\n                                    \"https://gitlab.com/cmbm-ethz/bamboost\"\n                                ),\n                            ),\n                            align=\"center\",\n                        ),\n                        valign=\"middle\",\n                    ),\n                ),\n            ]\n        ),\n        footer=FOOTER,\n    )"
                },
                "_set_footer": {
                  "name": "_set_footer",
                  "path": "bamboostcli.pages.welcome.WelcomeUI._set_footer",
                  "signature": "(self, text)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "text",
                      "annotation": "Union",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _set_footer(self, text: Union[str, urwid.Widget]):\n    if isinstance(text, str):\n        self.frame.footer = urwid.AttrWrap(urwid.Text(text, align=\"left\"), \"footer\")\n    else:\n        self.frame.footer = text"
                },
                "_cb_load_index": {
                  "name": "_cb_load_index",
                  "path": "bamboostcli.pages.welcome.WelcomeUI._cb_load_index",
                  "signature": "(self, *args)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _cb_load_index(self, *args):\n    def inner():\n        with Spinner(align=\"left\", caption=\"Loading index \") as spinner:\n            self._set_footer(spinner)\n            ui = Index(\n                index.IndexAPI.ThreadSafe().read_table().set_index(\"id\").to_dict()[\"path\"]\n            )\n            overlay = urwid.Overlay(\n                cRoundedLineBox(ui, title=\"Bamboost Index\", title_align=\"left\", focus_map=\"8\"),\n                Caller.main_loop.widget.base_widget,\n                align=\"center\",\n                width=200,\n                valign=\"middle\",\n                height=30,\n            )\n\n        self._set_footer(FOOTER)\n        Caller.enter_widget(overlay)\n\n    threading.Thread(target=inner).start()"
                },
                "_cb_load_remote": {
                  "name": "_cb_load_remote",
                  "path": "bamboostcli.pages.welcome.WelcomeUI._cb_load_remote",
                  "signature": "(self, item)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "item",
                      "annotation": "cActionItem",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _cb_load_remote(self, item: cActionItem):\n    def open_remote_index(remote: Union[str, cActionItem]):\n        remote_name = remote if isinstance(remote, str) else remote.content[0]\n\n        def inner():\n            with Spinner(caption=\"Loading remote index \") as spinner:\n                self._set_footer(spinner)\n                ui = IndexRemote(remote=Remote(remote_name, skip_update=True))\n                overlay = urwid.Overlay(\n                    cRoundedLineBox(\n                        ui,\n                        title=f\"Bamboost Index - {remote_name} | ctrl r: download index\",\n                        focus_map=\"5\",\n                    ),\n                    Caller.main_loop.widget.base_widget,\n                    align=\"center\",\n                    width=200,\n                    valign=\"middle\",\n                    height=30,\n                )\n\n            self._set_footer(FOOTER)\n            Caller.enter_widget(overlay)\n\n        threading.Thread(target=inner).start()\n\n    # edit = urwid.Filler(cEdit(callback=open_remote_index))\n    # ui = cPopup(\n    #     edit,\n    #     title=\"Enter remote\",\n    #     align=\"center\",\n    #     width=(\"relative\", 80),\n    #     valign=\"middle\",\n    #     height=1,\n    # )\n    listbox = cListBoxSelectionCharacter(\n        [cActionItem([name], callback=open_remote_index) for name in Remote.list()],\n        attr_map={0: \"5\"},\n        focus_map={0: \"5-bold\"},\n    )\n    ui = cPopup(\n        listbox,\n        title=\"Select remote\",\n        align=\"center\",\n        width=(\"relative\", 80),\n        valign=\"middle\",\n        height=len(listbox),\n    )\n    Caller.enter_widget(ui)"
                },
                "_cb_scan": {
                  "name": "_cb_scan",
                  "path": "bamboostcli.pages.welcome.WelcomeUI._cb_scan",
                  "signature": "(self, *args)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _cb_scan(self, *args):\n    def inner() -> None:\n        with Spinner(caption=\"Scanning paths \") as spinner:\n            self._set_footer(spinner)\n            index.IndexAPI.ThreadSafe().scan_known_paths()\n\n        self._set_footer(\"Paths scanned successfully\")\n\n    threading.Thread(target=inner).start()"
                },
                "_cb_open_config": {
                  "name": "_cb_open_config",
                  "path": "bamboostcli.pages.welcome.WelcomeUI._cb_open_config",
                  "signature": "(self, *args)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _cb_open_config(self, *args):\n    editor = os.environ.get(\"EDITOR\", \"vim\")\n    home = os.path.expanduser(\"~\")\n    subprocess.run(\n        [editor, os.path.join(home, \".config\", \"bamboost\", \"config.toml\")],\n    )\n    Caller.main_loop.screen.clear()"
                },
                "_cb_direct_access": {
                  "name": "_cb_direct_access",
                  "path": "bamboostcli.pages.welcome.WelcomeUI._cb_direct_access",
                  "signature": "(self, *args)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _cb_direct_access(self, *args):\n    ui = DirectAccess()\n    Caller.enter_widget(ui)"
                },
                "_cb_exit": {
                  "name": "_cb_exit",
                  "path": "bamboostcli.pages.welcome.WelcomeUI._cb_exit",
                  "signature": "(self, *args)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _cb_exit(self, *args):\n    raise urwid.ExitMainLoop()"
                }
              },
              "source": "class WelcomeUI:\n    \"\"\"\n    Welcome screen of the app. Displays a figlet logo and a list of options to choose from.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.welcome = urwid.AttrMap(urwid.Text(FIGLET, align=\"center\", wrap=\"clip\"), \"8\")\n        self.listbox = cListBoxSelectionCharacter(\n            [\n                cActionItem(\n                    [\"Index\", \"Show all known databases and enter selected\"],\n                    callback=self._cb_load_index,\n                ),\n                cActionItem(\n                    [\"Remote\", \"Show index of remote databases\"],\n                    callback=self._cb_load_remote,\n                ),\n                cActionItem(\n                    [\"Scan paths\", \"Scan specified paths in config file for new databases\"],\n                    callback=self._cb_scan,\n                ),\n                cActionItem(\n                    [\"Change config\", \"Open the config file in default editor\"],\n                    callback=self._cb_open_config,\n                ),\n                cActionItem([\"Exit\", \"Quit the app\"], callback=self._cb_exit),\n            ],\n            attr_map={0: \"5\", 1: \"default\"},\n            focus_map={0: \"5-bold\", 1: \"bold\"},\n        )\n        self.frame = urwid.Frame(\n            urwid.Pile(\n                [\n                    (\"weight\", 1, urwid.Filler(self.welcome, valign=\"bottom\", bottom=4)),\n                    (\n                        \"pack\",\n                        urwid.Filler(\n                            urwid.Padding(\n                                self.listbox,\n                                width=(\"relative\", 1),\n                                min_width=sum(self.listbox._column_widths.values()) + 5,\n                                align=\"center\",\n                            ),\n                            valign=\"bottom\",\n                            height=len(self.listbox.items),\n                        ),\n                    ),\n                    (\n                        \"weight\",\n                        1,\n                        urwid.Filler(\n                            urwid.Text(\n                                (\n                                    \"9\",\n                                    (\n                                        \"developed with \u2764 \\n\"\n                                        \"2024, Flavio Lorez and contributors\\n\"\n                                        \"https://gitlab.com/cmbm-ethz/bamboost\"\n                                    ),\n                                ),\n                                align=\"center\",\n                            ),\n                            valign=\"middle\",\n                        ),\n                    ),\n                ]\n            ),\n            footer=FOOTER,\n        )\n\n    def _set_footer(self, text: Union[str, urwid.Widget]):\n        if isinstance(text, str):\n            self.frame.footer = urwid.AttrWrap(urwid.Text(text, align=\"left\"), \"footer\")\n        else:\n            self.frame.footer = text\n\n    # ------------------\n    # Callback functions\n    # ------------------\n    def _cb_load_index(self, *args):\n        def inner():\n            with Spinner(align=\"left\", caption=\"Loading index \") as spinner:\n                self._set_footer(spinner)\n                ui = Index(\n                    index.IndexAPI.ThreadSafe().read_table().set_index(\"id\").to_dict()[\"path\"]\n                )\n                overlay = urwid.Overlay(\n                    cRoundedLineBox(ui, title=\"Bamboost Index\", title_align=\"left\", focus_map=\"8\"),\n                    Caller.main_loop.widget.base_widget,\n                    align=\"center\",\n                    width=200,\n                    valign=\"middle\",\n                    height=30,\n                )\n\n            self._set_footer(FOOTER)\n            Caller.enter_widget(overlay)\n\n        threading.Thread(target=inner).start()\n\n    def _cb_load_remote(self, item: cActionItem):\n        def open_remote_index(remote: Union[str, cActionItem]):\n            remote_name = remote if isinstance(remote, str) else remote.content[0]\n\n            def inner():\n                with Spinner(caption=\"Loading remote index \") as spinner:\n                    self._set_footer(spinner)\n                    ui = IndexRemote(remote=Remote(remote_name, skip_update=True))\n                    overlay = urwid.Overlay(\n                        cRoundedLineBox(\n                            ui,\n                            title=f\"Bamboost Index - {remote_name} | ctrl r: download index\",\n                            focus_map=\"5\",\n                        ),\n                        Caller.main_loop.widget.base_widget,\n                        align=\"center\",\n                        width=200,\n                        valign=\"middle\",\n                        height=30,\n                    )\n\n                self._set_footer(FOOTER)\n                Caller.enter_widget(overlay)\n\n            threading.Thread(target=inner).start()\n\n        # edit = urwid.Filler(cEdit(callback=open_remote_index))\n        # ui = cPopup(\n        #     edit,\n        #     title=\"Enter remote\",\n        #     align=\"center\",\n        #     width=(\"relative\", 80),\n        #     valign=\"middle\",\n        #     height=1,\n        # )\n        listbox = cListBoxSelectionCharacter(\n            [cActionItem([name], callback=open_remote_index) for name in Remote.list()],\n            attr_map={0: \"5\"},\n            focus_map={0: \"5-bold\"},\n        )\n        ui = cPopup(\n            listbox,\n            title=\"Select remote\",\n            align=\"center\",\n            width=(\"relative\", 80),\n            valign=\"middle\",\n            height=len(listbox),\n        )\n        Caller.enter_widget(ui)\n\n    def _cb_scan(self, *args):\n        def inner() -> None:\n            with Spinner(caption=\"Scanning paths \") as spinner:\n                self._set_footer(spinner)\n                index.IndexAPI.ThreadSafe().scan_known_paths()\n\n            self._set_footer(\"Paths scanned successfully\")\n\n        threading.Thread(target=inner).start()\n\n    def _cb_open_config(self, *args):\n        editor = os.environ.get(\"EDITOR\", \"vim\")\n        home = os.path.expanduser(\"~\")\n        subprocess.run(\n            [editor, os.path.join(home, \".config\", \"bamboost\", \"config.toml\")],\n        )\n        Caller.main_loop.screen.clear()\n\n    def _cb_direct_access(self, *args):\n        ui = DirectAccess()\n        Caller.enter_widget(ui)\n\n    def _cb_exit(self, *args):\n        raise urwid.ExitMainLoop()",
              "inherited_members": {}
            },
            "DirectAccess": {
              "name": "DirectAccess",
              "path": "bamboostcli.pages.welcome.DirectAccess",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "parser",
                  "annotation": null,
                  "description": null,
                  "value": "ArgumentParser()"
                },
                {
                  "name": "edit",
                  "annotation": null,
                  "description": null,
                  "value": "self.CustomCommandLine(self.parser)"
                },
                {
                  "name": "overlay",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Overlay(cRoundedLineBox(self.edit, title='Enter Simulation UID', focus_map='8'), Caller.main_loop.widget, align='center', width=100, valign='middle', height=3)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.pages.welcome.DirectAccess.__init__",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self) -> None:\n    self.parser = ArgumentParser()\n    self.edit = self.CustomCommandLine(self.parser)\n\n    self.overlay = urwid.Overlay(\n        cRoundedLineBox(self.edit, title=\"Enter Simulation UID\", focus_map=\"8\"),\n        Caller.main_loop.widget,\n        align=\"center\",\n        width=100,\n        valign=\"middle\",\n        height=3,\n    )\n\n    urwid.connect_signal(self.edit, \"execute_command\", self.execute_command)\n\n    super().__init__(self.edit, self.overlay)"
                },
                "execute_command": {
                  "name": "execute_command",
                  "path": "bamboostcli.pages.welcome.DirectAccess.execute_command",
                  "signature": "(self, command)",
                  "description": "Open the hdf file with the given UID",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "command",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute_command(self, command):\n    \"\"\"\n    Open the hdf file with the given UID\n    \"\"\"\n    show_error = lambda: self.edit.set_caption((\"2\", \"Invalid UID - \"))\n    if command.split(\":\")[0] not in self.parser.db_ids:\n        show_error()\n        return\n\n    try:\n        sim_file = Simulation.fromUID(command).h5file\n    except (ValueError, FileNotFoundError):\n        show_error()\n        return\n\n    widget = HDFView(sim_file)\n    Caller.enter_widget(widget)"
                }
              },
              "source": "class DirectAccess(AutocompleteContainer):\n    class CustomCommandLine(CommandLine):\n        def keypress(self, size, key):\n            if key == \"tab\":\n                if not self.show_popup:\n                    return None\n                new_text = self.popup.get_focus()[0].base_widget.text\n                self.edit_text = \":\".join(re.split(r\"\\:+\", self.edit_text)[:-1] + [new_text])\n                if len(self.edit_text.split(\":\")) <= 1:\n                    self.edit_text += \":\"\n                self.edit_pos = len(self.edit_text)\n                self.suggestions = self.parser.current_suggestions(self.edit_text)\n                return\n\n            if key == \"meta backspace\":\n                # Logic to delete the word before the cursor until : or start of the line\n                new_pos = (\n                    self.edit_text.rfind(\":\", 0, self.edit_pos - 1) + 1 if self.edit_pos > 0 else 0\n                )\n                new_text = self.edit_text[:new_pos] + self.edit_text[self.edit_pos :]\n                self.set_edit_text(new_text)\n                self.set_edit_pos(new_pos)\n                return\n\n            self.set_caption((\"3\", \"Evaluating... \"))\n\n            return super().keypress(size, key)\n\n    def __init__(self) -> None:\n        self.parser = ArgumentParser()\n        self.edit = self.CustomCommandLine(self.parser)\n\n        self.overlay = urwid.Overlay(\n            cRoundedLineBox(self.edit, title=\"Enter Simulation UID\", focus_map=\"8\"),\n            Caller.main_loop.widget,\n            align=\"center\",\n            width=100,\n            valign=\"middle\",\n            height=3,\n        )\n\n        urwid.connect_signal(self.edit, \"execute_command\", self.execute_command)\n\n        super().__init__(self.edit, self.overlay)\n\n    def execute_command(self, command):\n        \"\"\"\n        Open the hdf file with the given UID\n        \"\"\"\n        show_error = lambda: self.edit.set_caption((\"2\", \"Invalid UID - \"))\n        if command.split(\":\")[0] not in self.parser.db_ids:\n            show_error()\n            return\n\n        try:\n            sim_file = Simulation.fromUID(command).h5file\n        except (ValueError, FileNotFoundError):\n            show_error()\n            return\n\n        widget = HDFView(sim_file)\n        Caller.enter_widget(widget)",
              "inherited_members": {
                "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer.container"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer.render"
                  }
                ]
              }
            }
          },
          "functions": {}
        },
        "db": {
          "name": "db",
          "path": "bamboostcli.pages.db",
          "filepath": "/home/florez/work/code/hdftui/bamboostcli/pages/db.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "DIVIDE_CHARS",
              "annotation": null,
              "description": null,
              "value": "2"
            },
            {
              "name": "FOOTER",
              "annotation": null,
              "description": null,
              "value": "'q: Exit widget | Q: Quit app | ?: Keybindings | : Command'"
            },
            {
              "name": "database_keybinds",
              "annotation": null,
              "description": null,
              "value": "Config.keybinds.get('database', {})"
            }
          ],
          "modules": {},
          "classes": {
            "DatabaseCommands": {
              "name": "DatabaseCommands",
              "path": "bamboostcli.pages.db.DatabaseCommands",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "parent",
                  "annotation": "Database",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "parent",
                  "annotation": null,
                  "description": null,
                  "value": "parent"
                },
                {
                  "name": "parser",
                  "annotation": null,
                  "description": null,
                  "value": "ArgumentParser()"
                },
                {
                  "name": "_functions",
                  "annotation": "dict",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.pages.db.DatabaseCommands.__init__",
                  "signature": "(self, parent) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "Database",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, parent: Database) -> None:\n    self.parent = parent\n\n    self.parser = ArgumentParser()  # Enhanced argparse parser\n\n    functions = self.parser.add_subparsers(dest=\"function\")\n\n    # sort\n    sort = functions.add_parser(\"sort\", help=\"Sort by a column\")\n    sort.add_argument(\"column\", choices=list(self.parent.df.columns))\n    sort.add_argument(\"-r\", \"--reverse\", action=\"store_true\", help=\"Reverse the sort order\")\n    sort.add_argument(\"--close\", \"-c\", help=\"Sort by the closest value in a column\")\n\n    # filter\n    filter = functions.add_parser(\"filter\", help=\"Filter table by a column.\")\n    filter.add_argument(\"column\", choices=list(self.parent.df.columns), help=\"Column to filter\")\n    filter.add_argument(\"-s\", \"--as_string\", help=\"Force to filter by string comparison\", action=\"store_true\")  # fmt: skip\n    filter.add_argument(\"-eq\", \"--eq\", help=\"Filter by equality\")\n    filter.add_argument(\"-ne\", \"--ne\", help=\"Filter by inequality\")\n    filter.add_argument(\"-gt\", \"--gt\", help=\"Filter by greater than\")\n    filter.add_argument(\"-lt\", \"--lt\", help=\"Filter by less than\")\n    filter.add_argument(\"-ge\", \"--ge\", help=\"Filter by greater than or equal to\")\n    filter.add_argument(\"-le\", \"--le\", help=\"Filter by less than or equal to\")\n    filter.add_argument(\"-c\", \"--contains\", help=\"Filter by substring\")\n\n    # goto\n    goto = functions.add_parser(\"goto\", help=\"Go to a column\")\n    goto.add_argument(\"column\", choices=list(self.parent.df.columns), help=\"Column to jump to.\")\n\n    # reset\n    functions.add_parser(\"reset\", help=\"Reset the table to the original dataframe\")\n\n    # pin column\n    pin = functions.add_parser(\"pin\", help=\"Pin a column to the left\")\n    pin.add_argument(\"column\", choices=list(self.parent.df.columns), help=\"Column to pin\")\n\n    # id to stdout\n    _ = functions.add_parser(\n        \"id_to_stdout\",\n        help=\"Print the full ID of the selected simulation to stdout\",\n    )"
                },
                "eval": {
                  "name": "eval",
                  "path": "bamboostcli.pages.db.DatabaseCommands.eval",
                  "signature": "(self, command) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "command",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def eval(self, command: str) -> None:\n    stdout = io.StringIO()\n    stderr = io.StringIO()\n    sys.stdout = stdout\n    sys.stderr = stderr\n    try:\n        args = self.parser.parse_string(command)\n        sys.stdout, sys.stderr = sys.__stdout__, sys.__stderr__\n    except SystemExit as e:  # argparse raises SystemExit on help display\n        sys.stdout = sys.__stdout__\n        sys.stderr = sys.__stderr__\n        if e.args and e.args[0] == 0:  # help displayed\n            _show_help(stdout.getvalue())\n            return\n        if e.args and e.args[0] == 2:  # error displayed\n            urwid.emit_signal(self.parent.command_line, \"release_focus\")\n            self.parent.container.footer = urwid.Text(\n                (\"failed\", stderr.getvalue().splitlines()[-1])\n            )\n            return\n\n    _func = args.__dict__.pop(\"function\")\n    cb = self._functions[_func]\n    try:\n        cb(**args.__dict__)\n    except (KeyError, ValueError, TypeError) as e:\n        urwid.emit_signal(self.parent.command_line, \"release_focus\")\n        self.parent.container.footer = urwid.Text((\"failed\", f\"Error: {e}\"))\n        return\n\n    urwid.emit_signal(self.parent.command_line, \"release_focus\")\n    self.parent.container.footer = urwid.Text((\"success\", f\"Command executed: {command}\"))"
                }
              },
              "source": "class DatabaseCommands:\n    def __init__(self, parent: Database) -> None:\n        self.parent = parent\n\n        self.parser = ArgumentParser()  # Enhanced argparse parser\n\n        functions = self.parser.add_subparsers(dest=\"function\")\n\n        # sort\n        sort = functions.add_parser(\"sort\", help=\"Sort by a column\")\n        sort.add_argument(\"column\", choices=list(self.parent.df.columns))\n        sort.add_argument(\"-r\", \"--reverse\", action=\"store_true\", help=\"Reverse the sort order\")\n        sort.add_argument(\"--close\", \"-c\", help=\"Sort by the closest value in a column\")\n\n        # filter\n        filter = functions.add_parser(\"filter\", help=\"Filter table by a column.\")\n        filter.add_argument(\"column\", choices=list(self.parent.df.columns), help=\"Column to filter\")\n        filter.add_argument(\"-s\", \"--as_string\", help=\"Force to filter by string comparison\", action=\"store_true\")  # fmt: skip\n        filter.add_argument(\"-eq\", \"--eq\", help=\"Filter by equality\")\n        filter.add_argument(\"-ne\", \"--ne\", help=\"Filter by inequality\")\n        filter.add_argument(\"-gt\", \"--gt\", help=\"Filter by greater than\")\n        filter.add_argument(\"-lt\", \"--lt\", help=\"Filter by less than\")\n        filter.add_argument(\"-ge\", \"--ge\", help=\"Filter by greater than or equal to\")\n        filter.add_argument(\"-le\", \"--le\", help=\"Filter by less than or equal to\")\n        filter.add_argument(\"-c\", \"--contains\", help=\"Filter by substring\")\n\n        # goto\n        goto = functions.add_parser(\"goto\", help=\"Go to a column\")\n        goto.add_argument(\"column\", choices=list(self.parent.df.columns), help=\"Column to jump to.\")\n\n        # reset\n        functions.add_parser(\"reset\", help=\"Reset the table to the original dataframe\")\n\n        # pin column\n        pin = functions.add_parser(\"pin\", help=\"Pin a column to the left\")\n        pin.add_argument(\"column\", choices=list(self.parent.df.columns), help=\"Column to pin\")\n\n        # id to stdout\n        _ = functions.add_parser(\n            \"id_to_stdout\",\n            help=\"Print the full ID of the selected simulation to stdout\",\n        )\n\n    @property\n    def _functions(self) -> dict[str, Callable]:\n        return {\n            \"sort\": self.parent.table.sort,\n            \"filter\": self.parent.table.filter,\n            \"goto\": self.parent.table.go_to_column,\n            \"reset\": self.parent.table.reset,\n            \"pin\": self.parent.table.pin_column,\n            \"id_to_stdout\": self.parent.id_to_stdout,\n        }\n\n    def eval(self, command: str) -> None:\n        stdout = io.StringIO()\n        stderr = io.StringIO()\n        sys.stdout = stdout\n        sys.stderr = stderr\n        try:\n            args = self.parser.parse_string(command)\n            sys.stdout, sys.stderr = sys.__stdout__, sys.__stderr__\n        except SystemExit as e:  # argparse raises SystemExit on help display\n            sys.stdout = sys.__stdout__\n            sys.stderr = sys.__stderr__\n            if e.args and e.args[0] == 0:  # help displayed\n                _show_help(stdout.getvalue())\n                return\n            if e.args and e.args[0] == 2:  # error displayed\n                urwid.emit_signal(self.parent.command_line, \"release_focus\")\n                self.parent.container.footer = urwid.Text(\n                    (\"failed\", stderr.getvalue().splitlines()[-1])\n                )\n                return\n\n        _func = args.__dict__.pop(\"function\")\n        cb = self._functions[_func]\n        try:\n            cb(**args.__dict__)\n        except (KeyError, ValueError, TypeError) as e:\n            urwid.emit_signal(self.parent.command_line, \"release_focus\")\n            self.parent.container.footer = urwid.Text((\"failed\", f\"Error: {e}\"))\n            return\n\n        urwid.emit_signal(self.parent.command_line, \"release_focus\")\n        self.parent.container.footer = urwid.Text((\"success\", f\"Command executed: {command}\"))",
              "inherited_members": {}
            },
            "Database": {
              "name": "Database",
              "path": "bamboostcli.pages.db.Database",
              "description": "Database frame\n\nTODO: Add description here",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "id",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "db",
                  "annotation": "bamboost.Manager",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "placehold_footer",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Text(('footer', FOOTER))"
                },
                {
                  "name": "id",
                  "annotation": null,
                  "description": null,
                  "value": "id"
                },
                {
                  "name": "db",
                  "annotation": null,
                  "description": null,
                  "value": "db"
                },
                {
                  "name": "df",
                  "annotation": null,
                  "description": null,
                  "value": "self.db.df"
                },
                {
                  "name": "header",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Pile([urwid.Text(('6-bold', f'  UID:   {self.id}')), urwid.Text(('5-bold', f'  Path:  {self.db.path}')), urwid.Divider()])"
                },
                {
                  "name": "table",
                  "annotation": null,
                  "description": null,
                  "value": "Table(self.df)"
                },
                {
                  "name": "commands",
                  "annotation": null,
                  "description": null,
                  "value": "DatabaseCommands(self)"
                },
                {
                  "name": "command_line",
                  "annotation": null,
                  "description": null,
                  "value": "CommandLine(self.commands.parser)"
                },
                {
                  "name": "container",
                  "annotation": null,
                  "description": null,
                  "value": "urwid.Frame(self.table, header=self.header, footer=self.placehold_footer, focus_part='body')"
                },
                {
                  "name": "keybinds",
                  "annotation": null,
                  "description": null,
                  "value": "Keybindings(self).new('command', ':', Database.enter_command_line, 'Enter command').new('search', ',', Database.search, 'Search').new('jump', '/', lambda self: Database.enter_command_line(self, caption='jump to column: ', prefix='goto '), 'Jump to column').new('help', '?', Database.show_help, 'Show keybindings').new('copy', 'y', Database.copy_id, 'Copy UID').new('open-paraview', 'ctrl o', Database.open_paraview, 'Open in paraview').new('open-xdmf-file', ['o', 'x'], Database.open_xdmf, 'Open XDMF').new('open-output-file', ['o', 'o'], Database.open_output_file, 'Open output file').new('open-submission-file', ['o', 'e'], Database.open_submission_file, 'Open submission file').new('open-dir', ['o', 'd'], Database.open_sim_directory, 'Open directory').new('submit', 'ctrl p', Database.submit, 'Submit job').new('delete', 'd', Database.delete, 'Delete simulation').new('note', ['o', 'n'], Database.edit_note, 'Edit note').new('links', 'L', Database.show_links, 'Show linked sims').new('stdout', 'ctrl t', Database.id_to_stdout, 'Print full ID to stdout').new('reload', 'R', Database.refresh, 'Reload dataframe').new('page-down', 'ctrl d', lambda *_: Caller.main_loop.process_input(['page down']), 'Page down').new('page-up', 'ctrl u', lambda *_: Caller.main_loop.process_input(['page up']), 'Page up').new('next-search', 'n', lambda *_: next(self._search_query), 'Next search')"
                },
                {
                  "name": "_search_query",
                  "annotation": "None",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboostcli.pages.db.Database.__init__",
                  "signature": "(self, id, db) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "id",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "db",
                      "annotation": "bamboost.Manager",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, id: str, db: bamboost.Manager) -> None:\n    self.id = id\n    self.db = db\n    self.df = self.db.df\n    self.header = urwid.Pile(\n        [\n            urwid.Text((\"6-bold\", f\"  UID:   {self.id}\")),\n            urwid.Text((\"5-bold\", f\"  Path:  {self.db.path}\")),\n            urwid.Divider(),\n        ]\n    )\n    self.table = Table(self.df)\n\n    self.commands = DatabaseCommands(self)\n    self.command_line = CommandLine(self.commands.parser)\n    urwid.connect_signal(self.command_line, \"execute_command\", self.commands.eval)\n    urwid.connect_signal(self.command_line, \"release_focus\", self.unfocus_command_line)\n\n    self.container = urwid.Frame(\n        self.table,\n        header=self.header,\n        footer=self.placehold_footer,\n        focus_part=\"body\",\n    )\n\n    # fmt: off\n    self.keybinds = (\n        Keybindings(self)\n        .new(\"command\", \":\", Database.enter_command_line, \"Enter command\")\n        .new(\"search\", \",\", Database.search, \"Search\")\n        .new(\"jump\", \"/\", lambda self: Database.enter_command_line(self, caption=\"jump to column: \", prefix=\"goto \"), \"Jump to column\",)\n        .new(\"help\", \"?\", Database.show_help, \"Show keybindings\")\n        .new(\"copy\", \"y\", Database.copy_id, \"Copy UID\")\n        .new(\"open-paraview\", \"ctrl o\", Database.open_paraview, \"Open in paraview\")\n        .new(\"open-xdmf-file\", [\"o\", \"x\"], Database.open_xdmf, \"Open XDMF\")\n        .new(\"open-output-file\", [\"o\", \"o\"], Database.open_output_file, \"Open output file\")\n        .new(\"open-submission-file\", [\"o\", \"e\"], Database.open_submission_file, \"Open submission file\")\n        .new(\"open-dir\", [\"o\", \"d\"], Database.open_sim_directory, \"Open directory\")\n        .new(\"submit\", \"ctrl p\", Database.submit, \"Submit job\")\n        .new(\"delete\", \"d\", Database.delete, \"Delete simulation\")\n        .new(\"note\", [\"o\", \"n\"], Database.edit_note, \"Edit note\")\n        .new(\"links\", \"L\", Database.show_links, \"Show linked sims\")\n        .new(\"stdout\", \"ctrl t\", Database.id_to_stdout, \"Print full ID to stdout\")\n        .new(\"reload\", \"R\", Database.refresh, \"Reload dataframe\")\n        .new(\"page-down\", \"ctrl d\", lambda *_: Caller.main_loop.process_input([\"page down\"]), \"Page down\")\n        .new(\"page-up\", \"ctrl u\", lambda *_: Caller.main_loop.process_input([\"page up\"]), \"Page up\")\n        .new(\"next-search\", \"n\", lambda *_: next(self._search_query), \"Next search\")\n    )\n\n    # fmt: on\n\n    # set the user keybindings\n    apply_user_keybinds(self.keybinds, \"database\")\n    self.keybinds.resolve_mapping()\n\n    # include keybinds from table widget\n    self.keybinds.merge(self.table.keybinds)\n\n    super().__init__(self.command_line, self.container)\n\n    # catch the release_focus signal from the command line\n    urwid.connect_signal(self.table, \"enter_file\", self.enter_file)\n    urwid.connect_signal(self.table, \"set_footer\", self.set_footer)"
                },
                "display_loading_screen": {
                  "name": "display_loading_screen",
                  "path": "bamboostcli.pages.db.Database.display_loading_screen",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def display_loading_screen(self) -> None: ..."
                },
                "set_footer": {
                  "name": "set_footer",
                  "path": "bamboostcli.pages.db.Database.set_footer",
                  "signature": "(self, widget)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "widget",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def set_footer(self, widget):\n    self.container.footer = widget"
                },
                "_reload_df": {
                  "name": "_reload_df",
                  "path": "bamboostcli.pages.db.Database._reload_df",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _reload_df(self) -> None:\n    self.df = self.db.get_view()\n    self.table.reset_data(self.df)"
                },
                "keypress": {
                  "name": "keypress",
                  "path": "bamboostcli.pages.db.Database.keypress",
                  "signature": "(self, size, key) -> str | None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "size",
                      "annotation": "tuple",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str | None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n    if key in self.keybinds.keys() and self.container.focus_part == \"body\":\n        self.keybinds.call(size, key)\n        return\n    self.keybinds.reset_submap()\n    return self.container.keypress(size, key)"
                },
                "copy_id": {
                  "name": "copy_id",
                  "path": "bamboostcli.pages.db.Database.copy_id",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def copy_id(self) -> None:\n    sim_id = self.table._get_entry_in_focus()[\"id\"]\n    full_id = \":\".join((self.id, sim_id))\n    pyperclip.copy(full_id)\n    self.container.footer = urwid.Text((\"footer\", f\"Copied <{full_id}> to clipboard\"))"
                },
                "open_paraview": {
                  "name": "open_paraview",
                  "path": "bamboostcli.pages.db.Database.open_paraview",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def open_paraview(self) -> None:\n    id = self.table._get_entry_in_focus()[\"id\"]\n    self.db[id].open_in_paraview()"
                },
                "open_xdmf": {
                  "name": "open_xdmf",
                  "path": "bamboostcli.pages.db.Database.open_xdmf",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def open_xdmf(self) -> None:\n    # Lauch EDITOR to edit the xdmf file\n    id = self.table._get_entry_in_focus()[\"id\"]\n    xdmf_file = self.db[id].xdmffile\n    os.system(f\"${{EDITOR:-vi}} {xdmf_file}\")\n    Caller.main_loop.screen.clear()"
                },
                "open_output_file": {
                  "name": "open_output_file",
                  "path": "bamboostcli.pages.db.Database.open_output_file",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def open_output_file(self) -> None:\n    # Lauch EDITOR to edit the output file\n    id = self.table._get_entry_in_focus()[\"id\"]\n    output_file = self.db[id].files(f\"{id}.out\")\n    if os.path.exists(output_file):\n        os.system(f\"${{EDITOR:-vi}} {output_file}\")\n        Caller.main_loop.screen.clear()\n    else:\n        self.container.footer = urwid.Text((\"footer\", f\"No output file found for {id}\"))"
                },
                "open_submission_file": {
                  "name": "open_submission_file",
                  "path": "bamboostcli.pages.db.Database.open_submission_file",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def open_submission_file(self) -> None:\n    # Lauch EDITOR to edit the submission file\n    id = self.table._get_entry_in_focus()[\"id\"]\n    submission_file_local = self.db[id].files(f\"{id}.sh\")\n    submission_file_slurm = self.db[id].files(f\"sbatch_{id}.sh\")\n    submission_file = (\n        submission_file_local\n        if os.path.exists(submission_file_local)\n        else submission_file_slurm\n    )\n    subprocess.run([os.getenv(\"EDITOR\", \"vi\"), submission_file])\n    Caller.main_loop.screen.clear()"
                },
                "open_sim_directory": {
                  "name": "open_sim_directory",
                  "path": "bamboostcli.pages.db.Database.open_sim_directory",
                  "signature": "(self) -> None",
                  "description": "Open the simulation directory in the editor.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def open_sim_directory(self) -> None:\n    \"\"\"Open the simulation directory in the editor.\"\"\"\n    id = self.table._get_entry_in_focus()[\"id\"]\n    sim_dir = self.db[id].path\n    subprocess.run([os.getenv(\"EDITOR\", \"vi\"), sim_dir])\n    Caller.main_loop.screen.clear()"
                },
                "submit": {
                  "name": "submit",
                  "path": "bamboostcli.pages.db.Database.submit",
                  "signature": "(self) -> None",
                  "description": "Submit the job for execution.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def submit(self) -> None:\n    \"\"\"Submit the job for execution.\"\"\"\n    id = self.table._get_entry_in_focus()[\"id\"]\n\n    def _submit() -> None:\n        def target(id) -> None:\n            # Redirect stdout to a file if submitted locally\n            new_stdout = open(f\"bamboost-job-{id}.out\", \"w\")\n            with redirect_allout(new_stdout):\n                try:\n                    self.db[id].submit(stdout=new_stdout, stderr=new_stdout)\n                except FileNotFoundError as e:\n                    self.container.footer = urwid.Text((\"footer\", f\"Error: {e}\"))\n                    Caller.main_loop.draw_screen()\n                    return\n\n            self.container.footer = urwid.Text((\"footer\", f\"Job {id} submitted\"))\n            self.table._df = self.db.get_view()\n            self.table.loc(id).recreate()\n            Caller.main_loop.draw_screen()\n\n        threading.Thread(target=target, args=(id,)).start()\n        Caller.exit_widget()\n\n    ui = cw.cConfirmDialog(\n        Caller.main_loop,\n        f\"Submitting job <{id}>. This will overwrite any existing data. Are you sure?\",\n        callback=_submit,\n    )\n    Caller.enter_widget(ui)"
                },
                "id_to_stdout": {
                  "name": "id_to_stdout",
                  "path": "bamboostcli.pages.db.Database.id_to_stdout",
                  "signature": "(self, id=None) -> None",
                  "description": "Print the full ID of the selected simulation to stdout.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "id",
                      "annotation": "str",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def id_to_stdout(self, id: str = None) -> None:\n    \"\"\"Print the full ID of the selected simulation to stdout.\"\"\"\n    # get the ID of the selected simulation\n    id = self.table._get_entry_in_focus()[\"id\"]\n\n    # print the full ID to stdout\n    print(self.db[id].get_full_uid(), file=sys.stdout)\n    sys.stdout.flush()\n\n    # set the footer for the user\n    self.set_footer(\n        urwid.Text((\"footer\", f\"Full ID of {id} printed to stdout [Exit app to continue]\"))\n    )"
                },
                "delete": {
                  "name": "delete",
                  "path": "bamboostcli.pages.db.Database.delete",
                  "signature": "(self) -> None",
                  "description": "Delete the selected simulation.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def delete(self) -> None:\n    \"\"\"Delete the selected simulation.\"\"\"\n    id = self.table._get_entry_in_focus()[\"id\"]\n\n    def _delete() -> None:\n        self.db.remove(id)\n        self.table.reset_data(self.db.get_view())\n\n    ui = cw.cConfirmDialog(\n        Caller.main_loop,\n        f\"Are you sure you want to delete {id}?\",\n        callback=_delete,\n    )\n    Caller.enter_widget(ui)"
                },
                "refresh": {
                  "name": "refresh",
                  "path": "bamboostcli.pages.db.Database.refresh",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def refresh(self) -> None:\n    self._reload_df()"
                },
                "edit_note": {
                  "name": "edit_note",
                  "path": "bamboostcli.pages.db.Database.edit_note",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def edit_note(self) -> None:\n    id = self.table._get_entry_in_focus()[\"id\"]\n    note = self.db[id].metadata.get(\"notes\", \"\")\n\n    def commit_note(note: str) -> None:\n        self.db[id].change_note(note)\n        Caller.exit_widget()\n        self.table.loc(id).edit_cell_text(\"notes\", note)\n\n    edit = cw.cEdit(edit_text=note, multiline=True, edit_pos=len(note), callback=commit_note)\n    overlay = urwid.Overlay(\n        cw.cRoundedLineBox(\n            urwid.Frame(\n                urwid.Filler(urwid.Padding(edit, left=1, right=1), valign=\"top\"),\n                footer=urwid.Pile(\n                    [\n                        urwid.Divider(\"\\u2500\"),\n                        urwid.Padding(\n                            urwid.Text((\"2\", \"Enter: Save | Esc: Cancel\")),\n                            left=1,\n                            right=1,\n                        ),\n                    ]\n                ),\n            ),\n            focus_map=\"8\",\n            title=\"Edit note\",\n            title_align=\"left\",\n        ),\n        Caller.widget_stack[-1],\n        align=\"center\",\n        width=(\"relative\", 80),\n        valign=\"middle\",\n        height=20,\n    )\n    Caller.enter_widget(overlay)"
                },
                "show_links": {
                  "name": "show_links",
                  "path": "bamboostcli.pages.db.Database.show_links",
                  "signature": "(self) -> None",
                  "description": "Show the linked simulations.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def show_links(self) -> None:\n    \"\"\"Show the linked simulations.\"\"\"\n    id = self.table._get_entry_in_focus()[\"id\"]\n    links = self.db[id].links.all_links()\n\n    def cb(action_item: cw.cActionItem):\n        id = action_item.content[1]\n        widget = hfive.HFive(bamboost.Simulation.fromUID(id).h5file)\n        Caller.enter_widget(widget)\n\n    ui = cw.cPopup(\n        cw.cListBoxSelectionCharacter(\n            [cw.cActionItem([key, val], callback=cb) for key, val in links.items()],\n            attr_map={0: \"5\", 1: \"8\"},\n            focus_map={0: \"5-bold\", 1: \"8-bold\"},\n        ),\n        footer=\"Enter: Open | Esc: Close\",\n        title=\"Linked simulations\",\n        title_align=\"left\",\n        focus_map=\"8\",\n        height=len(links),\n    )\n    Caller.enter_widget(ui)"
                },
                "enter_command_line": {
                  "name": "enter_command_line",
                  "path": "bamboostcli.pages.db.Database.enter_command_line",
                  "signature": "(self, *args, *, caption=None, prefix=None, container=None, **kwargs) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "caption",
                      "annotation": "str | None",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "prefix",
                      "annotation": "str | None",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "container",
                      "annotation": "urwid.Widget | None",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def enter_command_line(\n    self,\n    *args,\n    caption: str | None = None,\n    prefix: str | None = None,\n    container: urwid.Widget | None = None,\n    **kwargs,\n) -> None:\n    self.command_line.set_caption(caption or \":\")\n    self.commands.parser.set_prefix(prefix or \"\")\n\n    self.container.footer = self.command_line\n    self.command_line.edit_text = \"\"\n    self.command_line.history_index = 0\n    self.container.set_focus(\"footer\")"
                },
                "_search": {
                  "name": "_search",
                  "path": "bamboostcli.pages.db.Database._search",
                  "signature": "(self, text) -> Generator",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "text",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Generator",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _search(self, text: str) -> Generator[None, None, None]:\n    rows: list[RowEntry] = self.table.entries.body\n    for row in rows:\n        for col_name, cell in row._cells.items():\n            cell_w = cell[2].base_widget\n            if cell_w.text.lower().find(text.lower()) != -1:\n                # split the text into two parts (before and after the match) using regex module\n                text_orig = cell_w.text\n                before, match, after = re.split(f\"({text})\", cell_w.text, flags=re.IGNORECASE)\n                cell_w.set_text([before, (\"match\", match), after])\n                self.table.go_to_column(col_name)\n                yield\n                # reset the text to the original\n                cell_w.set_text(text_orig)"
                },
                "search": {
                  "name": "search",
                  "path": "bamboostcli.pages.db.Database.search",
                  "signature": "(self) -> None",
                  "description": "Search for string in the table and highlight it.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def search(self) -> None:\n    \"\"\"Search for string in the table and highlight it.\"\"\"\n\n    def search(text):\n        self._search_query = self._search(text)\n        self.unfocus_command_line()\n        next(self._search_query)\n\n    edit = cw.cEdit(caption=\"search: \", callback=search)\n    self.container.footer = edit\n    self.container.set_focus(\"footer\")\n    return"
                },
                "unfocus_command_line": {
                  "name": "unfocus_command_line",
                  "path": "bamboostcli.pages.db.Database.unfocus_command_line",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def unfocus_command_line(self) -> None:\n    self.container.footer = self.placehold_footer\n    self.container.set_focus(\"body\")"
                },
                "enter_file": {
                  "name": "enter_file",
                  "path": "bamboostcli.pages.db.Database.enter_file",
                  "signature": "(self, id) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "id",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def enter_file(self, id: str) -> None:\n    Caller.enter_widget(hfive.HFive(self.db[id].h5file))"
                },
                "show_help": {
                  "name": "show_help",
                  "path": "bamboostcli.pages.db.Database.show_help",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def show_help(self) -> None:\n    # if not hasattr(self, \"_help_widget\"):\n    #     self._help_widget = cKeybindsOverlay(Caller.main_loop, self.keybinds)\n    # self._help_widget.toggle()\n    self.keybinds.toggle_help()"
                }
              },
              "source": "class Database(AutocompleteContainer):\n    \"\"\"Database frame\n\n    TODO: Add description here\n    \"\"\"\n\n    placehold_footer = urwid.Text((\"footer\", FOOTER))\n\n    def __init__(self, id: str, db: bamboost.Manager) -> None:\n        self.id = id\n        self.db = db\n        self.df = self.db.df\n        self.header = urwid.Pile(\n            [\n                urwid.Text((\"6-bold\", f\"  UID:   {self.id}\")),\n                urwid.Text((\"5-bold\", f\"  Path:  {self.db.path}\")),\n                urwid.Divider(),\n            ]\n        )\n        self.table = Table(self.df)\n\n        self.commands = DatabaseCommands(self)\n        self.command_line = CommandLine(self.commands.parser)\n        urwid.connect_signal(self.command_line, \"execute_command\", self.commands.eval)\n        urwid.connect_signal(self.command_line, \"release_focus\", self.unfocus_command_line)\n\n        self.container = urwid.Frame(\n            self.table,\n            header=self.header,\n            footer=self.placehold_footer,\n            focus_part=\"body\",\n        )\n\n        # fmt: off\n        self.keybinds = (\n            Keybindings(self)\n            .new(\"command\", \":\", Database.enter_command_line, \"Enter command\")\n            .new(\"search\", \",\", Database.search, \"Search\")\n            .new(\"jump\", \"/\", lambda self: Database.enter_command_line(self, caption=\"jump to column: \", prefix=\"goto \"), \"Jump to column\",)\n            .new(\"help\", \"?\", Database.show_help, \"Show keybindings\")\n            .new(\"copy\", \"y\", Database.copy_id, \"Copy UID\")\n            .new(\"open-paraview\", \"ctrl o\", Database.open_paraview, \"Open in paraview\")\n            .new(\"open-xdmf-file\", [\"o\", \"x\"], Database.open_xdmf, \"Open XDMF\")\n            .new(\"open-output-file\", [\"o\", \"o\"], Database.open_output_file, \"Open output file\")\n            .new(\"open-submission-file\", [\"o\", \"e\"], Database.open_submission_file, \"Open submission file\")\n            .new(\"open-dir\", [\"o\", \"d\"], Database.open_sim_directory, \"Open directory\")\n            .new(\"submit\", \"ctrl p\", Database.submit, \"Submit job\")\n            .new(\"delete\", \"d\", Database.delete, \"Delete simulation\")\n            .new(\"note\", [\"o\", \"n\"], Database.edit_note, \"Edit note\")\n            .new(\"links\", \"L\", Database.show_links, \"Show linked sims\")\n            .new(\"stdout\", \"ctrl t\", Database.id_to_stdout, \"Print full ID to stdout\")\n            .new(\"reload\", \"R\", Database.refresh, \"Reload dataframe\")\n            .new(\"page-down\", \"ctrl d\", lambda *_: Caller.main_loop.process_input([\"page down\"]), \"Page down\")\n            .new(\"page-up\", \"ctrl u\", lambda *_: Caller.main_loop.process_input([\"page up\"]), \"Page up\")\n            .new(\"next-search\", \"n\", lambda *_: next(self._search_query), \"Next search\")\n        )\n\n        # fmt: on\n\n        # set the user keybindings\n        apply_user_keybinds(self.keybinds, \"database\")\n        self.keybinds.resolve_mapping()\n\n        # include keybinds from table widget\n        self.keybinds.merge(self.table.keybinds)\n\n        super().__init__(self.command_line, self.container)\n\n        # catch the release_focus signal from the command line\n        urwid.connect_signal(self.table, \"enter_file\", self.enter_file)\n        urwid.connect_signal(self.table, \"set_footer\", self.set_footer)\n\n    def display_loading_screen(self) -> None: ...\n\n    def set_footer(self, widget):\n        self.container.footer = widget\n\n    def _reload_df(self) -> None:\n        self.df = self.db.get_view()\n        self.table.reset_data(self.df)\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        if key in self.keybinds.keys() and self.container.focus_part == \"body\":\n            self.keybinds.call(size, key)\n            return\n        self.keybinds.reset_submap()\n        return self.container.keypress(size, key)\n\n    def copy_id(self) -> None:\n        sim_id = self.table._get_entry_in_focus()[\"id\"]\n        full_id = \":\".join((self.id, sim_id))\n        pyperclip.copy(full_id)\n        self.container.footer = urwid.Text((\"footer\", f\"Copied <{full_id}> to clipboard\"))\n\n    def open_paraview(self) -> None:\n        id = self.table._get_entry_in_focus()[\"id\"]\n        self.db[id].open_in_paraview()\n\n    def open_xdmf(self) -> None:\n        # Lauch EDITOR to edit the xdmf file\n        id = self.table._get_entry_in_focus()[\"id\"]\n        xdmf_file = self.db[id].xdmffile\n        os.system(f\"${{EDITOR:-vi}} {xdmf_file}\")\n        Caller.main_loop.screen.clear()\n\n    def open_output_file(self) -> None:\n        # Lauch EDITOR to edit the output file\n        id = self.table._get_entry_in_focus()[\"id\"]\n        output_file = self.db[id].files(f\"{id}.out\")\n        if os.path.exists(output_file):\n            os.system(f\"${{EDITOR:-vi}} {output_file}\")\n            Caller.main_loop.screen.clear()\n        else:\n            self.container.footer = urwid.Text((\"footer\", f\"No output file found for {id}\"))\n\n    def open_submission_file(self) -> None:\n        # Lauch EDITOR to edit the submission file\n        id = self.table._get_entry_in_focus()[\"id\"]\n        submission_file_local = self.db[id].files(f\"{id}.sh\")\n        submission_file_slurm = self.db[id].files(f\"sbatch_{id}.sh\")\n        submission_file = (\n            submission_file_local\n            if os.path.exists(submission_file_local)\n            else submission_file_slurm\n        )\n        subprocess.run([os.getenv(\"EDITOR\", \"vi\"), submission_file])\n        Caller.main_loop.screen.clear()\n\n    def open_sim_directory(self) -> None:\n        \"\"\"Open the simulation directory in the editor.\"\"\"\n        id = self.table._get_entry_in_focus()[\"id\"]\n        sim_dir = self.db[id].path\n        subprocess.run([os.getenv(\"EDITOR\", \"vi\"), sim_dir])\n        Caller.main_loop.screen.clear()\n\n    def submit(self) -> None:\n        \"\"\"Submit the job for execution.\"\"\"\n        id = self.table._get_entry_in_focus()[\"id\"]\n\n        def _submit() -> None:\n            def target(id) -> None:\n                # Redirect stdout to a file if submitted locally\n                new_stdout = open(f\"bamboost-job-{id}.out\", \"w\")\n                with redirect_allout(new_stdout):\n                    try:\n                        self.db[id].submit(stdout=new_stdout, stderr=new_stdout)\n                    except FileNotFoundError as e:\n                        self.container.footer = urwid.Text((\"footer\", f\"Error: {e}\"))\n                        Caller.main_loop.draw_screen()\n                        return\n\n                self.container.footer = urwid.Text((\"footer\", f\"Job {id} submitted\"))\n                self.table._df = self.db.get_view()\n                self.table.loc(id).recreate()\n                Caller.main_loop.draw_screen()\n\n            threading.Thread(target=target, args=(id,)).start()\n            Caller.exit_widget()\n\n        ui = cw.cConfirmDialog(\n            Caller.main_loop,\n            f\"Submitting job <{id}>. This will overwrite any existing data. Are you sure?\",\n            callback=_submit,\n        )\n        Caller.enter_widget(ui)\n\n    def id_to_stdout(self, id: str = None) -> None:\n        \"\"\"Print the full ID of the selected simulation to stdout.\"\"\"\n        # get the ID of the selected simulation\n        id = self.table._get_entry_in_focus()[\"id\"]\n\n        # print the full ID to stdout\n        print(self.db[id].get_full_uid(), file=sys.stdout)\n        sys.stdout.flush()\n\n        # set the footer for the user\n        self.set_footer(\n            urwid.Text((\"footer\", f\"Full ID of {id} printed to stdout [Exit app to continue]\"))\n        )\n\n        # exit the app\n        # raise urwid.ExitMainLoop()\n\n    def delete(self) -> None:\n        \"\"\"Delete the selected simulation.\"\"\"\n        id = self.table._get_entry_in_focus()[\"id\"]\n\n        def _delete() -> None:\n            self.db.remove(id)\n            self.table.reset_data(self.db.get_view())\n\n        ui = cw.cConfirmDialog(\n            Caller.main_loop,\n            f\"Are you sure you want to delete {id}?\",\n            callback=_delete,\n        )\n        Caller.enter_widget(ui)\n\n    def refresh(self) -> None:\n        self._reload_df()\n\n    def edit_note(self) -> None:\n        id = self.table._get_entry_in_focus()[\"id\"]\n        note = self.db[id].metadata.get(\"notes\", \"\")\n\n        def commit_note(note: str) -> None:\n            self.db[id].change_note(note)\n            Caller.exit_widget()\n            self.table.loc(id).edit_cell_text(\"notes\", note)\n\n        edit = cw.cEdit(edit_text=note, multiline=True, edit_pos=len(note), callback=commit_note)\n        overlay = urwid.Overlay(\n            cw.cRoundedLineBox(\n                urwid.Frame(\n                    urwid.Filler(urwid.Padding(edit, left=1, right=1), valign=\"top\"),\n                    footer=urwid.Pile(\n                        [\n                            urwid.Divider(\"\\u2500\"),\n                            urwid.Padding(\n                                urwid.Text((\"2\", \"Enter: Save | Esc: Cancel\")),\n                                left=1,\n                                right=1,\n                            ),\n                        ]\n                    ),\n                ),\n                focus_map=\"8\",\n                title=\"Edit note\",\n                title_align=\"left\",\n            ),\n            Caller.widget_stack[-1],\n            align=\"center\",\n            width=(\"relative\", 80),\n            valign=\"middle\",\n            height=20,\n        )\n        Caller.enter_widget(overlay)\n\n    def show_links(self) -> None:\n        \"\"\"Show the linked simulations.\"\"\"\n        id = self.table._get_entry_in_focus()[\"id\"]\n        links = self.db[id].links.all_links()\n\n        def cb(action_item: cw.cActionItem):\n            id = action_item.content[1]\n            widget = hfive.HFive(bamboost.Simulation.fromUID(id).h5file)\n            Caller.enter_widget(widget)\n\n        ui = cw.cPopup(\n            cw.cListBoxSelectionCharacter(\n                [cw.cActionItem([key, val], callback=cb) for key, val in links.items()],\n                attr_map={0: \"5\", 1: \"8\"},\n                focus_map={0: \"5-bold\", 1: \"8-bold\"},\n            ),\n            footer=\"Enter: Open | Esc: Close\",\n            title=\"Linked simulations\",\n            title_align=\"left\",\n            focus_map=\"8\",\n            height=len(links),\n        )\n        Caller.enter_widget(ui)\n\n    def enter_command_line(\n        self,\n        *args,\n        caption: str | None = None,\n        prefix: str | None = None,\n        container: urwid.Widget | None = None,\n        **kwargs,\n    ) -> None:\n        self.command_line.set_caption(caption or \":\")\n        self.commands.parser.set_prefix(prefix or \"\")\n\n        self.container.footer = self.command_line\n        self.command_line.edit_text = \"\"\n        self.command_line.history_index = 0\n        self.container.set_focus(\"footer\")\n\n    @property\n    def _search_query(self) -> None:\n        return self.__search_gen\n\n    @_search_query.setter\n    def _search_query(self, value):\n        self.__search_gen = value\n\n    def _search(self, text: str) -> Generator[None, None, None]:\n        rows: list[RowEntry] = self.table.entries.body\n        for row in rows:\n            for col_name, cell in row._cells.items():\n                cell_w = cell[2].base_widget\n                if cell_w.text.lower().find(text.lower()) != -1:\n                    # split the text into two parts (before and after the match) using regex module\n                    text_orig = cell_w.text\n                    before, match, after = re.split(f\"({text})\", cell_w.text, flags=re.IGNORECASE)\n                    cell_w.set_text([before, (\"match\", match), after])\n                    self.table.go_to_column(col_name)\n                    yield\n                    # reset the text to the original\n                    cell_w.set_text(text_orig)\n\n    def search(self) -> None:\n        \"\"\"Search for string in the table and highlight it.\"\"\"\n\n        def search(text):\n            self._search_query = self._search(text)\n            self.unfocus_command_line()\n            next(self._search_query)\n\n        edit = cw.cEdit(caption=\"search: \", callback=search)\n        self.container.footer = edit\n        self.container.set_focus(\"footer\")\n        return\n\n    def unfocus_command_line(self) -> None:\n        self.container.footer = self.placehold_footer\n        self.container.set_focus(\"body\")\n\n    def enter_file(self, id: str) -> None:\n        Caller.enter_widget(hfive.HFive(self.db[id].h5file))\n\n    def show_help(self) -> None:\n        # if not hasattr(self, \"_help_widget\"):\n        #     self._help_widget = cKeybindsOverlay(Caller.main_loop, self.keybinds)\n        # self._help_widget.toggle()\n        self.keybinds.toggle_help()",
              "inherited_members": {
                "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer": [
                  {
                    "kind": "attribute",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer.edit"
                  },
                  {
                    "kind": "function",
                    "path": "bamboostcli.widgets.autocomplete_edit.AutocompleteContainer.render"
                  }
                ]
              }
            }
          },
          "functions": {
            "_show_help": {
              "name": "_show_help",
              "path": "bamboostcli.pages.db._show_help",
              "signature": "(text) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "text",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def _show_help(text) -> None:\n    class HelpFrame(urwid.Frame):\n        def keypress(self, size, key: str) -> str | None:\n            if key in {\"q\", \"esc\"}:\n                Caller.exit_widget()\n                return\n            return super().keypress(size, key)\n\n    Caller.enter_widget(\n        HelpFrame(\n            urwid.Overlay(\n                cw.cRoundedLineBox(\n                    urwid.Text(text), focus_map=\"8\", title=\"Help\", title_align=\"left\"\n                ),\n                Caller.main_loop.widget,\n                \"left\",\n                (\"relative\", 100),\n                \"bottom\",\n                (\"pack\"),\n                bottom=1,\n            )\n        )\n    )"
            }
          }
        }
      },
      "classes": {},
      "functions": {}
    }
  },
  "classes": {},
  "functions": {},
  "version": "unknown"
}