{
  "name": "bamboost",
  "path": "bamboost",
  "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/__init__.py",
  "description": null,
  "docstring": [],
  "attributes": [
    {
      "name": "__author__",
      "annotation": "str",
      "description": null,
      "value": "'florez@ethz.ch'"
    },
    {
      "name": "__copyright__",
      "annotation": "str",
      "description": null,
      "value": "''"
    },
    {
      "name": "__license__",
      "annotation": "str",
      "description": null,
      "value": "'MIT'"
    },
    {
      "name": "__version__",
      "annotation": "str",
      "description": null,
      "value": "version('bamboost')"
    },
    {
      "name": "BAMBOOST_LOGGER",
      "annotation": "logging.Logger",
      "description": null,
      "value": "logging.getLogger('bamboost')"
    },
    {
      "name": "STREAM_HANDLER",
      "annotation": "logging.StreamHandler",
      "description": null,
      "value": "logging.StreamHandler()"
    }
  ],
  "modules": {
    "_typing": {
      "name": "_typing",
      "path": "bamboost._typing",
      "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/_typing.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "StrPath",
          "annotation": "TypeAlias",
          "description": null,
          "value": "Union"
        },
        {
          "name": "_T",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_T')"
        },
        {
          "name": "_U",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_U')"
        },
        {
          "name": "_P",
          "annotation": null,
          "description": null,
          "value": "ParamSpec('_P')"
        },
        {
          "name": "SimulationMetadataT",
          "annotation": null,
          "description": null,
          "value": "TypedDict('SimulationMetadataT', {'created_at': datetime, 'modified_at': datetime, 'description': str, 'status': str}, total=False)"
        },
        {
          "name": "SimulationParameterT",
          "annotation": "TypeAlias",
          "description": null,
          "value": "Dict"
        },
        {
          "name": "Mutable",
          "annotation": null,
          "description": null,
          "value": "type('Mutable', (_Mutability,), {})"
        },
        {
          "name": "Immutable",
          "annotation": null,
          "description": null,
          "value": "type('Immutable', (_Mutability,), {})"
        },
        {
          "name": "_MT",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_MT', bound=_Mutability)"
        }
      ],
      "modules": {},
      "classes": {
        "_MutabilitySentinel": {
          "name": "_MutabilitySentinel",
          "path": "bamboost._typing._MutabilitySentinel",
          "description": "A metaclass for creating mutability sentinel types.\n\nThis metaclass is used to create special types that represent mutability\nstates (Mutable and Immutable). It provides custom boolean evaluation and\nstring representation for the created types.",
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__new__": {
              "name": "__new__",
              "path": "bamboost._typing._MutabilitySentinel.__new__",
              "signature": "(cls, name, bases, attrs)",
              "description": "Create a new class using this metaclass.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The name of the class being created."
                    }
                  ]
                },
                {
                  "name": "bases",
                  "annotation": "tuple",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The base classes of the class being created."
                    }
                  ]
                },
                {
                  "name": "attrs",
                  "annotation": "dict",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The attributes of the class being created."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "type",
                "annotation": null,
                "description": "The newly created class."
              },
              "docstring": [],
              "source": "def __new__(cls, name, bases, attrs):\n    \"\"\"Create a new class using this metaclass.\n\n    Args:\n        name (str): The name of the class being created.\n        bases (tuple): The base classes of the class being created.\n        attrs (dict): The attributes of the class being created.\n\n    Returns:\n        type: The newly created class.\n    \"\"\"\n    return super().__new__(cls, name, bases, attrs)"
            },
            "__bool__": {
              "name": "__bool__",
              "path": "bamboost._typing._MutabilitySentinel.__bool__",
              "signature": "(self)",
              "description": "Determine the boolean value of the class.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "bool",
                "annotation": null,
                "description": "True if the class is Mutable, False otherwise."
              },
              "docstring": [],
              "source": "def __bool__(self):\n    \"\"\"Determine the boolean value of the class.\n\n    Returns:\n        bool: True if the class is Mutable, False otherwise.\n    \"\"\"\n    return self is Mutable"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "bamboost._typing._MutabilitySentinel.__repr__",
              "signature": "(self)",
              "description": "Get the string representation of the class.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "str",
                "annotation": null,
                "description": "The name of the class."
              },
              "docstring": [],
              "source": "def __repr__(self):\n    \"\"\"\n    Get the string representation of the class.\n\n    Returns:\n        str: The name of the class.\n    \"\"\"\n    return self.__name__"
            }
          },
          "source": "class _MutabilitySentinel(type):\n    \"\"\"A metaclass for creating mutability sentinel types.\n\n    This metaclass is used to create special types that represent mutability\n    states (Mutable and Immutable). It provides custom boolean evaluation and\n    string representation for the created types.\n    \"\"\"\n\n    def __new__(cls, name, bases, attrs):\n        \"\"\"Create a new class using this metaclass.\n\n        Args:\n            name (str): The name of the class being created.\n            bases (tuple): The base classes of the class being created.\n            attrs (dict): The attributes of the class being created.\n\n        Returns:\n            type: The newly created class.\n        \"\"\"\n        return super().__new__(cls, name, bases, attrs)\n\n    def __bool__(self):\n        \"\"\"Determine the boolean value of the class.\n\n        Returns:\n            bool: True if the class is Mutable, False otherwise.\n        \"\"\"\n        return self is Mutable\n\n    def __repr__(self):\n        \"\"\"\n        Get the string representation of the class.\n\n        Returns:\n            str: The name of the class.\n        \"\"\"\n        return self.__name__",
          "inherited_members": {}
        },
        "_Mutability": {
          "name": "_Mutability",
          "path": "bamboost._typing._Mutability",
          "description": null,
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {},
          "source": "class _Mutability(metaclass=_MutabilitySentinel):\n    pass",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "constants": {
      "name": "constants",
      "path": "bamboost.constants",
      "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/constants.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "UID_SEPARATOR",
          "annotation": null,
          "description": null,
          "value": "':'"
        },
        {
          "name": "HDF_DATA_FILE_NAME",
          "annotation": null,
          "description": null,
          "value": "'data.h5'"
        },
        {
          "name": "XDMF_FILE_NAME",
          "annotation": null,
          "description": null,
          "value": "'data.xdmf'"
        },
        {
          "name": "RUN_FILE_NAME",
          "annotation": null,
          "description": null,
          "value": "'run.sh'"
        },
        {
          "name": "PATH_DATA",
          "annotation": null,
          "description": null,
          "value": "'.data'"
        },
        {
          "name": "PATH_FIELD_DATA",
          "annotation": null,
          "description": null,
          "value": "f'{PATH_DATA}/field_data'"
        },
        {
          "name": "PATH_SCALAR_DATA",
          "annotation": null,
          "description": null,
          "value": "f'{PATH_DATA}/scalar_data'"
        },
        {
          "name": "PATH_PARAMETERS",
          "annotation": null,
          "description": null,
          "value": "'.parameters'"
        },
        {
          "name": "PATH_MESH",
          "annotation": null,
          "description": null,
          "value": "'.mesh'"
        },
        {
          "name": "PATH_LINKS",
          "annotation": null,
          "description": null,
          "value": "'.links'"
        },
        {
          "name": "PATH_USERDATA",
          "annotation": null,
          "description": null,
          "value": "'.userdata'"
        },
        {
          "name": "DS_NAME_TIMESTEPS",
          "annotation": null,
          "description": null,
          "value": "'.timesteps'"
        },
        {
          "name": "DEFAULT_MESH_NAME",
          "annotation": null,
          "description": null,
          "value": "'default'"
        },
        {
          "name": "TABLENAME_COLLECTIONS",
          "annotation": null,
          "description": null,
          "value": "'collections'"
        },
        {
          "name": "TABLENAME_SIMULATIONS",
          "annotation": null,
          "description": null,
          "value": "'simulations'"
        },
        {
          "name": "TABLENAME_PARAMETERS",
          "annotation": null,
          "description": null,
          "value": "'parameters'"
        }
      ],
      "modules": {},
      "classes": {},
      "functions": {}
    },
    "_config": {
      "name": "_config",
      "path": "bamboost._config",
      "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/_config.py",
      "description": "The module includes functions to copy an example config file to the user's\nconfig directory and load the config file from the directory. If the config\nfile does not exist, a copy of the example config file will be created.",
      "docstring": [],
      "attributes": [
        {
          "name": "__all__",
          "annotation": null,
          "description": null,
          "value": "['config']"
        },
        {
          "name": "CONFIG_DIR",
          "annotation": null,
          "description": null,
          "value": "Path('~/.config/bamboost').expanduser()"
        },
        {
          "name": "CONFIG_FILE",
          "annotation": null,
          "description": null,
          "value": "CONFIG_DIR.joinpath('config.toml')"
        },
        {
          "name": "LOCAL_DIR",
          "annotation": null,
          "description": null,
          "value": "Path('~/.local/share/bamboost').expanduser()"
        },
        {
          "name": "CACHE_DIR",
          "annotation": null,
          "description": null,
          "value": "Path('~/.cache/bamboost').expanduser()"
        },
        {
          "name": "DATABASE_FILE_NAME",
          "annotation": null,
          "description": null,
          "value": "'bamboost-next.sqlite'"
        },
        {
          "name": "ROOT_DIR",
          "annotation": null,
          "description": null,
          "value": "_find_root_dir()"
        },
        {
          "name": "config",
          "description": [
            {
              "kind": "text",
              "value": "A config options object. Initialized from config file\n`~/.config/bamboost/config.toml`."
            }
          ],
          "annotation": "_Config",
          "value": "_Config()"
        }
      ],
      "modules": {},
      "classes": {
        "_Base": {
          "name": "_Base",
          "path": "bamboost._config._Base",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "_field_aliases",
              "annotation": null,
              "description": null,
              "value": "{}"
            }
          ],
          "docstring": [],
          "functions": {
            "__repr__": {
              "name": "__repr__",
              "path": "bamboost._config._Base.__repr__",
              "signature": "(self) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self) -> str:\n    s = \"\"\n    max_length = max(len(field.name) for field in fields(self))\n    for field in fields(self):\n        s += f\"{field.name:<{max_length+1}}: {getattr(self, field.name)}\\n\"\n    return s"
            },
            "__getitem__": {
              "name": "__getitem__",
              "path": "bamboost._config._Base.__getitem__",
              "signature": "(self, key) -> Any",
              "description": "Access the configuration options by key, separated by dots.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Any",
                "description": null
              },
              "docstring": [],
              "source": "def __getitem__(self, key: str) -> Any:\n    \"\"\"Access the configuration options by key, separated by dots.\"\"\"\n    try:\n        current_selection = self\n        for attr in key.split(\".\"):\n            current_selection = getattr(current_selection, attr)\n        return current_selection\n    except KeyError:\n        raise KeyError(f\"Invalid key path: '{key}'\")"
            },
            "__setitem__": {
              "name": "__setitem__",
              "path": "bamboost._config._Base.__setitem__",
              "signature": "(self, key, value) -> None",
              "description": "Set the configuration options by key, separated by dots.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "key",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": "Any",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def __setitem__(self, key: str, value: Any) -> None:\n    \"\"\"Set the configuration options by key, separated by dots.\"\"\"\n    current_selection = self\n    keys = key.split(\".\")\n    for attr in keys[:-1]:\n        current_selection = getattr(current_selection, attr)\n    setattr(current_selection, keys[-1], value)"
            },
            "__getattr__": {
              "name": "__getattr__",
              "path": "bamboost._config._Base.__getattr__",
              "signature": "(self, name) -> Any",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Any",
                "description": null
              },
              "docstring": [],
              "source": "def __getattr__(self, name: str) -> Any:\n    # handle aliases\n    actual_name = self._field_aliases.get(name, name)\n    return super().__getattribute__(actual_name)"
            },
            "_ipython_key_completions_": {
              "name": "_ipython_key_completions_",
              "path": "bamboost._config._Base._ipython_key_completions_",
              "signature": "(self) -> Generator[str, None, None]",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Generator[str, None, None]",
                "description": null
              },
              "docstring": [],
              "source": "def _ipython_key_completions_(self) -> Generator[str, None, None]:\n    for key, obj in self.__dict__.items():\n        yield key\n        for subkey in getattr(obj, \"__dict__\", {}).keys():\n            yield f\"{key}.{subkey}\""
            },
            "from_dict": {
              "name": "from_dict",
              "path": "bamboost._config._Base.from_dict",
              "signature": "(cls, config)",
              "description": "Create an instance of the dataclass from a dictionary of\nconfiguration values.\n\nThis method performs the following steps:\n1. Identifies valid field names and aliases.\n2. Logs any unknown configuration keys.\n3. Filters the input dictionary to include only valid keys and aliases.\n4. Validates the types of the configuration values.\n5. Creates an instance of the class with the filtered and validated configuration.\n6. Logs any missing fields that are using default values.",
              "parameters": [
                {
                  "name": "cls",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "config",
                  "annotation": "dict",
                  "description": [
                    {
                      "kind": "text",
                      "value": "A dictionary containing configuration key-value pairs."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": "An instance of the class initialized with the provided configuration."
              },
              "docstring": [
                {
                  "kind": "raises",
                  "value": [
                    {
                      "annotation": "No exceptions are raised, but various warnings and errors are logged",
                      "description": ""
                    }
                  ]
                },
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "note",
                    "description": "- Invalid type values are removed from the configuration.\n- Aliases are resolved to their corresponding field names."
                  },
                  "title": "Note"
                }
              ],
              "source": "@classmethod\ndef from_dict(cls, config: dict):\n    \"\"\"Create an instance of the dataclass from a dictionary of\n    configuration values.\n\n    This method performs the following steps:\n    1. Identifies valid field names and aliases.\n    2. Logs any unknown configuration keys.\n    3. Filters the input dictionary to include only valid keys and aliases.\n    4. Validates the types of the configuration values.\n    5. Creates an instance of the class with the filtered and validated configuration.\n    6. Logs any missing fields that are using default values.\n\n    Args:\n        config: A dictionary containing configuration key-value pairs.\n\n    Returns:\n        An instance of the class initialized with the provided configuration.\n\n    Raises:\n        No exceptions are raised, but various warnings and errors are logged:\n        - Unknown configuration keys are logged as info.\n        - Invalid types for configuration values are logged as errors.\n        - Type checking errors are logged as info.\n        - Missing fields (using defaults) are logged as info.\n\n    Note:\n        - Invalid type values are removed from the configuration.\n        - Aliases are resolved to their corresponding field names.\n    \"\"\"\n    # Get the valid field names\n    valid_fields = {f.name for f in fields(cls)}\n    aliases = set(cls._field_aliases.keys())\n\n    # Check for unknown keys\n    unknown_keys = set(config) - valid_fields - aliases\n    for key in unknown_keys:\n        log.info(f\"Unknown config key: {key}\")\n\n    # Filter the input dictionary to only include valid keys\n    filtered_config = {k: v for k, v in config.items() if k in valid_fields}\n    filtered_config.update(\n        {cls._field_aliases[k]: v for k, v in config.items() if k in aliases}\n    )\n\n    # Validate type of user and project config values\n    resolved_type_hints = get_type_hints(cls)\n    for field_def in fields(cls):\n        if field_def.name in filtered_config:\n            try:\n                if not isinstance(\n                    filtered_config[field_def.name],\n                    resolved_type_hints[field_def.name],\n                ):\n                    log.error(\n                        (\n                            f\"Invalid type for config key '{field_def.name}': {filtered_config[field_def.name]}. \"\n                            f\"Requires {field_def.type} \"\n                        )\n                    )\n                    # If the type is invalid, remove the key\n                    filtered_config.pop(field_def.name)\n            except TypeError:\n                # An error occurred while checking the type, keep the key but log a warning\n                log.info(\n                    f\"Error checking type for config key '{field_def.name}': {filtered_config[field_def.name]}\"\n                )\n\n    # Create the instance\n    instance = cls(**filtered_config)\n\n    # Check for missing fields (defaults used)\n    for field_def in fields(cls):\n        if field_def.name not in filtered_config:\n            log.info(\n                f\"Config key '{field_def.name}' not set; using default: {getattr(instance, field_def.name)}\"\n            )\n\n    return instance"
            },
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._Base.__init__",
              "signature": "(self) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass\nclass _Base:\n    _field_aliases = {}\n\n    def __repr__(self) -> str:\n        s = \"\"\n        max_length = max(len(field.name) for field in fields(self))\n        for field in fields(self):\n            s += f\"{field.name:<{max_length+1}}: {getattr(self, field.name)}\\n\"\n        return s\n\n    def __getitem__(self, key: str) -> Any:\n        \"\"\"Access the configuration options by key, separated by dots.\"\"\"\n        try:\n            current_selection = self\n            for attr in key.split(\".\"):\n                current_selection = getattr(current_selection, attr)\n            return current_selection\n        except KeyError:\n            raise KeyError(f\"Invalid key path: '{key}'\")\n\n    def __setitem__(self, key: str, value: Any) -> None:\n        \"\"\"Set the configuration options by key, separated by dots.\"\"\"\n        current_selection = self\n        keys = key.split(\".\")\n        for attr in keys[:-1]:\n            current_selection = getattr(current_selection, attr)\n        setattr(current_selection, keys[-1], value)\n\n    def __getattr__(self, name: str) -> Any:\n        # handle aliases\n        actual_name = self._field_aliases.get(name, name)\n        return super().__getattribute__(actual_name)\n\n    def _ipython_key_completions_(self) -> Generator[str, None, None]:\n        for key, obj in self.__dict__.items():\n            yield key\n            for subkey in getattr(obj, \"__dict__\", {}).keys():\n                yield f\"{key}.{subkey}\"\n\n    @classmethod\n    def from_dict(cls, config: dict):\n        \"\"\"Create an instance of the dataclass from a dictionary of\n        configuration values.\n\n        This method performs the following steps:\n        1. Identifies valid field names and aliases.\n        2. Logs any unknown configuration keys.\n        3. Filters the input dictionary to include only valid keys and aliases.\n        4. Validates the types of the configuration values.\n        5. Creates an instance of the class with the filtered and validated configuration.\n        6. Logs any missing fields that are using default values.\n\n        Args:\n            config: A dictionary containing configuration key-value pairs.\n\n        Returns:\n            An instance of the class initialized with the provided configuration.\n\n        Raises:\n            No exceptions are raised, but various warnings and errors are logged:\n            - Unknown configuration keys are logged as info.\n            - Invalid types for configuration values are logged as errors.\n            - Type checking errors are logged as info.\n            - Missing fields (using defaults) are logged as info.\n\n        Note:\n            - Invalid type values are removed from the configuration.\n            - Aliases are resolved to their corresponding field names.\n        \"\"\"\n        # Get the valid field names\n        valid_fields = {f.name for f in fields(cls)}\n        aliases = set(cls._field_aliases.keys())\n\n        # Check for unknown keys\n        unknown_keys = set(config) - valid_fields - aliases\n        for key in unknown_keys:\n            log.info(f\"Unknown config key: {key}\")\n\n        # Filter the input dictionary to only include valid keys\n        filtered_config = {k: v for k, v in config.items() if k in valid_fields}\n        filtered_config.update(\n            {cls._field_aliases[k]: v for k, v in config.items() if k in aliases}\n        )\n\n        # Validate type of user and project config values\n        resolved_type_hints = get_type_hints(cls)\n        for field_def in fields(cls):\n            if field_def.name in filtered_config:\n                try:\n                    if not isinstance(\n                        filtered_config[field_def.name],\n                        resolved_type_hints[field_def.name],\n                    ):\n                        log.error(\n                            (\n                                f\"Invalid type for config key '{field_def.name}': {filtered_config[field_def.name]}. \"\n                                f\"Requires {field_def.type} \"\n                            )\n                        )\n                        # If the type is invalid, remove the key\n                        filtered_config.pop(field_def.name)\n                except TypeError:\n                    # An error occurred while checking the type, keep the key but log a warning\n                    log.info(\n                        f\"Error checking type for config key '{field_def.name}': {filtered_config[field_def.name]}\"\n                    )\n\n        # Create the instance\n        instance = cls(**filtered_config)\n\n        # Check for missing fields (defaults used)\n        for field_def in fields(cls):\n            if field_def.name not in filtered_config:\n                log.info(\n                    f\"Config key '{field_def.name}' not set; using default: {getattr(instance, field_def.name)}\"\n                )\n\n        return instance",
          "inherited_members": {}
        },
        "_Paths": {
          "name": "_Paths",
          "path": "bamboost._config._Paths",
          "description": "Paths used by bamboost.\n\nThis dataclass contains the paths used by bamboost.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "localDir",
              "annotation": "Path | str",
              "description": null,
              "value": "LOCAL_DIR"
            },
            {
              "name": "cacheDir",
              "annotation": "Path | str",
              "description": null,
              "value": "CACHE_DIR"
            }
          ],
          "attributes": [
            {
              "name": "localDir",
              "description": [
                {
                  "kind": "text",
                  "value": "The directory where the local data is stored."
                }
              ],
              "annotation": "Path | str",
              "value": "field(default=LOCAL_DIR)"
            },
            {
              "name": "cacheDir",
              "description": [
                {
                  "kind": "text",
                  "value": "The directory where the cache is stored."
                }
              ],
              "annotation": "Path | str",
              "value": "field(default=CACHE_DIR)"
            }
          ],
          "docstring": [],
          "functions": {
            "__setattr__": {
              "name": "__setattr__",
              "path": "bamboost._config._Paths.__setattr__",
              "signature": "(self, name, value) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "value",
                  "annotation": "Any",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def __setattr__(self, name: str, value: Any, /) -> None:\n    if isinstance(value, str):\n        value = Path(value).expanduser()\n    super().__setattr__(name, value)"
            },
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._Paths.__init__",
              "signature": "(self, localDir=LOCAL_DIR, cacheDir=CACHE_DIR) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "localDir",
                  "annotation": "Path | str",
                  "description": null,
                  "value": "LOCAL_DIR"
                },
                {
                  "name": "cacheDir",
                  "annotation": "Path | str",
                  "description": null,
                  "value": "CACHE_DIR"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass(repr=False)\nclass _Paths(_Base):\n    \"\"\"Paths used by bamboost.\n\n    This dataclass contains the paths used by bamboost.\n\n    Attributes:\n        localDir: The directory where the local data is stored.\n        cacheDir: The directory where the cache is stored.\n    \"\"\"\n\n    localDir: Path | str = field(default=LOCAL_DIR)\n    cacheDir: Path | str = field(default=CACHE_DIR)\n\n    def __setattr__(self, name: str, value: Any, /) -> None:\n        if isinstance(value, str):\n            value = Path(value).expanduser()\n        super().__setattr__(name, value)",
          "inherited_members": {
            "bamboost._config._Base": [
              {
                "kind": "attribute",
                "path": "bamboost._config._Base._field_aliases"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__repr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__setitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getattr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base._ipython_key_completions_"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.from_dict"
              }
            ]
          }
        },
        "_Options": {
          "name": "_Options",
          "path": "bamboost._config._Options",
          "description": "Core options for bamboost.\n\nThis dataclass contains the core options for bamboost.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "mpi",
              "annotation": "bool",
              "description": null,
              "value": "importlib.util.find_spec('mpi4py') is not None"
            },
            {
              "name": "sortTableKey",
              "annotation": "str",
              "description": null,
              "value": "'time_stamp'"
            },
            {
              "name": "sortTableOrder",
              "annotation": "str",
              "description": null,
              "value": "'desc'"
            }
          ],
          "attributes": [
            {
              "name": "mpi",
              "description": [
                {
                  "kind": "text",
                  "value": "If True, the mpi4py package is available and used."
                }
              ],
              "annotation": "bool",
              "value": "field(default=importlib.util.find_spec('mpi4py') is not None)"
            },
            {
              "name": "sortTableKey",
              "description": [
                {
                  "kind": "text",
                  "value": "The default key to sort the table by."
                }
              ],
              "annotation": "str",
              "value": "field(default='time_stamp')"
            },
            {
              "name": "sortTableOrder",
              "description": [
                {
                  "kind": "text",
                  "value": "The default order to sort the table by."
                }
              ],
              "annotation": "str",
              "value": "field(default='desc')"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._Options.__init__",
              "signature": "(self, mpi=importlib.util.find_spec('mpi4py') is not None, sortTableKey='time_stamp', sortTableOrder='desc') -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "mpi",
                  "annotation": "bool",
                  "description": null,
                  "value": "importlib.util.find_spec('mpi4py') is not None"
                },
                {
                  "name": "sortTableKey",
                  "annotation": "str",
                  "description": null,
                  "value": "'time_stamp'"
                },
                {
                  "name": "sortTableOrder",
                  "annotation": "str",
                  "description": null,
                  "value": "'desc'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass(repr=False)\nclass _Options(_Base):\n    \"\"\"Core options for bamboost.\n\n    This dataclass contains the core options for bamboost.\n\n    Attributes:\n        mpi: If True, the mpi4py package is available and used.\n        sortTableKey: The default key to sort the table by.\n        sortTableOrder: The default order to sort the table by.\n    \"\"\"\n\n    mpi: bool = field(default=importlib.util.find_spec(\"mpi4py\") is not None)\n    sortTableKey: str = field(default=\"time_stamp\")\n    sortTableOrder: str = field(default=\"desc\")",
          "inherited_members": {
            "bamboost._config._Base": [
              {
                "kind": "attribute",
                "path": "bamboost._config._Base._field_aliases"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__repr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__setitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getattr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base._ipython_key_completions_"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.from_dict"
              }
            ]
          }
        },
        "_IndexOptions": {
          "name": "_IndexOptions",
          "path": "bamboost._config._IndexOptions",
          "description": "Index options for bamboost.\n\nThis dataclass contains the index options for bamboost.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "searchPaths",
              "annotation": "Iterable",
              "description": null,
              "value": "lambda: PathSet([Path('~').expanduser()])()"
            },
            {
              "name": "syncTables",
              "annotation": "bool",
              "description": null,
              "value": "True"
            },
            {
              "name": "convertArrays",
              "annotation": "bool",
              "description": null,
              "value": "True"
            },
            {
              "name": "databaseFileName",
              "annotation": "str",
              "description": null,
              "value": "DATABASE_FILE_NAME"
            },
            {
              "name": "isolated",
              "annotation": "bool",
              "description": null,
              "value": "False"
            }
          ],
          "attributes": [
            {
              "name": "_field_aliases",
              "annotation": null,
              "description": null,
              "value": "{'paths': 'searchPaths'}"
            },
            {
              "name": "searchPaths",
              "description": [
                {
                  "kind": "text",
                  "value": "A list of paths to index."
                }
              ],
              "annotation": "Iterable",
              "value": "field(default_factory=lambda: PathSet([Path('~').expanduser()]))"
            },
            {
              "name": "syncTables",
              "description": [
                {
                  "kind": "text",
                  "value": "If True, the sqlite tables are synchronized immediatly\nafter some queries."
                }
              ],
              "annotation": "bool",
              "value": "field(default=True)"
            },
            {
              "name": "convertArrays",
              "description": [
                {
                  "kind": "text",
                  "value": "If True, arrays are converted to np.arrays."
                }
              ],
              "annotation": "bool",
              "value": "True"
            },
            {
              "name": "databaseFileName",
              "description": [
                {
                  "kind": "text",
                  "value": "The name of the database file."
                }
              ],
              "annotation": "str",
              "value": "field(default=DATABASE_FILE_NAME)"
            },
            {
              "name": "databaseFile",
              "description": [
                {
                  "kind": "text",
                  "value": "The path to the database file."
                }
              ],
              "annotation": "Path | str",
              "value": "field(init=False)"
            },
            {
              "name": "isolated",
              "description": [
                {
                  "kind": "text",
                  "value": "If true, this project manages it's own database. The\nsearchPaths are reduced to the project root only."
                }
              ],
              "annotation": "bool",
              "value": "False"
            }
          ],
          "docstring": [],
          "functions": {
            "__post_init__": {
              "name": "__post_init__",
              "path": "bamboost._config._IndexOptions.__post_init__",
              "signature": "(self) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def __post_init__(self) -> None:\n    # Parse search paths to Path objects\n    self.searchPaths = PathSet(\n        Path(p).expanduser() if isinstance(p, str) else p for p in self.searchPaths\n    )\n\n    # Handle isolated mode\n    if self.isolated:\n        ROOT_DIR.joinpath(\".bamboost_cache\").mkdir(parents=True, exist_ok=True)\n        self.databaseFile = ROOT_DIR.joinpath(\".bamboost_cache\", \"bamboost.sqlite\")\n        self.searchPaths = PathSet([ROOT_DIR])\n    else:\n        self.databaseFile = LOCAL_DIR.joinpath(self.databaseFileName)"
            },
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._IndexOptions.__init__",
              "signature": "(self, searchPaths=lambda: PathSet([Path('~').expanduser()])(), syncTables=True, convertArrays=True, databaseFileName=DATABASE_FILE_NAME, isolated=False) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "searchPaths",
                  "annotation": "Iterable",
                  "description": null,
                  "value": "lambda: PathSet([Path('~').expanduser()])()"
                },
                {
                  "name": "syncTables",
                  "annotation": "bool",
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "convertArrays",
                  "annotation": "bool",
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "databaseFileName",
                  "annotation": "str",
                  "description": null,
                  "value": "DATABASE_FILE_NAME"
                },
                {
                  "name": "isolated",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": ""
            }
          },
          "source": "@dataclass(repr=False)\nclass _IndexOptions(_Base):\n    \"\"\"Index options for bamboost.\n\n    This dataclass contains the index options for bamboost.\n\n    Attributes:\n        searchPaths: A list of paths to index.\n        syncTables: If True, the sqlite tables are synchronized immediatly\n            after some queries.\n        convertArrays: If True, arrays are converted to np.arrays.\n        databaseFileName: The name of the database file.\n        databaseFile: The path to the database file.\n        isolated: If true, this project manages it's own database. The\n            searchPaths are reduced to the project root only.\n    \"\"\"\n\n    _field_aliases = {\n        \"paths\": \"searchPaths\",\n    }\n\n    searchPaths: Iterable[Union[str, Path]] = field(\n        default_factory=lambda: PathSet([Path(\"~\").expanduser()])\n    )\n    syncTables: bool = field(default=True)\n    convertArrays: bool = True\n    databaseFileName: str = field(default=DATABASE_FILE_NAME)\n    databaseFile: Path | str = field(init=False)\n    isolated: bool = False\n\n    def __post_init__(self) -> None:\n        # Parse search paths to Path objects\n        self.searchPaths = PathSet(\n            Path(p).expanduser() if isinstance(p, str) else p for p in self.searchPaths\n        )\n\n        # Handle isolated mode\n        if self.isolated:\n            ROOT_DIR.joinpath(\".bamboost_cache\").mkdir(parents=True, exist_ok=True)\n            self.databaseFile = ROOT_DIR.joinpath(\".bamboost_cache\", \"bamboost.sqlite\")\n            self.searchPaths = PathSet([ROOT_DIR])\n        else:\n            self.databaseFile = LOCAL_DIR.joinpath(self.databaseFileName)",
          "inherited_members": {
            "bamboost._config._Base": [
              {
                "kind": "function",
                "path": "bamboost._config._Base.__repr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__setitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getattr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base._ipython_key_completions_"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.from_dict"
              }
            ]
          }
        },
        "_Config": {
          "name": "_Config",
          "path": "bamboost._config._Config",
          "description": "Configuration class for bamboost.\n\nThis class manages the configuration options and index settings for bamboost.\nIt loads the configuration from a file and provides access to the options\nand index attributes.",
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            }
          ],
          "attributes": [
            {
              "name": "paths",
              "description": [
                {
                  "kind": "text",
                  "value": "Paths used by bamboost."
                }
              ],
              "annotation": "_Paths",
              "value": "_Paths.from_dict(config.pop('paths', {}))"
            },
            {
              "name": "options",
              "description": [
                {
                  "kind": "text",
                  "value": "Configuration options for bamboost."
                }
              ],
              "annotation": "_Options",
              "value": "_Options.from_dict(config.pop('options', {}))"
            },
            {
              "name": "index",
              "description": [
                {
                  "kind": "text",
                  "value": "Index settings for bamboost."
                }
              ],
              "annotation": "_IndexOptions",
              "value": "_IndexOptions.from_dict(config.pop('index', {}))"
            }
          ],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboost._config._Config.__init__",
              "signature": "(self) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self) -> None:\n    global_config = _get_global_config(CONFIG_FILE)\n    project_config = _get_project_config()\n\n    def nested_update(d: MutableMapping, u: MutableMapping) -> MutableMapping:\n        for k, v in u.items():\n            d[k] = (\n                nested_update(d.get(k, {}), v)\n                if isinstance(v, MutableMapping)\n                else v\n            )\n        return d\n\n    config = nested_update(global_config, project_config)\n\n    self.paths = _Paths.from_dict(config.pop(\"paths\", {}))\n    self.options = _Options.from_dict(config.pop(\"options\", {}))\n    self.index = _IndexOptions.from_dict(config.pop(\"index\", {}))\n\n    # Log unknown config options\n    for key in global_config.keys():\n        log.info(f\"Unknown config table: {key}\")"
            },
            "__repr__": {
              "name": "__repr__",
              "path": "bamboost._config._Config.__repr__",
              "signature": "(self) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def __repr__(self) -> str:\n    s = str()\n    for field in fields(self):\n        s += f\"> {field.name.upper()}\\n\"\n        s += getattr(self, field.name).__repr__()\n        s += \"\\n\"\n    return s"
            }
          },
          "source": "@dataclass(repr=False, init=False)\nclass _Config(_Base):\n    \"\"\"Configuration class for bamboost.\n\n    This class manages the configuration options and index settings for bamboost.\n    It loads the configuration from a file and provides access to the options\n    and index attributes.\n\n    Attributes:\n        paths: Paths used by bamboost.\n        options: Configuration options for bamboost.\n        index: Index settings for bamboost.\n    \"\"\"\n\n    paths: _Paths\n    options: _Options\n    index: _IndexOptions\n\n    def __init__(self) -> None:\n        global_config = _get_global_config(CONFIG_FILE)\n        project_config = _get_project_config()\n\n        def nested_update(d: MutableMapping, u: MutableMapping) -> MutableMapping:\n            for k, v in u.items():\n                d[k] = (\n                    nested_update(d.get(k, {}), v)\n                    if isinstance(v, MutableMapping)\n                    else v\n                )\n            return d\n\n        config = nested_update(global_config, project_config)\n\n        self.paths = _Paths.from_dict(config.pop(\"paths\", {}))\n        self.options = _Options.from_dict(config.pop(\"options\", {}))\n        self.index = _IndexOptions.from_dict(config.pop(\"index\", {}))\n\n        # Log unknown config options\n        for key in global_config.keys():\n            log.info(f\"Unknown config table: {key}\")\n\n    def __repr__(self) -> str:\n        s = str()\n        for field in fields(self):\n            s += f\"> {field.name.upper()}\\n\"\n            s += getattr(self, field.name).__repr__()\n            s += \"\\n\"\n        return s",
          "inherited_members": {
            "bamboost._config._Base": [
              {
                "kind": "attribute",
                "path": "bamboost._config._Base._field_aliases"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__setitem__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.__getattr__"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base._ipython_key_completions_"
              },
              {
                "kind": "function",
                "path": "bamboost._config._Base.from_dict"
              }
            ]
          }
        }
      },
      "functions": {
        "_find_root_dir": {
          "name": "_find_root_dir",
          "path": "bamboost._config._find_root_dir",
          "signature": "() -> Path",
          "description": "Find the root directory.",
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": "pathlib.Path",
            "description": null
          },
          "docstring": [],
          "source": "def _find_root_dir() -> Path:\n    \"\"\"Find the root directory.\"\"\"\n\n    ANCHORS = [\n        \".git\",\n        \"pyproject.toml\",\n    ]\n\n    cwd = Path.cwd()\n    for path in chain([cwd], cwd.parents):\n        if any(path.joinpath(anchor).exists() for anchor in ANCHORS):\n            return path\n\n    log.warning(\"Root directory not found. Using current directory.\")\n    return cwd"
        },
        "_get_global_config": {
          "name": "_get_global_config",
          "path": "bamboost._config._get_global_config",
          "signature": "(filepath) -> dict[str, Any]",
          "description": "Reads the configuration file and fills the configuration options.",
          "parameters": [
            {
              "name": "filepath",
              "annotation": "Path",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "dict[str, typing.Any]",
            "description": null
          },
          "docstring": [],
          "source": "def _get_global_config(filepath: Path) -> dict[str, Any]:\n    \"\"\"Reads the configuration file and fills the configuration options.\"\"\"\n    if not filepath.exists():\n        log.warning(\"Config file not found. Using default settings.\")\n        return {}\n\n    with filepath.open(\"rb\") as f:\n        try:\n            return tomli.load(f)\n        except tomli.TOMLDecodeError as e:\n            log.error(f\"Error reading config file: {e}\")\n            return {}"
        },
        "_get_project_config": {
          "name": "_get_project_config",
          "path": "bamboost._config._get_project_config",
          "signature": "() -> dict[str, Any]",
          "description": "Get the project configuration.",
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": "dict[str, typing.Any]",
            "description": null
          },
          "docstring": [],
          "source": "def _get_project_config() -> dict[str, Any]:\n    \"\"\"Get the project configuration.\"\"\"\n    with ROOT_DIR.joinpath(\"pyproject.toml\").open(\"rb\") as f:\n        try:\n            return tomli.load(f).get(\"tool\", {}).get(\"bamboost\", {})\n        except tomli.TOMLDecodeError as e:\n            log.error(f\"Error reading project config file: {e}\")\n            return {}"
        }
      }
    },
    "utilities": {
      "name": "utilities",
      "path": "bamboost.utilities",
      "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/utilities.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "_R",
          "annotation": null,
          "description": null,
          "value": "TypeVar('_R')"
        }
      ],
      "modules": {},
      "classes": {
        "PathSet": {
          "name": "PathSet",
          "path": "bamboost.utilities.PathSet",
          "description": null,
          "parameters": [
            {
              "name": "self",
              "annotation": null,
              "description": null,
              "value": null
            },
            {
              "name": "iterable",
              "annotation": "Optional",
              "description": null,
              "value": "None"
            }
          ],
          "attributes": [],
          "docstring": [],
          "functions": {
            "__init__": {
              "name": "__init__",
              "path": "bamboost.utilities.PathSet.__init__",
              "signature": "(self, iterable=None) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "iterable",
                  "annotation": "Optional",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def __init__(self, iterable: Optional[Iterable[StrPath]] = None) -> None:\n    super().__init__(Path(arg).resolve().expanduser() for arg in iterable or [])"
            },
            "add": {
              "name": "add",
              "path": "bamboost.utilities.PathSet.add",
              "signature": "(self, element) -> None",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "element",
                  "annotation": "Union",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def add(self, element: Union[str, Path], /) -> None:\n    return super().add(Path(element).resolve().expanduser())"
            }
          },
          "source": "class PathSet(set[Path]):\n    def __init__(self, iterable: Optional[Iterable[StrPath]] = None) -> None:\n        super().__init__(Path(arg).resolve().expanduser() for arg in iterable or [])\n\n    def add(self, element: Union[str, Path], /) -> None:\n        return super().add(Path(element).resolve().expanduser())",
          "inherited_members": {}
        }
      },
      "functions": {
        "maybe_apply": {
          "name": "maybe_apply",
          "path": "bamboost.utilities.maybe_apply",
          "signature": "(func) -> Callable[[Optional[_T]], Optional[_U]]",
          "description": null,
          "parameters": [
            {
              "name": "func",
              "annotation": "Callable",
              "description": null,
              "value": null
            }
          ],
          "returns": {
            "name": "",
            "annotation": "typing.Callable[[typing.Optional[bamboost._typing._T]], typing.Optional[bamboost._typing._U]]",
            "description": null
          },
          "docstring": [],
          "source": "def maybe_apply(func: Callable[[_T], _U]) -> Callable[[Optional[_T]], Optional[_U]]:\n    def function(x: Optional[_T]) -> Optional[_U]:\n        if x is not None:\n            return func(x)\n\n    return function"
        },
        "compose_while_not_none": {
          "name": "compose_while_not_none",
          "path": "bamboost.utilities.compose_while_not_none",
          "signature": "(first_func, *funcs) -> Callable[_P, Optional[Any]]",
          "description": "Compose multiple functions into a single function. The output of each\nfunction is passed as the input to the next function. The functions are\napplied from left to right. If a function returns `None`, the next function\nis not called and `None` is returned.",
          "parameters": [
            {
              "name": "first_func",
              "annotation": "Callable",
              "description": null,
              "value": null
            },
            {
              "name": "funcs",
              "annotation": "Callable",
              "description": null,
              "value": "()"
            }
          ],
          "returns": {
            "name": "Callable",
            "annotation": "typing.Callable",
            "description": "The composed function."
          },
          "docstring": [],
          "source": "def compose_while_not_none(\n    first_func: Callable[_P, Any], *funcs: Callable\n) -> Callable[_P, Optional[Any]]:\n    \"\"\"Compose multiple functions into a single function. The output of each\n    function is passed as the input to the next function. The functions are\n    applied from left to right. If a function returns `None`, the next function\n    is not called and `None` is returned.\n\n    Args:\n        *funcs: Functions to compose.\n\n    Returns:\n        Callable: The composed function.\n    \"\"\"\n    funcs = (first_func, *funcs)\n\n    def function(f: Callable, g: Callable) -> Callable:\n        def composed(*x: Any) -> Any:\n            result = f(*x)\n            if result is None:\n                return None\n            else:\n                return g(result)\n\n        return composed\n\n    return reduce(function, funcs)"
        }
      }
    },
    "core": {
      "name": "core",
      "path": "bamboost.core",
      "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "utilities": {
          "name": "utilities",
          "path": "bamboost.core.utilities",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/utilities.py",
          "description": "Utility functions used by bamboost.",
          "docstring": [],
          "attributes": [
            {
              "name": "__all__",
              "annotation": null,
              "description": null,
              "value": "['flatten_dict', 'unflatten_dict', 'tree', 'h5_tree', 'show_differences', 'to_camel_case']"
            },
            {
              "name": "space",
              "annotation": null,
              "description": null,
              "value": "'    '"
            },
            {
              "name": "branch",
              "annotation": null,
              "description": null,
              "value": "'\u2502   '"
            },
            {
              "name": "tee",
              "annotation": null,
              "description": null,
              "value": "'\u251c\u2500\u2500 '"
            },
            {
              "name": "last",
              "annotation": null,
              "description": null,
              "value": "'\u2514\u2500\u2500 '"
            },
            {
              "name": "JobArguments",
              "annotation": null,
              "description": null,
              "value": "NamedTuple('JobArguments', [('db_path', Path), ('name', str), ('submit', bool), ('note', str)])"
            },
            {
              "name": "ScriptArguments",
              "annotation": null,
              "description": null,
              "value": "NamedTuple('ScriptArguments', [('simulation', str)])"
            }
          ],
          "modules": {},
          "classes": {
            "FilePicker": {
              "name": "FilePicker",
              "path": "bamboost.core.utilities.FilePicker",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "path",
                  "annotation": "Path",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "path",
                  "annotation": null,
                  "description": null,
                  "value": "path"
                },
                {
                  "name": "_dict",
                  "annotation": null,
                  "description": null,
                  "value": "self._build_file_dict(path)"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.utilities.FilePicker.__init__",
                  "signature": "(self, path)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "Path",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, path: Path):\n    self.path = path\n    self._dict = self._build_file_dict(path)"
                },
                "_build_file_dict": {
                  "name": "_build_file_dict",
                  "path": "bamboost.core.utilities.FilePicker._build_file_dict",
                  "signature": "(self, path) -> dict",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "Path",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "dict",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _build_file_dict(self, path: Path) -> dict:\n    file_dict = {}\n    for f in path.iterdir():\n        if f.is_dir():\n            subdir_dict = self._build_file_dict(f)\n            file_dict.update({f\"{f.name}/{k}\": v for k, v in subdir_dict.items()})\n        else:\n            file_dict[f.name] = f.absolute()\n    return file_dict"
                },
                "__getitem__": {
                  "name": "__getitem__",
                  "path": "bamboost.core.utilities.FilePicker.__getitem__",
                  "signature": "(self, key) -> Path",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "pathlib.Path",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getitem__(self, key) -> Path:\n    return self._dict[key]"
                },
                "_ipython_key_completions_": {
                  "name": "_ipython_key_completions_",
                  "path": "bamboost.core.utilities.FilePicker._ipython_key_completions_",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _ipython_key_completions_(self):\n    return tuple(self._dict.keys())"
                },
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.core.utilities.FilePicker.__repr__",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self):\n    return tree(self.path)"
                }
              },
              "source": "class FilePicker:\n    def __init__(self, path: Path):\n        self.path = path\n        self._dict = self._build_file_dict(path)\n\n    def _build_file_dict(self, path: Path) -> dict:\n        file_dict = {}\n        for f in path.iterdir():\n            if f.is_dir():\n                subdir_dict = self._build_file_dict(f)\n                file_dict.update({f\"{f.name}/{k}\": v for k, v in subdir_dict.items()})\n            else:\n                file_dict[f.name] = f.absolute()\n        return file_dict\n\n    def __getitem__(self, key) -> Path:\n        return self._dict[key]\n\n    def _ipython_key_completions_(self):\n        return tuple(self._dict.keys())\n\n    def __repr__(self):\n        return tree(self.path)",
              "inherited_members": {}
            }
          },
          "functions": {
            "flatten_dict": {
              "name": "flatten_dict",
              "path": "bamboost.core.utilities.flatten_dict",
              "signature": "(dictionary, parent_key='', seperator='.') -> dict",
              "description": null,
              "parameters": [
                {
                  "name": "dictionary",
                  "annotation": "Mapping",
                  "description": null,
                  "value": null
                },
                {
                  "name": "parent_key",
                  "annotation": null,
                  "description": null,
                  "value": "''"
                },
                {
                  "name": "seperator",
                  "annotation": null,
                  "description": null,
                  "value": "'.'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "dict",
                "description": null
              },
              "docstring": [],
              "source": "def flatten_dict(dictionary: Mapping, parent_key=\"\", seperator=\".\") -> dict:\n    items = []\n    for key, value in dictionary.items():\n        new_key = parent_key + seperator + key if parent_key else key\n        if isinstance(value, MutableMapping):\n            items.extend(flatten_dict(value, new_key, seperator=seperator).items())\n        else:\n            items.append((new_key, value))\n    return dict(items)"
            },
            "unflatten_dict": {
              "name": "unflatten_dict",
              "path": "bamboost.core.utilities.unflatten_dict",
              "signature": "(dictionary, seperator='.') -> dict",
              "description": null,
              "parameters": [
                {
                  "name": "dictionary",
                  "annotation": "dict",
                  "description": null,
                  "value": null
                },
                {
                  "name": "seperator",
                  "annotation": "str",
                  "description": null,
                  "value": "'.'"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "dict",
                "description": null
              },
              "docstring": [],
              "source": "def unflatten_dict(dictionary: dict, seperator: str = \".\") -> dict:\n    new_dict = dict()\n    for key, value in dictionary.items():\n        parts = key.split(seperator)\n        d = new_dict\n        for part in parts[:-1]:\n            if part not in d:\n                d[part] = dict()\n            d = d[part]\n        d[parts[-1]] = value\n    return new_dict"
            },
            "tree": {
              "name": "tree",
              "path": "bamboost.core.utilities.tree",
              "signature": "(dir_path, level=-1, limit_to_directories=False, length_limit=1000) -> str",
              "description": "Given a directory Path object print a visual tree structure",
              "parameters": [
                {
                  "name": "dir_path",
                  "annotation": "Path",
                  "description": null,
                  "value": null
                },
                {
                  "name": "level",
                  "annotation": "int",
                  "description": null,
                  "value": "-1"
                },
                {
                  "name": "limit_to_directories",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "length_limit",
                  "annotation": "int",
                  "description": null,
                  "value": "1000"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def tree(\n    dir_path: Path,\n    level: int = -1,\n    limit_to_directories: bool = False,\n    length_limit: int = 1000,\n) -> str:\n    \"\"\"Given a directory Path object print a visual tree structure\"\"\"\n    dir_path = Path(dir_path)  # accept string coerceable to Path\n    files = 0\n    directories = 0\n    folder_symbol = \"\\U00002b57 \"\n\n    def inner(dir_path: Path, prefix: str = \"\", level=-1):\n        nonlocal files, directories\n        if not level:\n            return  # 0, stop iterating\n        if limit_to_directories:\n            contents = [d for d in dir_path.iterdir() if d.is_dir()]\n        else:\n            contents = list(dir_path.iterdir())\n        pointers = [tee] * (len(contents) - 1) + [last]\n        for pointer, path in zip(pointers, contents):\n            if path.is_dir():\n                yield prefix + pointer + \"\\U000025cc \" + path.name\n                directories += 1\n                extension = branch if pointer == tee else space\n                yield from inner(path, prefix=prefix + extension, level=level - 1)\n            elif not limit_to_directories:\n                yield prefix + pointer + path.name\n                files += 1\n\n    tree_string = \"\"\n    tree_string += (folder_symbol + dir_path.name) + \"\\n\"\n    iterator = inner(dir_path, level=level)\n    for line in islice(iterator, length_limit):\n        tree_string += (line) + \"\\n\"\n    if next(iterator, None):\n        tree_string += (f\"... length_limit, {length_limit}, reached, counted:\") + \"\\n\"\n    tree_string += (\n        f\"\\n{directories} directories\" + (f\", {files} files\" if files else \"\")\n    ) + \"\\n\"\n    return tree_string"
            },
            "h5_tree": {
              "name": "h5_tree",
              "path": "bamboost.core.utilities.h5_tree",
              "signature": "(val, pre='')",
              "description": null,
              "parameters": [
                {
                  "name": "val",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "pre",
                  "annotation": null,
                  "description": null,
                  "value": "''"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def h5_tree(val, pre=\"\"):\n    import h5py\n\n    items = len(val)\n    for key, val in val.items():\n        items -= 1\n        if items == 0:\n            # the last item\n            if isinstance(val, h5py.Group):\n                print(pre + \"\u2514\u2500\u2500 \" + key)\n                h5_tree(val, pre + \"    \")\n            else:\n                print(pre + \"\u2514\u2500\u2500 \" + key + \" (%d)\" % len(val))\n        else:\n            if isinstance(val, h5py.Group):\n                print(pre + \"\u251c\u2500\u2500 \" + key)\n                h5_tree(val, pre + \"\u2502   \")\n            else:\n                print(pre + \"\u251c\u2500\u2500 \" + key + \" (%d)\" % len(val))"
            },
            "show_differences": {
              "name": "show_differences",
              "path": "bamboost.core.utilities.show_differences",
              "signature": "(df) -> DataFrame",
              "description": "This function takes a pandas DataFrame as input and returns a modified\nDataFrame that shows only the columns which have differences.\n\nThe function first creates a copy of the input DataFrame to work with. It\nthen iterates over each column in the DataFrame and tries to calculate the\nnumber of unique values in that column. If successful, it adds the column\nname and number of unique values to a list of good results. If there is an\nerror, it attempts to apply json.dumps to the column and then calculate the\nnumber of unique values again. If this is successful, it also adds the\ncolumn name and number of unique values to the list of good results. If\nthere is still an error, it adds the column name and the error to a list of\nerrors.\n\nAfter processing all columns, the function removes any columns that had\nerrors from the DataFrame. It then sets the index of the DataFrame to 'id'\nand filters out any columns that have only one unique value. The modified\nDataFrame is then returned.",
              "parameters": [
                {
                  "name": "df",
                  "annotation": "pd.DataFrame",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The input DataFrame to analyze"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "pandas.DataFrame",
                "description": "pd.DataFrame"
              },
              "docstring": [],
              "source": "def show_differences(df: \"DataFrame\") -> \"DataFrame\":\n    \"\"\"This function takes a pandas DataFrame as input and returns a modified\n    DataFrame that shows only the columns which have differences.\n\n    The function first creates a copy of the input DataFrame to work with. It\n    then iterates over each column in the DataFrame and tries to calculate the\n    number of unique values in that column. If successful, it adds the column\n    name and number of unique values to a list of good results. If there is an\n    error, it attempts to apply json.dumps to the column and then calculate the\n    number of unique values again. If this is successful, it also adds the\n    column name and number of unique values to the list of good results. If\n    there is still an error, it adds the column name and the error to a list of\n    errors.\n\n    After processing all columns, the function removes any columns that had\n    errors from the DataFrame. It then sets the index of the DataFrame to 'id'\n    and filters out any columns that have only one unique value. The modified\n    DataFrame is then returned.\n\n    Args:\n        df (pd.DataFrame): The input DataFrame to analyze\n\n    Returns:\n        pd.DataFrame\n    \"\"\"\n    import json\n\n    df_diff = df.copy()\n    cols_nunique_good = []\n    cols_nunique_error = []\n    for col in df_diff.columns:\n        try:\n            nunique = df_diff[col].nunique()\n            cols_nunique_good.append((col, nunique))\n        except Exception:\n            try:\n                df_diff[col] = df_diff[col].apply(json.dumps)\n                nunique = df_diff[col].nunique()\n                cols_nunique_good.append((col, nunique))\n            except TypeError as e:\n                cols_nunique_error.append((col, e))\n\n    df_diff = df_diff[\n        df_diff.columns[~df_diff.columns.isin([col for col, _ in cols_nunique_error])]\n    ]\n    try:\n        df_diff.set_index(\"id\", inplace=True)\n    except KeyError:\n        pass\n    df_diff = df_diff.loc[:, (df_diff.nunique() != 1)]\n    df_diff.dropna(axis=1, how=\"all\", inplace=True)\n    return df_diff"
            },
            "to_camel_case": {
              "name": "to_camel_case",
              "path": "bamboost.core.utilities.to_camel_case",
              "signature": "(s) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "s",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def to_camel_case(s: str) -> str:\n    words = s.split()\n    camel_case = words[0].lower() + \"\".join([word.capitalize() for word in words[1:]])\n    return camel_case"
            },
            "parse_job_arguments": {
              "name": "parse_job_arguments",
              "path": "bamboost.core.utilities.parse_job_arguments",
              "signature": "() -> JobArguments",
              "description": "Parse command-line arguments for submitting a job to a bamboost database.",
              "parameters": [],
              "returns": {
                "name": "JobArguments",
                "annotation": "bamboost.core.utilities.JobArguments",
                "description": "A named tuple containing the parsed arguments."
              },
              "docstring": [],
              "source": "def parse_job_arguments() -> JobArguments:\n    \"\"\"Parse command-line arguments for submitting a job to a bamboost database.\n\n    Returns:\n        JobArguments: A named tuple containing the parsed arguments.\n    \"\"\"\n    parser = ArgumentParser(description=\"Submit a job to a bamboost database\")\n\n    # Add the database path argument\n    parser.add_argument(\"db_path\", type=Path, help=\"Path to the bamboost database\")\n    # Add the name argument as optional\n    parser.add_argument(\"name\", type=str, nargs=\"?\", help=\"Name of the simulation\")\n    # Add the submit flag as optional\n    parser.add_argument(\"--submit\", \"-s\", help=\"Submit the job\", action=\"store_true\")\n    # Add note\n    parser.add_argument(\n        \"--note\", \"-n\", help=\"Add a note to this job\", type=str, default=\"\"\n    )\n\n    args = parser.parse_args()\n\n    return JobArguments(\n        db_path=args.db_path, name=args.name, submit=args.submit, note=args.note\n    )"
            },
            "parse_script_arguments": {
              "name": "parse_script_arguments",
              "path": "bamboost.core.utilities.parse_script_arguments",
              "signature": "() -> ScriptArguments",
              "description": "Parse command-line arguments for a script using the bamboost system.",
              "parameters": [],
              "returns": {
                "name": "ScriptArguments",
                "annotation": "bamboost.core.utilities.ScriptArguments",
                "description": "A named tuple containing the parsed arguments."
              },
              "docstring": [],
              "source": "def parse_script_arguments() -> ScriptArguments:\n    \"\"\"Parse command-line arguments for a script using the bamboost system.\n\n    Returns:\n        ScriptArguments: A named tuple containing the parsed arguments.\n    \"\"\"\n    parser = ArgumentParser(description=\"Submit a job to a bamboost database\")\n\n    # Add the simulation UID argument\n    parser.add_argument(\n        \"--simulation\", type=str, help=\"UID of the simulation\", required=True\n    )\n\n    args = parser.parse_args()\n\n    return ScriptArguments(simulation=args.simulation)"
            }
          }
        },
        "manager": {
          "name": "manager",
          "path": "bamboost.core.manager",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/manager.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "__all__",
              "annotation": null,
              "description": null,
              "value": "['Collection', 'NotACollectionError']"
            },
            {
              "name": "log",
              "annotation": null,
              "description": null,
              "value": "BAMBOOST_LOGGER.getChild('Collection')"
            }
          ],
          "modules": {},
          "classes": {
            "NotACollectionError": {
              "name": "NotACollectionError",
              "path": "bamboost.core.manager.NotACollectionError",
              "description": "Raised when a path is not a valid collection.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "path",
                  "annotation": "Path",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.manager.NotACollectionError.__init__",
                  "signature": "(self, path)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "Path",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, path: Path):\n    super().__init__(f\"{path} is not a valid collection.\")"
                }
              },
              "source": "class NotACollectionError(NotADirectoryError):\n    \"\"\"Raised when a path is not a valid collection.\"\"\"\n\n    def __init__(self, path: Path):\n        super().__init__(f\"{path} is not a valid collection.\")",
              "inherited_members": {}
            },
            "_CollectionPicker": {
              "name": "_CollectionPicker",
              "path": "bamboost.core.manager._CollectionPicker",
              "description": null,
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__getitem__": {
                  "name": "__getitem__",
                  "path": "bamboost.core.manager._CollectionPicker.__getitem__",
                  "signature": "(self, key) -> Collection",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "key",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.core.manager.Collection",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getitem__(self, key: str, /) -> Collection:\n    key = key.split(\" - \", 1)[0]\n    return Collection(uid=key)"
                },
                "_ipython_key_completions_": {
                  "name": "_ipython_key_completions_",
                  "path": "bamboost.core.manager._CollectionPicker._ipython_key_completions_",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _ipython_key_completions_(self):\n    return (f\"{i.uid} - {i.path[-30:]}\" for i in DEFAULT_INDEX.all_collections)"
                }
              },
              "source": "class _CollectionPicker:\n    def __getitem__(self, key: str, /) -> Collection:\n        key = key.split(\" - \", 1)[0]\n        return Collection(uid=key)\n\n    def _ipython_key_completions_(self):\n        return (f\"{i.uid} - {i.path[-30:]}\" for i in DEFAULT_INDEX.all_collections)",
              "inherited_members": {}
            },
            "Collection": {
              "name": "Collection",
              "path": "bamboost.core.manager.Collection",
              "description": "View of database.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "path",
                  "annotation": "Optional",
                  "description": [
                    {
                      "kind": "text",
                      "value": "path to the directory of the database. If doesn't exist,\na new database will be created."
                    }
                  ],
                  "value": "None"
                },
                {
                  "name": "uid",
                  "annotation": "Optional",
                  "description": [
                    {
                      "kind": "text",
                      "value": "UID of the database"
                    }
                  ],
                  "value": "None"
                },
                {
                  "name": "create_if_not_exist",
                  "annotation": "bool",
                  "description": null,
                  "value": "True"
                },
                {
                  "name": "comm",
                  "annotation": "Optional",
                  "description": [
                    {
                      "kind": "text",
                      "value": "MPI communicator"
                    }
                  ],
                  "value": "None"
                },
                {
                  "name": "index_instance",
                  "annotation": "Optional",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "FROZEN",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "uid",
                  "annotation": "CollectionUID",
                  "description": null,
                  "value": "CollectionUID(uid or self._index.resolve_uid(self.path))"
                },
                {
                  "name": "path",
                  "annotation": "Path",
                  "description": null,
                  "value": "Path(path or self._index.resolve_path(uid.upper())).absolute()"
                },
                {
                  "name": "fromUID",
                  "annotation": null,
                  "description": null,
                  "value": "_CollectionPicker()"
                },
                {
                  "name": "_comm",
                  "annotation": null,
                  "description": null,
                  "value": "comm or MPI.COMM_WORLD"
                },
                {
                  "name": "_index",
                  "annotation": null,
                  "description": null,
                  "value": "index_instance or Index(comm=self._comm)"
                },
                {
                  "name": "_orm",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "df",
                  "annotation": "pd.DataFrame",
                  "description": [
                    {
                      "kind": "text",
                      "value": "View of the collection and its parametric space."
                    },
                    {
                      "kind": "returns",
                      "value": [
                        {
                          "name": "",
                          "annotation": "pd.DataFrame",
                          "description": "A dataframe of the collection"
                        }
                      ]
                    }
                  ],
                  "value": null
                }
              ],
              "docstring": [
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "example",
                    "description": ">>> db = Manager(\"path/to/db\")\n>>> db.df # DataFrame of the database"
                  },
                  "title": "Example"
                }
              ],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.core.manager.Collection.__init__",
                  "signature": "(self, path=None, *, uid=None, create_if_not_exist=True, comm=None, index_instance=None)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "uid",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "create_if_not_exist",
                      "annotation": "bool",
                      "description": null,
                      "value": "True"
                    },
                    {
                      "name": "comm",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "index_instance",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(\n    self,\n    path: Optional[StrPath] = None,\n    *,\n    uid: Optional[str] = None,\n    create_if_not_exist: bool = True,\n    comm: Optional[Comm] = None,\n    index_instance: Optional[Index] = None,\n):\n    assert path or uid, \"Either path or uid must be provided.\"\n    assert not (path and uid), \"Only one of path or uid must be provided.\"\n\n    self._comm = comm or MPI.COMM_WORLD\n    self._index = index_instance or Index(comm=self._comm)\n\n    # Resolve the path\n    self.path = Path(path or self._index.resolve_path(uid.upper())).absolute()\n    if not self.path.is_dir():\n        if not create_if_not_exist:\n            raise NotADirectoryError(\"Specified path does not exist.\")\n\n        self.path.mkdir(parents=True, exist_ok=False)  # create the directory\n        log.info(f\"Initialized directory for collection at {path}\")\n\n    # Resolve or get an UID for the collection\n    self.uid = CollectionUID(uid or self._index.resolve_uid(self.path))\n\n    # Check if identifier file exists\n    if not self.path.joinpath(get_identifier_filename(uid=self.uid)).exists():\n        create_identifier_file(self.path, self.uid)\n\n    # Sync the SQL table with the filesystem\n    # Making sure the collection is up to date in the index\n    self._index.sync_collection(self.uid, self.path)\n    # Wait for root process to finish syncing\n    self._comm.barrier()"
                },
                "__len__": {
                  "name": "__len__",
                  "path": "bamboost.core.manager.Collection.__len__",
                  "signature": "(self) -> int",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "int",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __len__(self) -> int:\n    return len(self._orm.simulations)"
                },
                "__getitem__": {
                  "name": "__getitem__",
                  "path": "bamboost.core.manager.Collection.__getitem__",
                  "signature": "(self, name) -> Simulation",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.core.simulation.base.Simulation",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __getitem__(self, name: str) -> Simulation:\n    return Simulation(name, self.path, self._comm)"
                },
                "_ipython_key_completions_": {
                  "name": "_ipython_key_completions_",
                  "path": "bamboost.core.manager.Collection._ipython_key_completions_",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@cache\ndef _ipython_key_completions_(self):\n    return tuple(s.name for s in self._orm.simulations)"
                },
                "_repr_html_": {
                  "name": "_repr_html_",
                  "path": "bamboost.core.manager.Collection._repr_html_",
                  "signature": "(self) -> str",
                  "description": "HTML repr for ipython/notebooks. Uses string replacement to fill the\ntemplate code.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _repr_html_(self) -> str:\n    \"\"\"HTML repr for ipython/notebooks. Uses string replacement to fill the\n    template code.\n    \"\"\"\n    html_string = pkgutil.get_data(\"bamboost\", \"_repr/manager.html\").decode()\n    icon = pkgutil.get_data(\"bamboost\", \"_repr/icon.txt\").decode()\n    return (\n        html_string.replace(\"$ICON\", icon)\n        .replace(\"$db_path\", f\"<a href={self.path.as_posix()}>{self.path}</a>\")\n        .replace(\"$db_uid\", self.uid)\n        .replace(\"$db_size\", str(len(self)))\n    )"
                },
                "sync_cache": {
                  "name": "sync_cache",
                  "path": "bamboost.core.manager.Collection.sync_cache",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def sync_cache(self):\n    self._index.sync_collection(self.uid, self.path)"
                },
                "create_simulation": {
                  "name": "create_simulation",
                  "path": "bamboost.core.manager.Collection.create_simulation",
                  "signature": "(self, name=None, parameters=None, *, description=None, files=None, links=None, override=False) -> SimulationWriter",
                  "description": "Get a writer object for a new simulation. This is written for paralell use\nas it is likely that this may be used in an executable, creating multiple runs\nfor a parametric space, which may be run in paralell.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "parameters",
                      "annotation": "Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Parameter dictionary. If provided, the parameters will be\nchecked against the existing sims for duplication. Otherwise, they may be\nspecified later with `bamboost.simulation_writer.SimulationWriter.add_parameters`.\nNote:\n    The parameters are stored in the h5 file as attributes.\n    - If the value is a dict, it is flattened using\n      `bamboost.common.utilities.flatten_dict`.\n    - If the value is a list/array, it is stored as a dataset."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "description",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "files",
                      "annotation": "Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "List of files to copy to the simulation directory."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "links",
                      "annotation": "Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Dictionary of links to other simulations."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "override",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.core.simulation.base.SimulationWriter",
                    "description": "A simulation writer object."
                  },
                  "docstring": [
                    {
                      "kind": "admonition",
                      "value": {
                        "annotation": "note",
                        "description": "The files and links are copied to the simulation directory. The files are\ncopied with the same name as the original file. The links are copied with\nthe given name."
                      },
                      "title": "Note"
                    },
                    {
                      "kind": "examples",
                      "value": [
                        [
                          "examples",
                          ">>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})"
                        ],
                        [
                          "examples",
                          ">>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")"
                        ]
                      ]
                    }
                  ],
                  "source": "def create_simulation(\n    self,\n    name: Optional[str] = None,\n    parameters: Optional[Dict[str, Any]] = None,\n    *,\n    description: Optional[str] = None,\n    files: Optional[Iterable[str]] = None,\n    links: Optional[Dict[str, str]] = None,\n    override: bool = False,\n) -> SimulationWriter:\n    \"\"\"Get a writer object for a new simulation. This is written for paralell use\n    as it is likely that this may be used in an executable, creating multiple runs\n    for a parametric space, which may be run in paralell.\n\n    Args:\n        uid: The name/uid for the simulation. If not specified, a random id\n            will be assigned.\n        parameters: Parameter dictionary. If provided, the parameters will be\n            checked against the existing sims for duplication. Otherwise, they may be\n            specified later with `bamboost.simulation_writer.SimulationWriter.add_parameters`.\n            Note:\n                The parameters are stored in the h5 file as attributes.\n                - If the value is a dict, it is flattened using\n                  `bamboost.common.utilities.flatten_dict`.\n                - If the value is a list/array, it is stored as a dataset.\n        skip_duplicate_check: if True, the duplicate check is skipped.\n        prefix: Prefix for the uid. If not specified, no prefix is used.\n        duplicate_action: how to deal with duplicates. Replace\n            first duplicate ('r'), Create with altered uid (`c`), Create new\n            with new id (`n`), Abort (`a`) default \"prompt\" for each\n            duplicate on a case by case basis.\n        note: Note for the simulation.\n        files: List of files to copy to the simulation directory.\n        links: Dictionary of links to other simulations.\n\n    Note:\n        The files and links are copied to the simulation directory. The files are\n        copied with the same name as the original file. The links are copied with\n        the given name.\n\n    Examples:\n        >>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})\n\n        >>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")\n\n    Returns:\n        A simulation writer object.\n    \"\"\"\n    import shutil\n\n    name = SimulationName(name)  # Generates a unique id as name if not provided\n    directory = self.path.joinpath(name)\n\n    try:\n        # Check if name is already in use, otherwise create a new directory\n        if self._comm.rank == 0:\n            if override and directory.exists():\n                shutil.rmtree(directory)\n            directory.mkdir(exist_ok=False)\n        self._comm.barrier()\n\n        # Create the simulation instance\n        sim = SimulationWriter(\n            name, self.path, self._comm, self._index, collection_uid=self.uid\n        )\n        with self._index.sql_transaction(), sim._file.open(\"w\", driver=\"mpio\"):\n            sim.initialize()  # create groups, set metadata and status\n            sim.metadata[\"description\"] = description or \"\"\n            sim.parameters.update(parameters or {})\n            sim.links.update(links or {})\n            sim.copy_files(files or [])\n\n        # Invalidate the file_map such that it is reloaded\n        sim._file.file_map.invalidate()\n\n        log.info(f\"Created simulation {name} in {self.path}\")\n        return sim\n    except (OSError, ValueError, PermissionError):\n        log.error(\n            f\"Error occurred while creating simulation {name} at path {self.path}\"\n        )\n        shutil.rmtree(directory)\n        raise"
                },
                "find": {
                  "name": "find",
                  "path": "bamboost.core.manager.Collection.find",
                  "signature": "(self, parameter_selection) -> pd.DataFrame",
                  "description": "Find simulations with the given parameters.\n\nThe dictionary can contain callables to filter inequalities or other\nfilters.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parameter_selection",
                      "annotation": "dict",
                      "description": [
                        {
                          "kind": "text",
                          "value": "parameter selection dictionary"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "pandas.pandas.DataFrame",
                    "description": null
                  },
                  "docstring": [
                    {
                      "kind": "examples",
                      "value": [
                        [
                          "examples",
                          ">>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n>>> db.find({\"a\": 1, \"b\": 2})"
                        ]
                      ]
                    }
                  ],
                  "source": "def find(self, parameter_selection: dict[str, Any]) -> pd.DataFrame:\n    \"\"\"Find simulations with the given parameters.\n\n    The dictionary can contain callables to filter inequalities or other\n    filters.\n\n    Examples:\n        >>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n        >>> db.find({\"a\": 1, \"b\": 2})\n\n    Args:\n        parameter_selection (dict): parameter selection dictionary\n    \"\"\"\n    parameter_selection = flatten_dict(parameter_selection)\n    params = {}\n    filters = {}\n    for key, val in parameter_selection.items():\n        if callable(val):\n            filters[key] = val\n        else:\n            params[key] = val\n\n    df = self.df\n    matches = self._list_duplicates(params, df=df)\n    matches = df[df.id.isin(matches)]\n    if len(matches) == 0:\n        return matches\n\n    for key, func in filters.items():\n        matches = matches[matches[key].apply(func)]\n\n    return matches"
                },
                "_list_duplicates": {
                  "name": "_list_duplicates",
                  "path": "bamboost.core.manager.Collection._list_duplicates",
                  "signature": "(self, parameters, *, df=None) -> list[str]",
                  "description": "List ids of duplicates of the given parameters.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parameters",
                      "annotation": "dict",
                      "description": [
                        {
                          "kind": "text",
                          "value": "parameter dictionary"
                        }
                      ]
                    },
                    {
                      "name": "df",
                      "annotation": "pd.DataFrame",
                      "description": [
                        {
                          "kind": "text",
                          "value": "dataframe to search in. If not provided, the\ndataframe from the sql database is used."
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "list[str]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _list_duplicates(\n    self, parameters: dict, *, df: pd.DataFrame = None\n) -> list[str]:\n    \"\"\"List ids of duplicates of the given parameters.\n\n    Args:\n        parameters (dict): parameter dictionary\n        df (pd.DataFrame): dataframe to search in. If not provided, the\n            dataframe from the sql database is used.\n    \"\"\"\n    if df is None:\n        df: pd.DataFrame = self._table.read_table()\n    params = flatten_dict(parameters)\n\n    class ComparableIterable:\n        def __init__(self, ori):\n            self.ori = np.asarray(ori)\n\n        def __eq__(self, other):\n            other = np.asarray(other)\n            if other.shape != self.ori.shape:\n                return False\n            return (other == self.ori).all()\n\n    # make all iterables comparable by converting them to ComparableIterable\n    for k in params.keys():\n        if isinstance(params[k], Iterable) and not isinstance(params[k], str):\n            params[k] = ComparableIterable(params[k])\n\n    # if any of the parameters is not in the dataframe, no duplicates\n    for p in params:\n        if p not in df.keys():\n            return []\n\n    # get matching rows where all values of the series are equal to the corresponding values in the dataframe\n    s = pd.Series(params)\n    match = df.loc[(df[s.keys()].apply(lambda row: (s == row).all(), axis=1))]\n    return match.id.tolist()"
                },
                "_check_duplicate": {
                  "name": "_check_duplicate",
                  "path": "bamboost.core.manager.Collection._check_duplicate",
                  "signature": "(self, parameters, uid, duplicate_action='prompt') -> tuple",
                  "description": "Checking whether the parameters dictionary exists already.\nMay need to be improved...",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parameters",
                      "annotation": "`dict`",
                      "description": [
                        {
                          "kind": "text",
                          "value": "parameter dictionary to check for"
                        }
                      ]
                    },
                    {
                      "name": "uid",
                      "annotation": "`str`",
                      "description": [
                        {
                          "kind": "text",
                          "value": "uid"
                        }
                      ]
                    },
                    {
                      "name": "duplicate_action",
                      "annotation": "str",
                      "description": null,
                      "value": "'prompt'"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "tuple",
                    "description": null
                  },
                  "docstring": [
                    {
                      "kind": "text",
                      "value": "Returns:\n    Tuple(Bool, uid) wheter to continue and with what uid."
                    }
                  ],
                  "source": "def _check_duplicate(\n    self, parameters: dict, uid: str, duplicate_action: str = \"prompt\"\n) -> tuple:\n    \"\"\"Checking whether the parameters dictionary exists already.\n    May need to be improved...\n\n    Args:\n        parameters (`dict`): parameter dictionary to check for\n        uid (`str`): uid\n    Returns:\n        Tuple(Bool, uid) wheter to continue and with what uid.\n    \"\"\"\n\n    duplicates = self._list_duplicates(parameters)\n\n    if not duplicates:\n        return True, uid\n\n    print(\n        \"The parameter space already exists. Here are the duplicates:\",\n        flush=True,\n    )\n    print(self.df[self.df[\"id\"].isin([i for i in duplicates])], flush=True)\n\n    if duplicate_action == \"prompt\":\n        # What should be done?\n        prompt = input(\n            f\"Replace first duplicate [{duplicates[0]}] ('r'), Create with altered uid (`c`), \"\n            + \"Create new with new id (`n`), Abort (`a`): \"\n        )\n    else:\n        prompt = duplicate_action\n\n    if prompt == \"r\":\n        self.remove(duplicates[0])\n        return True, uid\n    if prompt == \"a\":\n        return False, uid\n    if prompt == \"n\":\n        return True, uid\n    if prompt == \"c\":\n        return True, self._generate_subuid(duplicates[0].split(\".\")[0])\n\n    raise ArgumentError(\"Answer not valid! Aborting\")"
                }
              },
              "source": "class Collection:\n    \"\"\"View of database.\n\n    Args:\n        path: path to the directory of the database. If doesn't exist,\n            a new database will be created.\n        comm: MPI communicator\n        uid: UID of the database\n\n    Attributes:\n        ...\n\n    Example:\n        >>> db = Manager(\"path/to/db\")\n        >>> db.df # DataFrame of the database\n    \"\"\"\n\n    FROZEN = False  # TODO: If true, the collection doesn't look for new simulations after initialization\n    uid: CollectionUID\n    path: Path\n    fromUID = _CollectionPicker()\n\n    def __init__(\n        self,\n        path: Optional[StrPath] = None,\n        *,\n        uid: Optional[str] = None,\n        create_if_not_exist: bool = True,\n        comm: Optional[Comm] = None,\n        index_instance: Optional[Index] = None,\n    ):\n        assert path or uid, \"Either path or uid must be provided.\"\n        assert not (path and uid), \"Only one of path or uid must be provided.\"\n\n        self._comm = comm or MPI.COMM_WORLD\n        self._index = index_instance or Index(comm=self._comm)\n\n        # Resolve the path\n        self.path = Path(path or self._index.resolve_path(uid.upper())).absolute()\n        if not self.path.is_dir():\n            if not create_if_not_exist:\n                raise NotADirectoryError(\"Specified path does not exist.\")\n\n            self.path.mkdir(parents=True, exist_ok=False)  # create the directory\n            log.info(f\"Initialized directory for collection at {path}\")\n\n        # Resolve or get an UID for the collection\n        self.uid = CollectionUID(uid or self._index.resolve_uid(self.path))\n\n        # Check if identifier file exists\n        if not self.path.joinpath(get_identifier_filename(uid=self.uid)).exists():\n            create_identifier_file(self.path, self.uid)\n\n        # Sync the SQL table with the filesystem\n        # Making sure the collection is up to date in the index\n        self._index.sync_collection(self.uid, self.path)\n        # Wait for root process to finish syncing\n        self._comm.barrier()\n\n    @property\n    def _orm(self):\n        return self._index.collection(self.uid)\n\n    def __len__(self) -> int:\n        return len(self._orm.simulations)\n\n    def __getitem__(self, name: str) -> Simulation:\n        return Simulation(name, self.path, self._comm)\n\n    @cache\n    def _ipython_key_completions_(self):\n        return tuple(s.name for s in self._orm.simulations)\n\n    def _repr_html_(self) -> str:\n        \"\"\"HTML repr for ipython/notebooks. Uses string replacement to fill the\n        template code.\n        \"\"\"\n        html_string = pkgutil.get_data(\"bamboost\", \"_repr/manager.html\").decode()\n        icon = pkgutil.get_data(\"bamboost\", \"_repr/icon.txt\").decode()\n        return (\n            html_string.replace(\"$ICON\", icon)\n            .replace(\"$db_path\", f\"<a href={self.path.as_posix()}>{self.path}</a>\")\n            .replace(\"$db_uid\", self.uid)\n            .replace(\"$db_size\", str(len(self)))\n        )\n\n    @property\n    def df(self) -> pd.DataFrame:\n        \"\"\"View of the collection and its parametric space.\n\n        Returns:\n            A dataframe of the collection\n        \"\"\"\n        import pandas as pd\n\n        df = pd.DataFrame.from_records(\n            [sim.as_dict(standalone=False) for sim in self._orm.simulations]\n        )\n        # Try to sort the dataframe with the user specified key\n        try:\n            df.sort_values(\n                config.options.sortTableKey,\n                inplace=True,\n                ascending=config.options.sortTableOrder == \"asc\",\n                ignore_index=True,\n            )\n        except KeyError:\n            pass\n\n        return df\n\n    def sync_cache(self):\n        self._index.sync_collection(self.uid, self.path)\n\n    def create_simulation(\n        self,\n        name: Optional[str] = None,\n        parameters: Optional[Dict[str, Any]] = None,\n        *,\n        description: Optional[str] = None,\n        files: Optional[Iterable[str]] = None,\n        links: Optional[Dict[str, str]] = None,\n        override: bool = False,\n    ) -> SimulationWriter:\n        \"\"\"Get a writer object for a new simulation. This is written for paralell use\n        as it is likely that this may be used in an executable, creating multiple runs\n        for a parametric space, which may be run in paralell.\n\n        Args:\n            uid: The name/uid for the simulation. If not specified, a random id\n                will be assigned.\n            parameters: Parameter dictionary. If provided, the parameters will be\n                checked against the existing sims for duplication. Otherwise, they may be\n                specified later with `bamboost.simulation_writer.SimulationWriter.add_parameters`.\n                Note:\n                    The parameters are stored in the h5 file as attributes.\n                    - If the value is a dict, it is flattened using\n                      `bamboost.common.utilities.flatten_dict`.\n                    - If the value is a list/array, it is stored as a dataset.\n            skip_duplicate_check: if True, the duplicate check is skipped.\n            prefix: Prefix for the uid. If not specified, no prefix is used.\n            duplicate_action: how to deal with duplicates. Replace\n                first duplicate ('r'), Create with altered uid (`c`), Create new\n                with new id (`n`), Abort (`a`) default \"prompt\" for each\n                duplicate on a case by case basis.\n            note: Note for the simulation.\n            files: List of files to copy to the simulation directory.\n            links: Dictionary of links to other simulations.\n\n        Note:\n            The files and links are copied to the simulation directory. The files are\n            copied with the same name as the original file. The links are copied with\n            the given name.\n\n        Examples:\n            >>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})\n\n            >>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")\n\n        Returns:\n            A simulation writer object.\n        \"\"\"\n        import shutil\n\n        name = SimulationName(name)  # Generates a unique id as name if not provided\n        directory = self.path.joinpath(name)\n\n        try:\n            # Check if name is already in use, otherwise create a new directory\n            if self._comm.rank == 0:\n                if override and directory.exists():\n                    shutil.rmtree(directory)\n                directory.mkdir(exist_ok=False)\n            self._comm.barrier()\n\n            # Create the simulation instance\n            sim = SimulationWriter(\n                name, self.path, self._comm, self._index, collection_uid=self.uid\n            )\n            with self._index.sql_transaction(), sim._file.open(\"w\", driver=\"mpio\"):\n                sim.initialize()  # create groups, set metadata and status\n                sim.metadata[\"description\"] = description or \"\"\n                sim.parameters.update(parameters or {})\n                sim.links.update(links or {})\n                sim.copy_files(files or [])\n\n            # Invalidate the file_map such that it is reloaded\n            sim._file.file_map.invalidate()\n\n            log.info(f\"Created simulation {name} in {self.path}\")\n            return sim\n        except (OSError, ValueError, PermissionError):\n            log.error(\n                f\"Error occurred while creating simulation {name} at path {self.path}\"\n            )\n            shutil.rmtree(directory)\n            raise\n\n    def find(self, parameter_selection: dict[str, Any]) -> pd.DataFrame:\n        \"\"\"Find simulations with the given parameters.\n\n        The dictionary can contain callables to filter inequalities or other\n        filters.\n\n        Examples:\n            >>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n            >>> db.find({\"a\": 1, \"b\": 2})\n\n        Args:\n            parameter_selection (dict): parameter selection dictionary\n        \"\"\"\n        parameter_selection = flatten_dict(parameter_selection)\n        params = {}\n        filters = {}\n        for key, val in parameter_selection.items():\n            if callable(val):\n                filters[key] = val\n            else:\n                params[key] = val\n\n        df = self.df\n        matches = self._list_duplicates(params, df=df)\n        matches = df[df.id.isin(matches)]\n        if len(matches) == 0:\n            return matches\n\n        for key, func in filters.items():\n            matches = matches[matches[key].apply(func)]\n\n        return matches\n\n    def _list_duplicates(\n        self, parameters: dict, *, df: pd.DataFrame = None\n    ) -> list[str]:\n        \"\"\"List ids of duplicates of the given parameters.\n\n        Args:\n            parameters (dict): parameter dictionary\n            df (pd.DataFrame): dataframe to search in. If not provided, the\n                dataframe from the sql database is used.\n        \"\"\"\n        if df is None:\n            df: pd.DataFrame = self._table.read_table()\n        params = flatten_dict(parameters)\n\n        class ComparableIterable:\n            def __init__(self, ori):\n                self.ori = np.asarray(ori)\n\n            def __eq__(self, other):\n                other = np.asarray(other)\n                if other.shape != self.ori.shape:\n                    return False\n                return (other == self.ori).all()\n\n        # make all iterables comparable by converting them to ComparableIterable\n        for k in params.keys():\n            if isinstance(params[k], Iterable) and not isinstance(params[k], str):\n                params[k] = ComparableIterable(params[k])\n\n        # if any of the parameters is not in the dataframe, no duplicates\n        for p in params:\n            if p not in df.keys():\n                return []\n\n        # get matching rows where all values of the series are equal to the corresponding values in the dataframe\n        s = pd.Series(params)\n        match = df.loc[(df[s.keys()].apply(lambda row: (s == row).all(), axis=1))]\n        return match.id.tolist()\n\n    def _check_duplicate(\n        self, parameters: dict, uid: str, duplicate_action: str = \"prompt\"\n    ) -> tuple:\n        \"\"\"Checking whether the parameters dictionary exists already.\n        May need to be improved...\n\n        Args:\n            parameters (`dict`): parameter dictionary to check for\n            uid (`str`): uid\n        Returns:\n            Tuple(Bool, uid) wheter to continue and with what uid.\n        \"\"\"\n\n        duplicates = self._list_duplicates(parameters)\n\n        if not duplicates:\n            return True, uid\n\n        print(\n            \"The parameter space already exists. Here are the duplicates:\",\n            flush=True,\n        )\n        print(self.df[self.df[\"id\"].isin([i for i in duplicates])], flush=True)\n\n        if duplicate_action == \"prompt\":\n            # What should be done?\n            prompt = input(\n                f\"Replace first duplicate [{duplicates[0]}] ('r'), Create with altered uid (`c`), \"\n                + \"Create new with new id (`n`), Abort (`a`): \"\n            )\n        else:\n            prompt = duplicate_action\n\n        if prompt == \"r\":\n            self.remove(duplicates[0])\n            return True, uid\n        if prompt == \"a\":\n            return False, uid\n        if prompt == \"n\":\n            return True, uid\n        if prompt == \"c\":\n            return True, self._generate_subuid(duplicates[0].split(\".\")[0])\n\n        raise ArgumentError(\"Answer not valid! Aborting\")",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "extensions": {
          "name": "extensions",
          "path": "bamboost.core.extensions",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/extensions/__init__.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "extensions",
              "annotation": null,
              "description": null,
              "value": "ExtensionsLazyLoader()"
            }
          ],
          "modules": {
            "slurm": {
              "name": "slurm",
              "path": "bamboost.core.extensions.slurm",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/extensions/slurm.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "__all__",
                  "annotation": null,
                  "description": null,
                  "value": "['install']"
                },
                {
                  "name": "NAME_OF_DICT",
                  "annotation": null,
                  "description": null,
                  "value": "'_slurm'"
                }
              ],
              "modules": {},
              "classes": {},
              "functions": {
                "_extend_enter_slurm_info": {
                  "name": "_extend_enter_slurm_info",
                  "path": "bamboost.core.extensions.slurm._extend_enter_slurm_info",
                  "signature": "(original_enter)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "original_enter",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _extend_enter_slurm_info(original_enter):\n    @wraps(original_enter)\n    def modified_enter(self: SimulationWriter, *args, **kwargs):\n        slurm_job_id = os.environ.get(\"SLURM_JOB_ID\")\n        self.update_metadata({NAME_OF_DICT: {\"jobId\": slurm_job_id}})\n        return original_enter(self, *args, **kwargs)\n\n    return modified_enter"
                },
                "_extend_exit_slurm_info": {
                  "name": "_extend_exit_slurm_info",
                  "path": "bamboost.core.extensions.slurm._extend_exit_slurm_info",
                  "signature": "(original_exit)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "original_exit",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _extend_exit_slurm_info(original_exit):\n    @wraps(original_exit)\n    def modified_exit(self: SimulationWriter, exc_type, exc_value, exc_tb):\n        # Inject the following into the __exit__ method of SimulationWriter\n        slurm_job_id = os.environ.get(\"SLURM_JOB_ID\")\n\n        result = subprocess.run(\n            [\"myjobs\", \"-j\", slurm_job_id], env=os.environ, capture_output=True\n        )\n\n        # Check if the command was successful\n        if result.returncode == 0:\n            # Get the output as a string\n            output_str = result.stdout.decode(\"utf-8\")\n\n            # Create a dictionary to store the key-value pairs\n            slurm_dict = {}\n            for line in output_str.strip().split(\"\\n\"):\n                if \":\" in line:  # Ensure the line contains a key-value pair\n                    key, value = line.split(\":\", 1)  # Split on the first colon\n\n                    # modify key to camelCase\n                    slurm_dict[to_camel_case(key.strip())] = value.strip()\n\n            # _write_slurm_info(self, slurm_dict)\n            self.update_metadata({NAME_OF_DICT: slurm_dict})\n\n        return original_exit(self, exc_type, exc_value, exc_tb)\n\n    return modified_exit"
                },
                "install": {
                  "name": "install",
                  "path": "bamboost.core.extensions.slurm.install",
                  "signature": "()",
                  "description": "Install the slurm extension to the SimulationWriter class. Extends the\n__exit__ method to add slurm metadata.",
                  "parameters": [],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def install():\n    \"\"\"Install the slurm extension to the SimulationWriter class. Extends the\n    __exit__ method to add slurm metadata.\n    \"\"\"\n    SimulationWriter.__exit__ = _extend_exit_slurm_info(SimulationWriter.__exit__)\n    SimulationWriter.__enter__ = _extend_enter_slurm_info(SimulationWriter.__enter__)"
                }
              }
            },
            "fenics": {
              "name": "fenics",
              "path": "bamboost.core.extensions.fenics",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/extensions/fenics.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "__all__",
                  "annotation": null,
                  "description": null,
                  "value": "['FenicsWriter']"
                }
              ],
              "modules": {},
              "classes": {
                "WriteStrategy": {
                  "name": "WriteStrategy",
                  "path": "bamboost.core.extensions.fenics.WriteStrategy",
                  "description": "Enum for write style.",
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "SCATTERED",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    },
                    {
                      "name": "CONTIGUOUS",
                      "annotation": null,
                      "description": null,
                      "value": "1"
                    }
                  ],
                  "docstring": [],
                  "functions": {},
                  "source": "class WriteStrategy(Enum):\n    \"\"\"Enum for write style.\"\"\"\n\n    SCATTERED = 0\n    CONTIGUOUS = 1",
                  "inherited_members": {}
                },
                "FenicsWriter": {
                  "name": "FenicsWriter",
                  "path": "bamboost.core.extensions.fenics.FenicsWriter",
                  "description": "Helper writer for input from FEniCS directly.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Unique identifier for the simulation"
                        }
                      ]
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path to database"
                        }
                      ]
                    },
                    {
                      "name": "comm",
                      "annotation": "MPI.Comm",
                      "description": [
                        {
                          "kind": "text",
                          "value": "MPI communicator"
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "create_if_not_exists",
                      "annotation": "bool",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Create file if it does not exist"
                        }
                      ],
                      "value": "False"
                    },
                    {
                      "name": "write_strategy",
                      "annotation": "WriteStrategy",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Write strategy for the data. Contiguous is faster but\nrequires the entire array to fit in memory of the root process."
                        }
                      ],
                      "value": "WriteStrategy.SCATTERED"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "write_strategy",
                      "annotation": null,
                      "description": null,
                      "value": "WriteStrategy(write_strategy)"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.extensions.fenics.FenicsWriter.__init__",
                      "signature": "(self, uid, path, comm=None, create_if_not_exists=False, write_strategy=WriteStrategy.SCATTERED)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "uid",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "comm",
                          "annotation": "MPI.Comm",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "create_if_not_exists",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        },
                        {
                          "name": "write_strategy",
                          "annotation": "WriteStrategy",
                          "description": null,
                          "value": "WriteStrategy.SCATTERED"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self,\n    uid: str,\n    path: str,\n    comm: MPI.Comm = None,\n    create_if_not_exists: bool = False,\n    write_strategy: WriteStrategy = WriteStrategy.SCATTERED,\n):\n    super().__init__(uid, path, comm)\n    self.write_strategy = WriteStrategy(write_strategy)"
                    },
                    "add_field": {
                      "name": "add_field",
                      "path": "bamboost.core.extensions.fenics.FenicsWriter.add_field",
                      "signature": "(self, name, func, time=None, mesh=None, dtype=None, center='Node') -> None",
                      "description": "Add a dataset to the file. The data is stored at `data/`.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Name for the dataset"
                            }
                          ]
                        },
                        {
                          "name": "func",
                          "annotation": "fe.Function",
                          "description": [
                            {
                              "kind": "text",
                              "value": "FEniCS function to store"
                            }
                          ]
                        },
                        {
                          "name": "time",
                          "annotation": "float",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. time"
                            }
                          ],
                          "value": "None"
                        },
                        {
                          "name": "mesh",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. Linked mesh for this data"
                            }
                          ],
                          "value": "None"
                        },
                        {
                          "name": "dtype",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. Numpy style datatype, see h5py documentation,\ndefaults to the dtype of the vector"
                            }
                          ],
                          "value": "None"
                        },
                        {
                          "name": "center",
                          "annotation": "Literal",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. Center of the data. Can be 'Node' or 'Cell'.\nDefault is 'Node'."
                            }
                          ],
                          "value": "'Node'"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_field(\n    self,\n    name: str,\n    func: fe.Function,\n    time: float = None,\n    mesh: str = None,\n    dtype: str = None,\n    center: Literal[\"Node\", \"Cell\"] = \"Node\",\n) -> None:\n    \"\"\"Add a dataset to the file. The data is stored at `data/`.\n\n    Args:\n        name: Name for the dataset\n        func: FEniCS function to store\n        time: Optional. time\n        mesh: Optional. Linked mesh for this data\n        dtype: Optional. Numpy style datatype, see h5py documentation,\n            defaults to the dtype of the vector\n        center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n            Default is 'Node'.\n    \"\"\"\n    mesh = mesh if mesh is not None else self._default_mesh\n    time = time if time is not None else self.step\n\n    {\n        WriteStrategy.SCATTERED: self._dump_fenics_field,\n        WriteStrategy.CONTIGUOUS: self._dump_fenics_field_on_root,\n    }.get(self.write_strategy)(\n        f\"data/{name}/{self.step}\",\n        func,\n        dtype=dtype,\n        center=center,\n    )\n    self._comm.barrier()  # attempt to fix bug (see SimulationWriter add_field)\n\n    if self._prank == 0:\n        with self._file(\"a\"):\n            vec = self._file[\"data\"][name][str(self.step)]\n            vec.attrs.update({\"center\": center, \"mesh\": mesh, \"t\": time})\n\n    self._comm.barrier()  # attempt to fix bug (see SimulationWriter add_field)"
                    },
                    "_dump_fenics_field": {
                      "name": "_dump_fenics_field",
                      "path": "bamboost.core.extensions.fenics.FenicsWriter._dump_fenics_field",
                      "signature": "(self, location, field, dtype=None, center='Node') -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "location",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "field",
                          "annotation": "fe.Function",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "dtype",
                          "annotation": "str",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "center",
                          "annotation": "Literal",
                          "description": null,
                          "value": "'Node'"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _dump_fenics_field(\n    self,\n    location: str,\n    field: fe.Function,\n    dtype: str = None,\n    center: Literal[\"Node\", \"Cell\"] = \"Node\",\n) -> None:\n    # get global dofs ordering and vector\n    if center == \"Node\":\n        data = self._get_global_dofs(field)\n    elif center == \"Cell\":\n        data = self._get_global_dofs_cell_data(field)\n    else:\n        raise ValueError(\"Center must be 'Node' or 'Cell'.\")\n\n    vector = data[\"vector\"]\n    global_map = data[\"global_map\"]\n    global_size = data[\"global_size\"]\n\n    dim = data[\"vector\"].shape[1:] if data[\"vector\"].ndim > 1 else None\n\n    group_name, dataset_name = location.rstrip(\"/\").rsplit(\"/\", 1)\n\n    # Write vector to file\n    with self._file(\"a\", driver=\"mpio\", comm=self._comm) as f:\n        f = f._h5py_file\n        grp = f.require_group(group_name)\n        vec = grp.require_dataset(\n            dataset_name,\n            shape=(global_size, *dim) if dim else (global_size,),\n            dtype=dtype if dtype else vector.dtype,\n        )\n        vec[global_map] = vector"
                    },
                    "_dump_fenics_field_on_root": {
                      "name": "_dump_fenics_field_on_root",
                      "path": "bamboost.core.extensions.fenics.FenicsWriter._dump_fenics_field_on_root",
                      "signature": "(self, location, field, dtype=None, center='Node') -> None",
                      "description": "Assembles the vector on the root process and writes it to file contiguously.\n\nThis is faster but requires the entire array to fit in memory.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "location",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Location in the HDF5 file"
                            }
                          ]
                        },
                        {
                          "name": "field",
                          "annotation": "fe.Function",
                          "description": [
                            {
                              "kind": "text",
                              "value": "FEniCS function"
                            }
                          ]
                        },
                        {
                          "name": "dtype",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. Numpy style datatype, see h5py documentation,\ndefaults to the dtype of the vector"
                            }
                          ],
                          "value": "None"
                        },
                        {
                          "name": "center",
                          "annotation": "Literal",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. Center of the data. Can be 'Node' or 'Cell'.\nDefault is 'Node'."
                            }
                          ],
                          "value": "'Node'"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _dump_fenics_field_on_root(\n    self,\n    location: str,\n    field: fe.Function,\n    dtype: str = None,\n    center: Literal[\"Node\", \"Cell\"] = \"Node\",\n) -> None:\n    \"\"\"Assembles the vector on the root process and writes it to file contiguously.\n\n    This is faster but requires the entire array to fit in memory.\n\n    Args:\n        location: Location in the HDF5 file\n        field: FEniCS function\n        dtype: Optional. Numpy style datatype, see h5py documentation,\n            defaults to the dtype of the vector\n        center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n            Default is 'Node'.\n    \"\"\"\n    # get global dofs ordering and vector\n    if center == \"Node\":\n        data = self._get_global_dofs(field)\n    elif center == \"Cell\":\n        data = self._get_global_dofs_cell_data(field)\n    else:\n        raise ValueError(\"Center must be 'Node' or 'Cell'.\")\n\n    vector = data[\"vector\"]\n    global_map = data[\"global_map\"]\n    global_size = data[\"global_size\"]\n\n    dim = data[\"vector\"].shape[1:] if data[\"vector\"].ndim > 1 else None\n\n    group_name, dataset_name = location.rstrip(\"/\").rsplit(\"/\", 1)\n\n    vector_p = self._comm.gather(vector)\n    global_map_p = self._comm.gather(global_map)\n\n    # On RAM, construct a contiguous vector on the root process\n    if self._prank == 0:\n        vector_contiguous = np.zeros(\n            (global_size, *dim) if dim else (global_size,), dtype=vector.dtype\n        )\n        for map, vec in zip(global_map_p, vector_p):\n            vector_contiguous[map] = vec\n\n        # Write vector to file\n        with self._file(\"a\") as f:\n            grp = f.require_group(group_name)\n            vec = grp.require_dataset(\n                dataset_name,\n                shape=(global_size, *dim) if dim else (global_size,),\n                dtype=dtype if dtype else vector.dtype,\n            )\n            vec[:] = vector_contiguous"
                    },
                    "_get_global_dofs": {
                      "name": "_get_global_dofs",
                      "path": "bamboost.core.extensions.fenics.FenicsWriter._get_global_dofs",
                      "signature": "(self, func) -> FenicsFieldInformation",
                      "description": "Get global dofs for a given function.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "func",
                          "annotation": "fe.Function",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.extensions.fenics.FenicsWriter.FenicsFieldInformation",
                        "description": "A dict with the local vector, a mapping from the local to the"
                      },
                      "docstring": [],
                      "source": "def _get_global_dofs(self, func: fe.Function) -> FenicsFieldInformation:\n    \"\"\"\n    Get global dofs for a given function.\n\n    Args:\n        - func: Expression/field/function\n\n    Returns:\n        A dict with the local vector, a mapping from the local to the\n        global vertices (both sorted by index because h5py complains if\n        slicing is not continuously increasing), and the number of global\n        vertices.\n    \"\"\"\n    assert hasattr(\n        func, \"function_space\"\n    ), \"Input is likely an indexed coefficient. Project to it's own function space first.\"\n\n    # Project to CG1 if necessary\n    if func.ufl_element().degree() != 1:\n        func = fe.project(\n            func, fe.FunctionSpace(func.function_space().mesh(), \"CG\", 1)\n        )\n\n    mesh = func.function_space().mesh()\n    global_size = mesh.num_entities_global(0)\n    shape = (-1, *func.ufl_shape) if func.ufl_shape else (-1,)\n    val_per_vertex = np.prod(shape[1:]).astype(np.int32) if func.ufl_shape else 1\n\n    dofmap = func.function_space().dofmap()\n    d2v = fe.dof_to_vertex_map(func.function_space())\n    d2v = (\n        d2v[np.arange(0, len(d2v), val_per_vertex, dtype=np.int32)]\n        // val_per_vertex\n    )\n\n    loc0, loc1 = (i // val_per_vertex for i in dofmap.ownership_range())\n    global_vertex_numbers = mesh.topology().global_indices(0)\n    global_vertices = global_vertex_numbers[d2v[: loc1 - loc0]]\n    sort_indices = np.argsort(global_vertices)\n\n    local_vector = (\n        func.vector().get_local().reshape(shape)[: loc1 - loc0][sort_indices]\n    )\n\n    return {\n        \"vector\": local_vector,\n        \"global_map\": global_vertices[sort_indices],\n        \"global_size\": global_size,\n    }"
                    },
                    "_get_global_dofs_cell_data": {
                      "name": "_get_global_dofs_cell_data",
                      "path": "bamboost.core.extensions.fenics.FenicsWriter._get_global_dofs_cell_data",
                      "signature": "(self, func) -> FenicsFieldInformation",
                      "description": "Get global dofs for a given function.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "func",
                          "annotation": "fe.Function",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.extensions.fenics.FenicsWriter.FenicsFieldInformation",
                        "description": "A dict with the local vector, a mapping from the local to the"
                      },
                      "docstring": [],
                      "source": "def _get_global_dofs_cell_data(self, func: fe.Function) -> FenicsFieldInformation:\n    \"\"\"\n    Get global dofs for a given function.\n\n    Args:\n        - func: Expression/field/function\n\n    Returns:\n        A dict with the local vector, a mapping from the local to the\n        global vertices (both sorted by index because h5py complains if\n        slicing is not continuously increasing), and the number of global\n        vertices.\n    \"\"\"\n    V = func.function_space()\n    val_per_vertex = (\n        np.prod(func.ufl_shape).astype(np.int32) if func.ufl_shape else 1\n    )\n\n    mesh = V.mesh()\n    dofmap = V.dofmap()\n\n    local_to_global_indices = dofmap.tabulate_local_to_global_dofs()\n    local_to_global_indices = (\n        local_to_global_indices[\n            np.arange(\n                0, len(local_to_global_indices), val_per_vertex, dtype=np.int32\n            )\n        ]\n        // val_per_vertex\n    )\n    shape = (-1, *func.ufl_shape) if func.ufl_shape else (-1,)\n    local_vector = func.vector().get_local().reshape(shape)\n\n    return {\n        \"vector\": local_vector,\n        \"global_map\": local_to_global_indices,\n        \"global_size\": self._comm.allreduce(mesh.num_cells(), op=MPI.SUM),\n    }"
                    },
                    "add_mesh": {
                      "name": "add_mesh",
                      "path": "bamboost.core.extensions.fenics.FenicsWriter.add_mesh",
                      "signature": "(self, mesh, mesh_name=None) -> None",
                      "description": "Add the mesh to file using fe.HDF5File. I can't figure out how to\nextract the local mesh data in correct order when running in parallel.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh",
                          "annotation": "fe.Mesh",
                          "description": [
                            {
                              "kind": "text",
                              "value": "FEniCS mesh object"
                            }
                          ]
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "name for mesh (default = `mesh`)"
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_mesh(self, mesh: fe.Mesh, mesh_name: str = None) -> None:\n    \"\"\"\n    Add the mesh to file using fe.HDF5File. I can't figure out how to\n    extract the local mesh data in correct order when running in parallel.\n\n    Args:\n        mesh: FEniCS mesh object\n        mesh_name: name for mesh (default = `mesh`)\n    \"\"\"\n    mesh_name = mesh_name if mesh_name is not None else self._default_mesh\n    mesh_location = f\"{self._mesh_location}/{mesh_name}/\"\n\n    assert not self._file._h5py_file, \"File is open -> Quitting\"\n\n    with self.temporary_close_file():\n        with fe.HDF5File(self._comm, self._data_file, \"a\") as f:\n            f.write(mesh, mesh_location)"
                    },
                    "temporary_close_file": {
                      "name": "temporary_close_file",
                      "path": "bamboost.core.extensions.fenics.FenicsWriter.temporary_close_file",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@contextmanager\ndef temporary_close_file(self):\n    was_open = False\n    if self._file._h5py_file:\n        self._file._h5py_file.close()\n        was_open = True\n    try:\n        yield\n    finally:\n        if was_open:\n            self._file._h5py_file = open_h5file(\n                self._file.file,\n                self._file.mode,\n                self._file.driver,\n                self._file.comm,\n            )"
                    }
                  },
                  "source": "class FenicsWriter(SimulationWriter):\n    \"\"\"\n    Helper writer for input from FEniCS directly.\n\n    Args:\n        uid: Unique identifier for the simulation\n        path: Path to database\n        comm: MPI communicator\n        create_if_not_exists: Create file if it does not exist\n        write_strategy: Write strategy for the data. Contiguous is faster but\n            requires the entire array to fit in memory of the root process.\n    \"\"\"\n\n    def __init__(\n        self,\n        uid: str,\n        path: str,\n        comm: MPI.Comm = None,\n        create_if_not_exists: bool = False,\n        write_strategy: WriteStrategy = WriteStrategy.SCATTERED,\n    ):\n        super().__init__(uid, path, comm)\n        self.write_strategy = WriteStrategy(write_strategy)\n\n    def add_field(\n        self,\n        name: str,\n        func: fe.Function,\n        time: float = None,\n        mesh: str = None,\n        dtype: str = None,\n        center: Literal[\"Node\", \"Cell\"] = \"Node\",\n    ) -> None:\n        \"\"\"Add a dataset to the file. The data is stored at `data/`.\n\n        Args:\n            name: Name for the dataset\n            func: FEniCS function to store\n            time: Optional. time\n            mesh: Optional. Linked mesh for this data\n            dtype: Optional. Numpy style datatype, see h5py documentation,\n                defaults to the dtype of the vector\n            center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n                Default is 'Node'.\n        \"\"\"\n        mesh = mesh if mesh is not None else self._default_mesh\n        time = time if time is not None else self.step\n\n        {\n            WriteStrategy.SCATTERED: self._dump_fenics_field,\n            WriteStrategy.CONTIGUOUS: self._dump_fenics_field_on_root,\n        }.get(self.write_strategy)(\n            f\"data/{name}/{self.step}\",\n            func,\n            dtype=dtype,\n            center=center,\n        )\n        self._comm.barrier()  # attempt to fix bug (see SimulationWriter add_field)\n\n        if self._prank == 0:\n            with self._file(\"a\"):\n                vec = self._file[\"data\"][name][str(self.step)]\n                vec.attrs.update({\"center\": center, \"mesh\": mesh, \"t\": time})\n\n        self._comm.barrier()  # attempt to fix bug (see SimulationWriter add_field)\n\n    def _dump_fenics_field(\n        self,\n        location: str,\n        field: fe.Function,\n        dtype: str = None,\n        center: Literal[\"Node\", \"Cell\"] = \"Node\",\n    ) -> None:\n        # get global dofs ordering and vector\n        if center == \"Node\":\n            data = self._get_global_dofs(field)\n        elif center == \"Cell\":\n            data = self._get_global_dofs_cell_data(field)\n        else:\n            raise ValueError(\"Center must be 'Node' or 'Cell'.\")\n\n        vector = data[\"vector\"]\n        global_map = data[\"global_map\"]\n        global_size = data[\"global_size\"]\n\n        dim = data[\"vector\"].shape[1:] if data[\"vector\"].ndim > 1 else None\n\n        group_name, dataset_name = location.rstrip(\"/\").rsplit(\"/\", 1)\n\n        # Write vector to file\n        with self._file(\"a\", driver=\"mpio\", comm=self._comm) as f:\n            f = f._h5py_file\n            grp = f.require_group(group_name)\n            vec = grp.require_dataset(\n                dataset_name,\n                shape=(global_size, *dim) if dim else (global_size,),\n                dtype=dtype if dtype else vector.dtype,\n            )\n            vec[global_map] = vector\n\n    def _dump_fenics_field_on_root(\n        self,\n        location: str,\n        field: fe.Function,\n        dtype: str = None,\n        center: Literal[\"Node\", \"Cell\"] = \"Node\",\n    ) -> None:\n        \"\"\"Assembles the vector on the root process and writes it to file contiguously.\n\n        This is faster but requires the entire array to fit in memory.\n\n        Args:\n            location: Location in the HDF5 file\n            field: FEniCS function\n            dtype: Optional. Numpy style datatype, see h5py documentation,\n                defaults to the dtype of the vector\n            center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n                Default is 'Node'.\n        \"\"\"\n        # get global dofs ordering and vector\n        if center == \"Node\":\n            data = self._get_global_dofs(field)\n        elif center == \"Cell\":\n            data = self._get_global_dofs_cell_data(field)\n        else:\n            raise ValueError(\"Center must be 'Node' or 'Cell'.\")\n\n        vector = data[\"vector\"]\n        global_map = data[\"global_map\"]\n        global_size = data[\"global_size\"]\n\n        dim = data[\"vector\"].shape[1:] if data[\"vector\"].ndim > 1 else None\n\n        group_name, dataset_name = location.rstrip(\"/\").rsplit(\"/\", 1)\n\n        vector_p = self._comm.gather(vector)\n        global_map_p = self._comm.gather(global_map)\n\n        # On RAM, construct a contiguous vector on the root process\n        if self._prank == 0:\n            vector_contiguous = np.zeros(\n                (global_size, *dim) if dim else (global_size,), dtype=vector.dtype\n            )\n            for map, vec in zip(global_map_p, vector_p):\n                vector_contiguous[map] = vec\n\n            # Write vector to file\n            with self._file(\"a\") as f:\n                grp = f.require_group(group_name)\n                vec = grp.require_dataset(\n                    dataset_name,\n                    shape=(global_size, *dim) if dim else (global_size,),\n                    dtype=dtype if dtype else vector.dtype,\n                )\n                vec[:] = vector_contiguous\n\n    class FenicsFieldInformation(TypedDict):\n        vector: np.ndarray\n        global_map: np.ndarray\n        global_size: int\n\n    def _get_global_dofs(self, func: fe.Function) -> FenicsFieldInformation:\n        \"\"\"\n        Get global dofs for a given function.\n\n        Args:\n            - func: Expression/field/function\n\n        Returns:\n            A dict with the local vector, a mapping from the local to the\n            global vertices (both sorted by index because h5py complains if\n            slicing is not continuously increasing), and the number of global\n            vertices.\n        \"\"\"\n        assert hasattr(\n            func, \"function_space\"\n        ), \"Input is likely an indexed coefficient. Project to it's own function space first.\"\n\n        # Project to CG1 if necessary\n        if func.ufl_element().degree() != 1:\n            func = fe.project(\n                func, fe.FunctionSpace(func.function_space().mesh(), \"CG\", 1)\n            )\n\n        mesh = func.function_space().mesh()\n        global_size = mesh.num_entities_global(0)\n        shape = (-1, *func.ufl_shape) if func.ufl_shape else (-1,)\n        val_per_vertex = np.prod(shape[1:]).astype(np.int32) if func.ufl_shape else 1\n\n        dofmap = func.function_space().dofmap()\n        d2v = fe.dof_to_vertex_map(func.function_space())\n        d2v = (\n            d2v[np.arange(0, len(d2v), val_per_vertex, dtype=np.int32)]\n            // val_per_vertex\n        )\n\n        loc0, loc1 = (i // val_per_vertex for i in dofmap.ownership_range())\n        global_vertex_numbers = mesh.topology().global_indices(0)\n        global_vertices = global_vertex_numbers[d2v[: loc1 - loc0]]\n        sort_indices = np.argsort(global_vertices)\n\n        local_vector = (\n            func.vector().get_local().reshape(shape)[: loc1 - loc0][sort_indices]\n        )\n\n        return {\n            \"vector\": local_vector,\n            \"global_map\": global_vertices[sort_indices],\n            \"global_size\": global_size,\n        }\n\n    def _get_global_dofs_cell_data(self, func: fe.Function) -> FenicsFieldInformation:\n        \"\"\"\n        Get global dofs for a given function.\n\n        Args:\n            - func: Expression/field/function\n\n        Returns:\n            A dict with the local vector, a mapping from the local to the\n            global vertices (both sorted by index because h5py complains if\n            slicing is not continuously increasing), and the number of global\n            vertices.\n        \"\"\"\n        V = func.function_space()\n        val_per_vertex = (\n            np.prod(func.ufl_shape).astype(np.int32) if func.ufl_shape else 1\n        )\n\n        mesh = V.mesh()\n        dofmap = V.dofmap()\n\n        local_to_global_indices = dofmap.tabulate_local_to_global_dofs()\n        local_to_global_indices = (\n            local_to_global_indices[\n                np.arange(\n                    0, len(local_to_global_indices), val_per_vertex, dtype=np.int32\n                )\n            ]\n            // val_per_vertex\n        )\n        shape = (-1, *func.ufl_shape) if func.ufl_shape else (-1,)\n        local_vector = func.vector().get_local().reshape(shape)\n\n        return {\n            \"vector\": local_vector,\n            \"global_map\": local_to_global_indices,\n            \"global_size\": self._comm.allreduce(mesh.num_cells(), op=MPI.SUM),\n        }\n\n    def add_mesh(self, mesh: fe.Mesh, mesh_name: str = None) -> None:\n        \"\"\"\n        Add the mesh to file using fe.HDF5File. I can't figure out how to\n        extract the local mesh data in correct order when running in parallel.\n\n        Args:\n            mesh: FEniCS mesh object\n            mesh_name: name for mesh (default = `mesh`)\n        \"\"\"\n        mesh_name = mesh_name if mesh_name is not None else self._default_mesh\n        mesh_location = f\"{self._mesh_location}/{mesh_name}/\"\n\n        assert not self._file._h5py_file, \"File is open -> Quitting\"\n\n        with self.temporary_close_file():\n            with fe.HDF5File(self._comm, self._data_file, \"a\") as f:\n                f.write(mesh, mesh_location)\n\n    @contextmanager\n    def temporary_close_file(self):\n        was_open = False\n        if self._file._h5py_file:\n            self._file._h5py_file.close()\n            was_open = True\n        try:\n            yield\n        finally:\n            if was_open:\n                self._file._h5py_file = open_h5file(\n                    self._file.file,\n                    self._file.mode,\n                    self._file.driver,\n                    self._file.comm,\n                )",
                  "inherited_members": {}
                }
              },
              "functions": {}
            },
            "use_locking": {
              "name": "use_locking",
              "path": "bamboost.core.extensions.use_locking",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/extensions/use_locking.py",
              "description": "This module provides a custom rather primitive file locking mechanism for\nHDF5 files.\n\nThis module provides a function `use_locking` that installs the mechanism by\nMonkey-patching the `FileHandler` class. To use this mechanism, call the\n`use_locking` function at the start of your script, before creating any\n`bamboost.common.file_handler.FileHandler` instances.",
              "docstring": [
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "example",
                    "description": ">>> from bamboost.extensions.use_locking import use_locking\n>>> use_locking(\"shared\")"
                  },
                  "title": "Example"
                }
              ],
              "attributes": [],
              "modules": {},
              "classes": {},
              "functions": {
                "get_lock_and_open_function": {
                  "name": "get_lock_and_open_function",
                  "path": "bamboost.core.extensions.use_locking.get_lock_and_open_function",
                  "signature": "(lock_type) -> Callable[..., Tuple[h5py.File, BufferedReader]]",
                  "description": "Returns a function that locks and opens an HDF5 file with the specified\nlock type.\n\nThe returned function acquires a lock on the lock file and opens the HDF5\nfile, returning both the opened HDF5 file object and the lock file object.\n\nThe returned function takes the following parameters:\n\n| Argument  | Description                                                                 |\n|-----------|-----------------------------------------------------------------------------|\n| file      | The path to the HDF5 file to open.                                          |\n| lock_file | The path to the lock file.                                                  |\n| mode      | The mode to open the file in (e.g., 'r', 'w', 'a').                         |\n| driver    | The HDF5 driver to use (e.g., 'mpio' for MPI-IO).                           |\n| comm      | The MPI communicator (only used with 'mpio' driver).                        |",
                  "parameters": [
                    {
                      "name": "lock_type",
                      "annotation": "Literal",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The type of lock to use."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "Callable",
                    "annotation": "collections.abc.Callable",
                    "description": "A function that locks and opens an HDF5 file."
                  },
                  "docstring": [],
                  "source": "def get_lock_and_open_function(\n    lock_type: Literal[\"shared\", \"exclusive\"],\n) -> Callable[..., Tuple[h5py.File, BufferedReader]]:\n    \"\"\"Returns a function that locks and opens an HDF5 file with the specified\n    lock type.\n\n    The returned function acquires a lock on the lock file and opens the HDF5\n    file, returning both the opened HDF5 file object and the lock file object.\n\n    The returned function takes the following parameters:\n\n    | Argument  | Description                                                                 |\n    |-----------|-----------------------------------------------------------------------------|\n    | file      | The path to the HDF5 file to open.                                          |\n    | lock_file | The path to the lock file.                                                  |\n    | mode      | The mode to open the file in (e.g., 'r', 'w', 'a').                         |\n    | driver    | The HDF5 driver to use (e.g., 'mpio' for MPI-IO).                           |\n    | comm      | The MPI communicator (only used with 'mpio' driver).                        |\n\n    Args:\n        lock_type (Literal[\"shared\", \"exclusive\"]): The type of lock to use.\n\n    Returns:\n        Callable: A function that locks and opens an HDF5 file.\n    \"\"\"\n    lock_type_int = {\"shared\": fcntl.LOCK_SH, \"exclusive\": fcntl.LOCK_EX}[lock_type]\n\n    def lock_and_open(\n        file: str, lock_file: str, mode: str, driver: str, comm: Any\n    ) -> Tuple[h5py.File, BufferedReader]:\n        lock_file_object = open(lock_file, \"rb\")\n        # acquire a lock\n        fcntl.flock(lock_file_object, lock_type_int)\n        # open the file\n        h5_file = open_h5file(file, mode, driver, comm)\n        return h5_file, lock_file_object\n\n    return lock_and_open"
                },
                "close_and_unlock": {
                  "name": "close_and_unlock",
                  "path": "bamboost.core.extensions.use_locking.close_and_unlock",
                  "signature": "(h5_file, lock_file) -> None",
                  "description": "Close an HDF5 file and release the associated file lock.\n\nThis function performs the following operations:\n1. Closes the given HDF5 file.\n2. Releases the lock on the lock file.\n3. Closes the lock file.",
                  "parameters": [
                    {
                      "name": "h5_file",
                      "annotation": "h5py.File",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The HDF5 file object to be closed."
                        }
                      ]
                    },
                    {
                      "name": "lock_file",
                      "annotation": "BufferedReader",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The lock file object to be unlocked and closed."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": "None"
                  },
                  "docstring": [],
                  "source": "def close_and_unlock(h5_file: h5py.File, lock_file: BufferedReader) -> None:\n    \"\"\"Close an HDF5 file and release the associated file lock.\n\n    This function performs the following operations:\n    1. Closes the given HDF5 file.\n    2. Releases the lock on the lock file.\n    3. Closes the lock file.\n\n    Args:\n        h5_file: The HDF5 file object to be closed.\n        lock_file: The lock file object to be unlocked and closed.\n\n    Returns:\n        None\n    \"\"\"\n    h5_file.close()\n    fcntl.flock(lock_file, fcntl.LOCK_UN)\n    lock_file.close()"
                },
                "get_open_method": {
                  "name": "get_open_method",
                  "path": "bamboost.core.extensions.use_locking.get_open_method",
                  "signature": "(lock_type) -> Callable[..., h5py.File]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "lock_type",
                      "annotation": "Literal",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "collections.abc.Callable[..., h5py.h5py.File]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_open_method(\n    lock_type: Literal[\"shared\", \"exclusive\"],\n) -> Callable[..., h5py.File]:\n    open_function = get_lock_and_open_function(lock_type)\n\n    @wraps(FileHandler.open)\n    def _modified_open(self: FileHandler, mode: str = \"r\", driver=None, comm=None):\n        \"\"\"Create a primitive lock file for the file.\n\n        Will replace `file_handler.FileHandler.open` method.\n        \"\"\"\n        if self._context_stack <= 0:\n            # lock_file_access(self.file_name, comm)\n\n            log.debug(f\"[{id(self)}] Open {self.file}\")\n            # self.file_object = open_h5file(self.file_name, mode, driver, comm)\n            self._h5py_file, self._lock_file = open_function(  # type: ignore\n                self.file, self._lock_file_name, mode, driver, comm\n            )\n\n        if _hirarchy_[self._h5py_file.mode] < _hirarchy_[mode]:\n            close_and_unlock(self._h5py_file, self._lock_file)\n            self._h5py_file, self._lock_file = open_function(  # type: ignore\n                self.file, self._lock_file_name, mode, driver, comm\n            )\n\n        log.debug(f\"[{id(self)}] Lock stack {self._context_stack}\")\n        self._context_stack += 1\n        return self._h5py_file\n\n    return _modified_open"
                },
                "_modified_close": {
                  "name": "_modified_close",
                  "path": "bamboost.core.extensions.use_locking._modified_close",
                  "signature": "(self)",
                  "description": "Create a primitive lock for the file.\n\nWill replace `file_handler.FileHandler.close` method.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": "FileHandler",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@wraps(FileHandler.close)\ndef _modified_close(self: FileHandler):\n    \"\"\"Create a primitive lock for the file.\n\n    Will replace `file_handler.FileHandler.close` method.\n    \"\"\"\n    self._context_stack -= 1\n    if self._context_stack == 0:\n        log.debug(f\"[{id(self)}] Close {self.file}\")\n        # self.file_object.close()\n        close_and_unlock(self._h5py_file, self._lock_file)\n\n    log.debug(f\"[{id(self)}] Lock stack {self._context_stack}\")"
                },
                "_extend_init": {
                  "name": "_extend_init",
                  "path": "bamboost.core.extensions.use_locking._extend_init",
                  "signature": "(original_init)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "original_init",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _extend_init(original_init):\n    @wraps(FileHandler.__init__)\n    def _modified_init(self: FileHandler, *args, **kwargs):\n        original_init(self, *args, **kwargs)\n\n        self._lock_file_name = f\"{self.file}.lock\"  # type: ignore\n\n        if not os.path.exists(self._lock_file_name):\n            with open(self._lock_file_name, \"w\") as f:\n                f.write(\"LOCK FILE\")\n\n    return _modified_init"
                },
                "use_locking": {
                  "name": "use_locking",
                  "path": "bamboost.core.extensions.use_locking.use_locking",
                  "signature": "(lock_type) -> None",
                  "description": "Installs a primitive locking mechanism for FileHandler operations.\n\nThis function modifies the FileHandler class to include file locking\ncapabilities, ensuring thread-safe access to files. It wraps the\n`__init__`, `open`, and `close` methods of FileHandler with locking mechanisms.",
                  "parameters": [
                    {
                      "name": "lock_type",
                      "annotation": "Literal",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The type of lock to use.\n- \"shared\" allows multiple processes to open the file simultaneously.\n- \"exclusive\" allows only one reader or writer at a time."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [
                    {
                      "kind": "admonition",
                      "value": {
                        "annotation": "usage",
                        "description": "Call this function before using FileHandler to enable locking:\nuse_locking(\"shared\")  # or use_locking(\"exclusive\")"
                      },
                      "title": "Usage"
                    },
                    {
                      "kind": "admonition",
                      "value": {
                        "annotation": "note",
                        "description": "This function should be called only once, preferably at the start\nof your program, before any FileHandler instances are created."
                      },
                      "title": "Note"
                    },
                    {
                      "kind": "admonition",
                      "value": {
                        "annotation": "note",
                        "description": "You should only need this functionality if you are using HDF5 <= 1.10.6.\nThe newer versions of HDF5 (>= 1.10.7) have built-in file locking."
                      },
                      "title": "Note"
                    }
                  ],
                  "source": "def use_locking(lock_type: Literal[\"shared\", \"exclusive\"]) -> None:\n    \"\"\"Installs a primitive locking mechanism for FileHandler operations.\n\n    This function modifies the FileHandler class to include file locking\n    capabilities, ensuring thread-safe access to files. It wraps the\n    `__init__`, `open`, and `close` methods of FileHandler with locking mechanisms.\n\n    Usage:\n        Call this function before using FileHandler to enable locking:\n        use_locking(\"shared\")  # or use_locking(\"exclusive\")\n\n    Note:\n        This function should be called only once, preferably at the start\n        of your program, before any FileHandler instances are created.\n\n    Note:\n        You should only need this functionality if you are using HDF5 <= 1.10.6.\n        The newer versions of HDF5 (>= 1.10.7) have built-in file locking.\n\n    Args:\n        lock_type (Literal[\"shared\", \"exclusive\"]): The type of lock to use.\n            - \"shared\" allows multiple processes to open the file simultaneously.\n            - \"exclusive\" allows only one reader or writer at a time.\n    \"\"\"\n    if not hasattr(FileHandler.__init__, \"__wrapped__\"):\n        FileHandler.__init__ = _extend_init(FileHandler.__init__)\n\n    if not hasattr(FileHandler.open, \"__wrapped__\"):\n        FileHandler.open = get_open_method(lock_type)\n\n    if not hasattr(FileHandler.close, \"__wrapped__\"):\n        FileHandler.close = _modified_close\n\n    log.info(\"Primitive locking installed\")"
                }
              }
            },
            "remote_manager": {
              "name": "remote_manager",
              "path": "bamboost.core.extensions.remote_manager",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/extensions/remote_manager.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "__all__",
                  "annotation": null,
                  "description": null,
                  "value": "['Remote', 'RemoteManager', 'RemoteSimulation']"
                },
                {
                  "name": "log",
                  "annotation": null,
                  "description": null,
                  "value": "BAMBOOST_LOGGER.getChild(__name__.split('.')[-1])"
                },
                {
                  "name": "HOME",
                  "annotation": null,
                  "description": null,
                  "value": "os.path.expanduser('~')"
                },
                {
                  "name": "CACHE_DIR",
                  "annotation": null,
                  "description": null,
                  "value": "os.path.join(HOME, '.cache', 'bamboost')"
                },
                {
                  "name": "REMOTE_INDEX",
                  "annotation": null,
                  "description": null,
                  "value": "'~/.local/share/bamboost/bamboost.db'"
                }
              ],
              "modules": {},
              "classes": {
                "Remote": {
                  "name": "Remote",
                  "path": "bamboost.core.extensions.remote_manager.Remote",
                  "description": "Access bamboost database of a remote server. The index is fetched using\nrsync over ssh. The `remote_name` can be a hostname or an IP address. Make\nsure that ssh keys are set and working, as there is no user authentication.\nThe `skip_update` flag can be set to avoid fetching the index from the\nremote server.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "remote_name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "skip_update",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    },
                    {
                      "name": "home_path",
                      "annotation": "str",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "remote_name",
                      "annotation": null,
                      "description": null,
                      "value": "remote_name"
                    },
                    {
                      "name": "local_path",
                      "annotation": null,
                      "description": null,
                      "value": "os.path.join(CACHE_DIR, self.remote_name)"
                    },
                    {
                      "name": "file",
                      "annotation": null,
                      "description": null,
                      "value": "f'{self.local_path}/bamboost.db'"
                    }
                  ],
                  "docstring": [
                    {
                      "kind": "admonition",
                      "value": {
                        "annotation": "example",
                        "description": ">>> remote = Remote(\"euler\")\n>>> remote.read_table()\nreturns a pandas DataFrame of the remote index.\n>>> remote[\"<id>\"]\nreturns a RemoteManager object for the given id."
                      },
                      "title": "Example"
                    }
                  ],
                  "functions": {
                    "__new__": {
                      "name": "__new__",
                      "path": "bamboost.core.extensions.remote_manager.Remote.__new__",
                      "signature": "(cls, *args, **kwargs)",
                      "description": "Override the __new__ method to avoid the singleton pattern of IndexAPI.",
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "args",
                          "annotation": null,
                          "description": null,
                          "value": "()"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __new__(cls, *args, **kwargs):\n    \"\"\"Override the __new__ method to avoid the singleton pattern of IndexAPI.\"\"\"\n    return object.__new__(cls)"
                    },
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.extensions.remote_manager.Remote.__init__",
                      "signature": "(self, remote_name, skip_update=False, *, home_path=None) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "remote_name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "skip_update",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        },
                        {
                          "name": "home_path",
                          "annotation": "str",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self, remote_name: str, skip_update: bool = False, *, home_path: str = None\n) -> None:\n    self.remote_name = remote_name\n    self.local_path = os.path.join(CACHE_DIR, self.remote_name)\n    os.makedirs(self.local_path, exist_ok=True)\n    self.file = f\"{self.local_path}/bamboost.db\"\n\n    if not skip_update:\n        process = self.fetch_index()\n        process.wait()\n\n    # Initialize the SQLiteHandler\n    SQLiteHandler.__init__(self, self.file)"
                    },
                    "list": {
                      "name": "list",
                      "path": "bamboost.core.extensions.remote_manager.Remote.list",
                      "signature": "(cls) -> list",
                      "description": "List all remote servers.",
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.extensions.remote_manager.Remote.list",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@classmethod\ndef list(cls) -> list:\n    \"\"\"List all remote servers.\"\"\"\n    return [\n        name\n        for name in os.listdir(CACHE_DIR)\n        if os.path.isdir(os.path.join(CACHE_DIR, name))\n    ]"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.extensions.remote_manager.Remote._ipython_key_completions_",
                      "signature": "(self) -> list[str]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.extensions.remote_manager.Remote.list[str]",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self) -> list[str]:\n    ids = self.get_df()[[\"id\", \"path\"]].values\n    completion_keys = [\n        f'{key} - {\"...\"+val[-25:] if len(val)>=25 else val}' for key, val in ids\n    ]\n    return completion_keys"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.extensions.remote_manager.Remote.__getitem__",
                      "signature": "(self, id) -> RemoteManager",
                      "description": "Return a `RemoteManager` for the given id.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "id",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.extensions.remote_manager.RemoteManager",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, id: str) -> RemoteManager:\n    \"\"\"Return a `RemoteManager` for the given id.\"\"\"\n    id = id.split(\" - \")[0]\n    return RemoteManager(id, remote=self)"
                    },
                    "fetch_index": {
                      "name": "fetch_index",
                      "path": "bamboost.core.extensions.remote_manager.Remote.fetch_index",
                      "signature": "(self) -> subprocess.Popen",
                      "description": "Fetch the index from the remote server.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "subprocess.subprocess.Popen",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def fetch_index(self) -> subprocess.Popen:\n    \"\"\"Fetch the index from the remote server.\"\"\"\n    return subprocess.Popen(\n        [\"rsync\", \"-av\", f\"{self.remote_name}:{REMOTE_INDEX}\", self.file],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n    )"
                    },
                    "get_manager": {
                      "name": "get_manager",
                      "path": "bamboost.core.extensions.remote_manager.Remote.get_manager",
                      "signature": "(self, id, skip_update=False) -> RemoteManager",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "id",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "skip_update",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.extensions.remote_manager.RemoteManager",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def get_manager(self, id: str, skip_update: bool = False) -> RemoteManager:\n    return RemoteManager(id, remote=self, skip_update=skip_update)"
                    },
                    "get_path": {
                      "name": "get_path",
                      "path": "bamboost.core.extensions.remote_manager.Remote.get_path",
                      "signature": "(self, id) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "id",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_connection\ndef get_path(self, id: str) -> str:\n    self.cursor.execute(\"SELECT path FROM dbindex WHERE id=?\", (id,))\n    fetch = self.cursor.fetchone()\n    if fetch is None:\n        raise KeyError(f\"No database found with id: {id}\")\n    else:\n        return fetch[0]"
                    },
                    "insert_local_path": {
                      "name": "insert_local_path",
                      "path": "bamboost.core.extensions.remote_manager.Remote.insert_local_path",
                      "signature": "(self, id, path) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "id",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_connection\ndef insert_local_path(self, id: str, path: str) -> None:\n    try:\n        self.cursor.execute(\n            \"UPDATE dbindex SET local_path=? WHERE id=?\", (path, id)\n        )\n    except sqlite3.OperationalError:\n        self.cursor.execute(\n            \"ALTER TABLE dbindex ADD COLUMN local_path TEXT DEFAULT NULL\"\n        )\n        self.cursor.execute(\n            \"UPDATE dbindex SET local_path=? WHERE id=?\", (path, id)\n        )"
                    }
                  },
                  "source": "class Remote(CollectionsTable, SQLiteHandler):\n    \"\"\"Access bamboost database of a remote server. The index is fetched using\n    rsync over ssh. The `remote_name` can be a hostname or an IP address. Make\n    sure that ssh keys are set and working, as there is no user authentication.\n    The `skip_update` flag can be set to avoid fetching the index from the\n    remote server.\n\n    Args:\n        - remote_name (str): The hostname or IP address of the remote server.\n        - skip_update (bool): Flag to avoid fetching the index from the remote\n          server. Default is False.\n\n    Example:\n        >>> remote = Remote(\"euler\")\n        >>> remote.read_table()\n        returns a pandas DataFrame of the remote index.\n        >>> remote[\"<id>\"]\n        returns a RemoteManager object for the given id.\n    \"\"\"\n\n    def __new__(cls, *args, **kwargs):\n        \"\"\"Override the __new__ method to avoid the singleton pattern of IndexAPI.\"\"\"\n        return object.__new__(cls)\n\n    def __init__(\n        self, remote_name: str, skip_update: bool = False, *, home_path: str = None\n    ) -> None:\n        self.remote_name = remote_name\n        self.local_path = os.path.join(CACHE_DIR, self.remote_name)\n        os.makedirs(self.local_path, exist_ok=True)\n        self.file = f\"{self.local_path}/bamboost.db\"\n\n        if not skip_update:\n            process = self.fetch_index()\n            process.wait()\n\n        # Initialize the SQLiteHandler\n        SQLiteHandler.__init__(self, self.file)\n\n    @classmethod\n    def list(cls) -> list:\n        \"\"\"List all remote servers.\"\"\"\n        return [\n            name\n            for name in os.listdir(CACHE_DIR)\n            if os.path.isdir(os.path.join(CACHE_DIR, name))\n        ]\n\n    def _ipython_key_completions_(self) -> list[str]:\n        ids = self.get_df()[[\"id\", \"path\"]].values\n        completion_keys = [\n            f'{key} - {\"...\"+val[-25:] if len(val)>=25 else val}' for key, val in ids\n        ]\n        return completion_keys\n\n    def __getitem__(self, id: str) -> RemoteManager:\n        \"\"\"Return a `RemoteManager` for the given id.\"\"\"\n        id = id.split(\" - \")[0]\n        return RemoteManager(id, remote=self)\n\n    def fetch_index(self) -> subprocess.Popen:\n        \"\"\"Fetch the index from the remote server.\"\"\"\n        return subprocess.Popen(\n            [\"rsync\", \"-av\", f\"{self.remote_name}:{REMOTE_INDEX}\", self.file],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n        )\n\n    def get_manager(self, id: str, skip_update: bool = False) -> RemoteManager:\n        return RemoteManager(id, remote=self, skip_update=skip_update)\n\n    @with_connection\n    def get_path(self, id: str) -> str:\n        self.cursor.execute(\"SELECT path FROM dbindex WHERE id=?\", (id,))\n        fetch = self.cursor.fetchone()\n        if fetch is None:\n            raise KeyError(f\"No database found with id: {id}\")\n        else:\n            return fetch[0]\n\n    @with_connection\n    def insert_local_path(self, id: str, path: str) -> None:\n        try:\n            self.cursor.execute(\n                \"UPDATE dbindex SET local_path=? WHERE id=?\", (path, id)\n            )\n        except sqlite3.OperationalError:\n            self.cursor.execute(\n                \"ALTER TABLE dbindex ADD COLUMN local_path TEXT DEFAULT NULL\"\n            )\n            self.cursor.execute(\n                \"UPDATE dbindex SET local_path=? WHERE id=?\", (path, id)\n            )",
                  "inherited_members": {}
                },
                "RemoteDatabaseTable": {
                  "name": "RemoteDatabaseTable",
                  "path": "bamboost.core.extensions.remote_manager.RemoteDatabaseTable",
                  "description": null,
                  "parameters": [],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "sync": {
                      "name": "sync",
                      "path": "bamboost.core.extensions.remote_manager.RemoteDatabaseTable.sync",
                      "signature": "(self) -> None",
                      "description": "Don't sync a remote database.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def sync(self) -> None:\n    \"\"\"Don't sync a remote database.\"\"\"\n    return None"
                    }
                  },
                  "source": "class RemoteDatabaseTable(CollectionTable):\n    def sync(self) -> None:\n        \"\"\"Don't sync a remote database.\"\"\"\n        return None",
                  "inherited_members": {}
                },
                "RemoteManager": {
                  "name": "RemoteManager",
                  "path": "bamboost.core.extensions.remote_manager.RemoteManager",
                  "description": "Manager class with remote functionality. Constructor takes an existing ID\nof a database on a remote server. The ssh connection must be set up to work\nwithout explicit user authentication. Data is lazily transferred using\nrsync.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "id",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "remote",
                      "annotation": "Remote",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "comm",
                      "annotation": "MPI.Comm",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "UID",
                      "annotation": null,
                      "description": null,
                      "value": "id"
                    },
                    {
                      "name": "remote",
                      "annotation": null,
                      "description": null,
                      "value": "remote"
                    },
                    {
                      "name": "comm",
                      "annotation": null,
                      "description": null,
                      "value": "comm or MPI.COMM_WORLD"
                    },
                    {
                      "name": "path",
                      "annotation": null,
                      "description": null,
                      "value": "os.path.join(self.remote.local_path, self.UID)"
                    },
                    {
                      "name": "remote_path_db",
                      "annotation": null,
                      "description": null,
                      "value": "self._index.get_path(self.UID)"
                    },
                    {
                      "name": "_index",
                      "annotation": "CollectionsTable",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_table",
                      "annotation": "RemoteDatabaseTable",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.extensions.remote_manager.RemoteManager.__init__",
                      "signature": "(self, id, remote, comm=None) -> None",
                      "description": "params\nskip_update: if True, does not lookup the new database on the remote:",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "id",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "remote",
                          "annotation": "Remote",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "comm",
                          "annotation": "MPI.Comm",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self,\n    id: str,\n    remote: Remote,\n    comm: MPI.Comm = None,\n) -> None:\n    \"\"\"\n    params\n    skip_update: if True, does not lookup the new database on the remote:\n    \"\"\"\n    self.UID = id\n    self.remote = remote\n    self.comm = comm or MPI.COMM_WORLD\n    self.path = os.path.join(self.remote.local_path, self.UID)\n    log.info(f\"Creating cache directory at {self.path}\")\n    os.makedirs(self.path, exist_ok=True)\n\n    self.remote_path_db = self._index.get_path(self.UID)\n\n    # check if path exists\n    if not os.path.isdir(self.path):\n        os.makedirs(self.path)\n\n    # Write the database ID file if it does not exist\n    if not os.path.exists(f\"{self.path}/.BAMBOOST-{self.UID}\"):\n        with open(f\"{self.path}/.BAMBOOST-{self.UID}\", \"w\") as f:\n            f.write(self.UID)\n\n    self.UID = id\n    self._index.insert_local_path(self.UID, self.path)\n\n    # Update the SQL table for the database\n    with self._index.open():\n        self._table.create_database_table()"
                    },
                    "_repr_html_": {
                      "name": "_repr_html_",
                      "path": "bamboost.core.extensions.remote_manager.RemoteManager._repr_html_",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _repr_html_(self) -> str:\n    html_string = pkgutil.get_data(__name__, \"../html/manager.html\").decode()\n    icon = pkgutil.get_data(__name__, \"../html/icon.txt\").decode()\n    return (\n        html_string.replace(\"$ICON\", icon)\n        .replace(\"$db_path\", self.path)\n        .replace(\"$db_uid\", \"euler-\" + self.UID)\n        .replace(\"$db_size\", str(len(self)))\n    )"
                    },
                    "_get_uids": {
                      "name": "_get_uids",
                      "path": "bamboost.core.extensions.remote_manager.RemoteManager._get_uids",
                      "signature": "(self) -> list[str]",
                      "description": "Override the simulation list to fetch from databasetable.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "list[str]",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _get_uids(self) -> list[str]:\n    \"\"\"Override the simulation list to fetch from databasetable.\"\"\"\n    uids_in_tuple = self._index.fetch(f\"SELECT id FROM db_{self.UID}\")\n    return [uid for (uid,) in uids_in_tuple]"
                    },
                    "get_view": {
                      "name": "get_view",
                      "path": "bamboost.core.extensions.remote_manager.RemoteManager.get_view",
                      "signature": "(self, include_linked_sims=False) -> pd.DataFrame",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "include_linked_sims",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "pandas.pandas.DataFrame",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def get_view(self, include_linked_sims: bool = False) -> pd.DataFrame:\n    df = super().get_view(include_linked_sims)\n    df.insert(1, \"cached\", False)\n    for id in os.listdir(self.path):\n        if id in df[\"id\"].values:\n            df.loc[df[\"id\"] == id, \"cached\"] = True\n\n    if config.options.sort_table_key is not None:\n        df.sort_values(\n            config.options.sort_table_key,\n            ascending=config.options.sort_table_order == \"asc\",\n            inplace=True,\n        )\n    return df"
                    },
                    "sim": {
                      "name": "sim",
                      "path": "bamboost.core.extensions.remote_manager.RemoteManager.sim",
                      "signature": "(self, uid, return_writer=False)",
                      "description": "Return simulation object.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "uid",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "return_writer",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [
                        {
                          "kind": "text",
                          "value": "This method checks if the data for the given uid is already in the\nlocal cache. If not, it transfers the data from a remote location using\nrsync. The method then calls the superclass method to perform further\noperations on the transferred data."
                        }
                      ],
                      "source": "def sim(self, uid, return_writer: bool = False):\n    \"\"\"Return simulation object.\n\n    Args:\n        - uid (str): the unique id of the sim to be transferred.\n        - return_writer (bool): Flag to indicate whether to return a writer\n          object. Default is False.\n\n    This method checks if the data for the given uid is already in the\n    local cache. If not, it transfers the data from a remote location using\n    rsync. The method then calls the superclass method to perform further\n    operations on the transferred data.\n    \"\"\"\n    # Check if data is already in cache\n    if os.path.exists(f\"{self.path}/{uid}\"):\n        log.info(f\"Data for {uid} already in cache\")\n        return RemoteSimulation(uid, self)\n\n    # Transfer data using rsync\n    log.info(f\"Data not in cache. Transferring data for {uid} from {self.remote}\")\n    self.rsync(uid)\n\n    return RemoteSimulation(uid, self)"
                    },
                    "shallow_sim": {
                      "name": "shallow_sim",
                      "path": "bamboost.core.extensions.remote_manager.RemoteManager.shallow_sim",
                      "signature": "(self, uid) -> RemoteSimulation",
                      "description": "Return a RemoteSimulation object without transferring the data.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "uid",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The unique id of the simulation."
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.extensions.remote_manager.RemoteSimulation",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def shallow_sim(self, uid: str) -> RemoteSimulation:\n    \"\"\"Return a RemoteSimulation object without transferring the data.\n\n    Args:\n        uid: The unique id of the simulation.\n    \"\"\"\n    return RemoteSimulation(uid, self, _shallow=True)"
                    },
                    "_rsync": {
                      "name": "_rsync",
                      "path": "bamboost.core.extensions.remote_manager.RemoteManager._rsync",
                      "signature": "(self, uid=None) -> subprocess.Popen",
                      "description": "Transfer data using rsync. This method is called by the `rsync`.\nIt returns the subprocess.Popen object.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "uid",
                          "annotation": "str | None",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The unique id of the simulation to be transferred. If None,\nall simulations are synced."
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "subprocess.subprocess.Popen",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _rsync(self, uid: str | None = None) -> subprocess.Popen:\n    \"\"\"Transfer data using rsync. This method is called by the `rsync`.\n    It returns the subprocess.Popen object.\n\n    Args:\n        uid: The unique id of the simulation to be transferred. If None,\n            all simulations are synced.\n    \"\"\"\n    if uid is not None:\n        log.info(f\"Start syncing data for {uid} with {self.path}\")\n        return subprocess.Popen(\n            [\n                \"rsync\",\n                \"-ravh\",\n                f\"{self.remote.remote_name}:{self.remote_path_db}/{uid}\",\n                f\"{self.path}\",\n            ],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n        )\n\n    # else, sync entire database directory\n    log.info(f\"Start sync database with {self.path}\")\n    return subprocess.Popen(\n        [\n            \"rsync\",\n            \"-ravh\",\n            f\"{self.remote.remote_name}:{self.remote_path_db}/*\",\n            f\"{self.path}\",\n        ],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n    )"
                    },
                    "rsync": {
                      "name": "rsync",
                      "path": "bamboost.core.extensions.remote_manager.RemoteManager.rsync",
                      "signature": "(self, uid=None) -> RemoteManager",
                      "description": "Transfer data using rsync. Wait for the process to finish and return\nself.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "uid",
                          "annotation": "str | None",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The unique id of the simulation to be transferred. If None,\nall simulations are synced."
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.extensions.remote_manager.RemoteManager",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def rsync(self, uid: str | None = None) -> RemoteManager:\n    \"\"\"Transfer data using rsync. Wait for the process to finish and return\n    self.\n\n    Args:\n        uid: The unique id of the simulation to be transferred. If None,\n            all simulations are synced.\n    \"\"\"\n    process = self._rsync(uid)\n    for line in iter(process.stdout.readline, \"\"):\n        print(line, end=\"\")\n    process.wait()\n    return self"
                    }
                  },
                  "source": "class RemoteManager(Collection):\n    \"\"\"\n    Manager class with remote functionality. Constructor takes an existing ID\n    of a database on a remote server. The ssh connection must be set up to work\n    without explicit user authentication. Data is lazily transferred using\n    rsync.\n    \"\"\"\n\n    # INFO: The initialization of this class takes around 8 seconds because the\n    # home directory of the remote server needs to be fetched, read database\n    # index, and get remote database csv file with db.df in it (see below).\n    def __init__(\n        self,\n        id: str,\n        remote: Remote,\n        comm: MPI.Comm = None,\n    ) -> None:\n        \"\"\"\n        params\n        skip_update: if True, does not lookup the new database on the remote:\n        \"\"\"\n        self.UID = id\n        self.remote = remote\n        self.comm = comm or MPI.COMM_WORLD\n        self.path = os.path.join(self.remote.local_path, self.UID)\n        log.info(f\"Creating cache directory at {self.path}\")\n        os.makedirs(self.path, exist_ok=True)\n\n        self.remote_path_db = self._index.get_path(self.UID)\n\n        # check if path exists\n        if not os.path.isdir(self.path):\n            os.makedirs(self.path)\n\n        # Write the database ID file if it does not exist\n        if not os.path.exists(f\"{self.path}/.BAMBOOST-{self.UID}\"):\n            with open(f\"{self.path}/.BAMBOOST-{self.UID}\", \"w\") as f:\n                f.write(self.UID)\n\n        self.UID = id\n        self._index.insert_local_path(self.UID, self.path)\n\n        # Update the SQL table for the database\n        with self._index.open():\n            self._table.create_database_table()\n            # self._table.sync()\n\n    def _repr_html_(self) -> str:\n        html_string = pkgutil.get_data(__name__, \"../html/manager.html\").decode()\n        icon = pkgutil.get_data(__name__, \"../html/icon.txt\").decode()\n        return (\n            html_string.replace(\"$ICON\", icon)\n            .replace(\"$db_path\", self.path)\n            .replace(\"$db_uid\", \"euler-\" + self.UID)\n            .replace(\"$db_size\", str(len(self)))\n        )\n\n    def _get_uids(self) -> list[str]:\n        \"\"\"Override the simulation list to fetch from databasetable.\"\"\"\n        uids_in_tuple = self._index.fetch(f\"SELECT id FROM db_{self.UID}\")\n        return [uid for (uid,) in uids_in_tuple]\n\n    @property\n    def _index(self) -> CollectionsTable:\n        return self.remote\n\n    @property\n    def _table(self) -> RemoteDatabaseTable:\n        return RemoteDatabaseTable(self.UID, _index=self._index)\n\n    def get_view(self, include_linked_sims: bool = False) -> pd.DataFrame:\n        df = super().get_view(include_linked_sims)\n        df.insert(1, \"cached\", False)\n        for id in os.listdir(self.path):\n            if id in df[\"id\"].values:\n                df.loc[df[\"id\"] == id, \"cached\"] = True\n\n        if config.options.sort_table_key is not None:\n            df.sort_values(\n                config.options.sort_table_key,\n                ascending=config.options.sort_table_order == \"asc\",\n                inplace=True,\n            )\n        return df\n\n    def sim(self, uid, return_writer: bool = False):\n        \"\"\"Return simulation object.\n\n        Args:\n            - uid (str): the unique id of the sim to be transferred.\n            - return_writer (bool): Flag to indicate whether to return a writer\n              object. Default is False.\n\n        This method checks if the data for the given uid is already in the\n        local cache. If not, it transfers the data from a remote location using\n        rsync. The method then calls the superclass method to perform further\n        operations on the transferred data.\n        \"\"\"\n        # Check if data is already in cache\n        if os.path.exists(f\"{self.path}/{uid}\"):\n            log.info(f\"Data for {uid} already in cache\")\n            return RemoteSimulation(uid, self)\n\n        # Transfer data using rsync\n        log.info(f\"Data not in cache. Transferring data for {uid} from {self.remote}\")\n        self.rsync(uid)\n\n        return RemoteSimulation(uid, self)\n\n    def shallow_sim(self, uid: str) -> RemoteSimulation:\n        \"\"\"Return a RemoteSimulation object without transferring the data.\n\n        Args:\n            uid: The unique id of the simulation.\n        \"\"\"\n        return RemoteSimulation(uid, self, _shallow=True)\n\n    def _rsync(self, uid: str | None = None) -> subprocess.Popen:\n        \"\"\"Transfer data using rsync. This method is called by the `rsync`.\n        It returns the subprocess.Popen object.\n\n        Args:\n            uid: The unique id of the simulation to be transferred. If None,\n                all simulations are synced.\n        \"\"\"\n        if uid is not None:\n            log.info(f\"Start syncing data for {uid} with {self.path}\")\n            return subprocess.Popen(\n                [\n                    \"rsync\",\n                    \"-ravh\",\n                    f\"{self.remote.remote_name}:{self.remote_path_db}/{uid}\",\n                    f\"{self.path}\",\n                ],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                text=True,\n            )\n\n        # else, sync entire database directory\n        log.info(f\"Start sync database with {self.path}\")\n        return subprocess.Popen(\n            [\n                \"rsync\",\n                \"-ravh\",\n                f\"{self.remote.remote_name}:{self.remote_path_db}/*\",\n                f\"{self.path}\",\n            ],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n        )\n\n    def rsync(self, uid: str | None = None) -> RemoteManager:\n        \"\"\"Transfer data using rsync. Wait for the process to finish and return\n        self.\n\n        Args:\n            uid: The unique id of the simulation to be transferred. If None,\n                all simulations are synced.\n        \"\"\"\n        process = self._rsync(uid)\n        for line in iter(process.stdout.readline, \"\"):\n            print(line, end=\"\")\n        process.wait()\n        return self",
                  "inherited_members": {
                    "bamboost.core.manager.Collection": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.manager.Collection.FROZEN"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.manager.Collection.uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.manager.Collection.fromUID"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.manager.Collection._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.manager.Collection._orm"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.manager.Collection.__len__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.manager.Collection.__getitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.manager.Collection._ipython_key_completions_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.manager.Collection.df"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.manager.Collection.sync_cache"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.manager.Collection.create_simulation"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.manager.Collection.find"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.manager.Collection._list_duplicates"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.manager.Collection._check_duplicate"
                      }
                    ]
                  }
                },
                "RemoteSimulation": {
                  "name": "RemoteSimulation",
                  "path": "bamboost.core.extensions.remote_manager.RemoteSimulation",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "manager",
                      "annotation": "RemoteManager",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_shallow",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "cached",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    },
                    {
                      "name": "shallow",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    },
                    {
                      "name": "manager",
                      "annotation": null,
                      "description": null,
                      "value": "manager"
                    },
                    {
                      "name": "uid",
                      "annotation": null,
                      "description": null,
                      "value": "uid"
                    },
                    {
                      "name": "path_database",
                      "annotation": "str",
                      "description": null,
                      "value": "os.path.abspath(manager.path)"
                    },
                    {
                      "name": "database_id",
                      "annotation": null,
                      "description": null,
                      "value": "manager.UID"
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": null,
                      "value": "os.path.abspath(os.path.join(manager.path, uid))"
                    },
                    {
                      "name": "h5file",
                      "annotation": "str",
                      "description": null,
                      "value": "os.path.join(self.path, f'{self.uid}.h5')"
                    },
                    {
                      "name": "xdmffile",
                      "annotation": "str",
                      "description": null,
                      "value": "os.path.join(self.path, f'{self.uid}.xdmf')"
                    },
                    {
                      "name": "parameters",
                      "annotation": "dict",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Returns the parameters of the simulation.\n\n- If the simulation is shallow, the parameters are fetched from the\n  database. If so, the metadata is included in the parameters.\n- If the simulation is not shallow, the parameters are fetched from the\n  HDF5 file."
                        }
                      ],
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.extensions.remote_manager.RemoteSimulation.__init__",
                      "signature": "(self, uid, manager, *, _shallow=False) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "uid",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "manager",
                          "annotation": "RemoteManager",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "_shallow",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self, uid: str, manager: RemoteManager, *, _shallow: bool = False\n) -> None:\n    self.manager = manager\n    self.uid = uid\n\n    if not _shallow:\n        self._init_base_class()\n    else:\n        # A subset of the Simulation __init__ method\n        self.uid: str = uid\n        self.path_database: str = os.path.abspath(manager.path)\n        self.database_id = manager.UID\n        self.path: str = os.path.abspath(os.path.join(manager.path, uid))\n        self.h5file: str = os.path.join(self.path, f\"{self.uid}.h5\")\n        self.xdmffile: str = os.path.join(self.path, f\"{self.uid}.xdmf\")\n\n        # set flag to indicate that the data is not transferred\n        self.shallow = True"
                    },
                    "_init_base_class": {
                      "name": "_init_base_class",
                      "path": "bamboost.core.extensions.remote_manager.RemoteSimulation._init_base_class",
                      "signature": "(self) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _init_base_class(self) -> None:\n    super().__init__(self.uid, self.manager.path, _db_id=self.manager.UID)\n    self.cached = True"
                    },
                    "sync": {
                      "name": "sync",
                      "path": "bamboost.core.extensions.remote_manager.RemoteSimulation.sync",
                      "signature": "(self) -> RemoteSimulation",
                      "description": "Sync the simulation data with the remote server.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.extensions.remote_manager.RemoteSimulation",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def sync(self) -> RemoteSimulation:\n    \"\"\"Sync the simulation data with the remote server.\n\n    Args:\n        stdout: The file object to write the output of the rsync process.\n    \"\"\"\n    self.manager.rsync(self.uid)\n    self._init_base_class()\n    return self"
                    },
                    "get_full_uid": {
                      "name": "get_full_uid",
                      "path": "bamboost.core.extensions.remote_manager.RemoteSimulation.get_full_uid",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def get_full_uid(self) -> str:\n    return f\"ssh://{self.manager.remote.remote_name}/{self.manager.UID}:{self.uid}\""
                    }
                  },
                  "source": "class RemoteSimulation(Simulation):\n    cached: bool = False\n    shallow: bool = False\n\n    def __init__(\n        self, uid: str, manager: RemoteManager, *, _shallow: bool = False\n    ) -> None:\n        self.manager = manager\n        self.uid = uid\n\n        if not _shallow:\n            self._init_base_class()\n        else:\n            # A subset of the Simulation __init__ method\n            self.uid: str = uid\n            self.path_database: str = os.path.abspath(manager.path)\n            self.database_id = manager.UID\n            self.path: str = os.path.abspath(os.path.join(manager.path, uid))\n            self.h5file: str = os.path.join(self.path, f\"{self.uid}.h5\")\n            self.xdmffile: str = os.path.join(self.path, f\"{self.uid}.xdmf\")\n\n            # set flag to indicate that the data is not transferred\n            self.shallow = True\n\n    @cached_property\n    def parameters(self) -> dict:\n        \"\"\"Returns the parameters of the simulation.\n\n        - If the simulation is shallow, the parameters are fetched from the\n          database. If so, the metadata is included in the parameters.\n        - If the simulation is not shallow, the parameters are fetched from the\n          HDF5 file.\n        \"\"\"\n        if self.shallow:\n            return unflatten_dict(self.manager._table.read_entry(self.uid).to_dict())\n        return super().parameters\n\n    def _init_base_class(self) -> None:\n        super().__init__(self.uid, self.manager.path, _db_id=self.manager.UID)\n        self.cached = True\n\n    def sync(self) -> RemoteSimulation:\n        \"\"\"Sync the simulation data with the remote server.\n\n        Args:\n            stdout: The file object to write the output of the rsync process.\n        \"\"\"\n        self.manager.rsync(self.uid)\n        self._init_base_class()\n        return self\n\n    def get_full_uid(self) -> str:\n        return f\"ssh://{self.manager.remote.remote_name}/{self.manager.UID}:{self.uid}\"",
                  "inherited_members": {
                    "bamboost.core.simulation.base._Simulation": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._repr_html_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.name"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._psize"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._prank"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._ranks"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._index"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.collection_uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._data_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._xdmf_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._bash_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.root"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.from_uid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.edit"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.update_index"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.metadata"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.links"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.files"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.git"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.data"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.meshes"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.mesh"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.open_in_paraview"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.get_mesh"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.data_info"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.show_h5tree"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.enter_path"
                      }
                    ],
                    "bamboost.core.simulation.base.Simulation": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base.Simulation._file"
                      }
                    ]
                  }
                }
              },
              "functions": {
                "_extend_manager_from_uid_getitem": {
                  "name": "_extend_manager_from_uid_getitem",
                  "path": "bamboost.core.extensions.remote_manager._extend_manager_from_uid_getitem",
                  "signature": "(original_getitem)",
                  "description": "Extend the __getitem__ method of ManagerFromUID to handle remote keys.\nIn the following format: ssh://<remote_name>/<id>.",
                  "parameters": [
                    {
                      "name": "original_getitem",
                      "annotation": "Callable",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _extend_manager_from_uid_getitem(original_getitem: Callable):\n    \"\"\"Extend the __getitem__ method of ManagerFromUID to handle remote keys.\n    In the following format: ssh://<remote_name>/<id>.\n    \"\"\"\n\n    @wraps(original_getitem)\n    def modified_getitem(self: ManagerFromUID, key: str):\n        # If key starts with ssh://, it is a remote key\n        # Format: ssh://<remote_name>/<id>\n        if key.startswith(\"ssh://\"):\n            remote_name = key.split(\"/\")[2]\n            key = key.split(\"/\")[3]\n            try:\n                remote = Remote(remote_name, skip_update=True)\n                return remote[key]\n            except KeyError:\n                remote = Remote(remote_name, skip_update=False)\n                return remote[key]\n\n        return original_getitem(self, key)\n\n    return modified_getitem"
                },
                "_extend_simulation_from_uid": {
                  "name": "_extend_simulation_from_uid",
                  "path": "bamboost.core.extensions.remote_manager._extend_simulation_from_uid",
                  "signature": "(original_from_uid)",
                  "description": "Extend the fromUID method of Simulation to handle remote keys.\nIn the following format: ssh://<remote_name>/<id>:<uid>.",
                  "parameters": [
                    {
                      "name": "original_from_uid",
                      "annotation": "Callable",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _extend_simulation_from_uid(original_from_uid: Callable):\n    \"\"\"Extend the fromUID method of Simulation to handle remote keys.\n    In the following format: ssh://<remote_name>/<id>:<uid>.\n    \"\"\"\n\n    @wraps(original_from_uid)\n    def modified_from_uid(cls: Simulation, key: str):\n        # If key starts with ssh://, it is a remote key\n        # Format: ssh://<remote_name>/<db_id>:<sim_id>\n        if key.startswith(\"ssh://\"):\n            remote_name = key.split(\"/\")[2]\n            full_id = key.split(\"/\")[3]\n            db_id, sim_id = full_id.split(\":\")\n            remote = Remote(remote_name, skip_update=True)\n            return remote[db_id].sim(sim_id)\n\n        return original_from_uid(key)\n\n    return modified_from_uid"
                }
              }
            }
          },
          "classes": {
            "ExtensionsLazyLoader": {
              "name": "ExtensionsLazyLoader",
              "path": "bamboost.core.extensions.ExtensionsLazyLoader",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "FenicsWriter",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "Remote",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "RemoteManager",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "install_slurm",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class ExtensionsLazyLoader:\n    # This pattern is used to provide a single point/namespace to access all\n    # the extensions without importing them directly.\n    #\n    # TODO: this is the best way I could come up with, please suggest a better\n    # approach if you have one.\n\n    @property\n    def FenicsWriter(self):\n        from .fenics import FenicsWriter\n\n        return FenicsWriter\n\n    @property\n    def Remote(self):\n        from .remote_manager import Remote\n\n        return Remote\n\n    @property\n    def RemoteManager(self):\n        from .remote_manager import RemoteManager\n\n        return RemoteManager\n\n    @property\n    def install_slurm(self):\n        from .slurm import install\n\n        return install",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "simulation": {
          "name": "simulation",
          "path": "bamboost.core.simulation",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/simulation/__init__.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {
            "dict": {
              "name": "dict",
              "path": "bamboost.core.simulation.dict",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/simulation/dict.py",
              "description": null,
              "docstring": [],
              "attributes": [],
              "modules": {},
              "classes": {
                "Parameters": {
                  "name": "Parameters",
                  "path": "bamboost.core.simulation.dict.Parameters",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "_Simulation",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_simulation",
                      "annotation": "_Simulation",
                      "description": null,
                      "value": "simulation"
                    },
                    {
                      "name": "_dict",
                      "annotation": "SimulationParameterT",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_obj",
                      "annotation": "h5py.Group",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.dict.Parameters.__init__",
                      "signature": "(self, simulation)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "_Simulation",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: _Simulation[_MT]):\n    path = \"/.parameters\"\n    super().__init__(simulation._file, path)\n    self._simulation = simulation"
                    },
                    "read": {
                      "name": "read",
                      "path": "bamboost.core.simulation.dict.Parameters.read",
                      "signature": "(self) -> dict",
                      "description": "Read the parameters from the HDF5 file.\n\nIn addition to the attributes from the group, this method also reads in\nall datasets in the group.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.simulation.dict",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef read(self) -> dict:\n    \"\"\"Read the parameters from the HDF5 file.\n\n    In addition to the attributes from the group, this method also reads in\n    all datasets in the group.\n    \"\"\"\n    tmp_dict = dict()\n\n    try:\n        grp = cast(h5py.Group, self._file[self._path])\n    except KeyError:\n        raise KeyError(\n            f\"Group {self._path} not found in file {self._file._filename}.\"\n        )\n\n    # Read in attributes\n    tmp_dict.update(grp.attrs)\n\n    # Read in datasets\n    for key, value in grp.items():\n        if not isinstance(value, h5py.Dataset):\n            continue\n        tmp_dict.update({key: value[()]})\n\n    return utilities.unflatten_dict(tmp_dict)"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.simulation.dict.Parameters._ipython_key_completions_",
                      "signature": "(self) -> Generator[str, None, None]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "typing.Generator[str, None, None]",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self) -> Generator[str, None, None]:\n    for key, obj in self._dict.items():\n        yield key\n        if isinstance(obj, dict):\n            for subkey in obj.keys():\n                yield f\"{key}.{subkey}\""
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.dict.Parameters.__getitem__",
                      "signature": "(self, key) -> Any",
                      "description": "Get a parameter. Can use nested access with dot notation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "typing.Any",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> Any:\n    \"\"\"Get a parameter. Can use nested access with dot notation.\"\"\"\n    return reduce(lambda obj, k: obj[k], key.split(\".\"), self._dict)"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.simulation.dict.Parameters.__setitem__",
                      "signature": "(self, key, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Parameters",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "Any",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __setitem__(self: Parameters[Mutable], key: str, value: Any) -> None:\n    active_dict = reduce(lambda obj, k: obj[k], key.split(\".\")[:-1], self._dict)\n    active_dict[key.split(\".\")[-1]] = value\n\n    def _write(self, key, value):\n        # because values can be stored as datasets or attributes, we need\n        # to check if the key already exists and remove it before writing\n        # the new value -> to avoid duplicates\n        try:\n            del self._obj.attrs[key]  # remove existing attribute\n        except KeyError:\n            pass\n        try:\n            del self._obj[key]  # remove existing dataset\n        except KeyError:\n            pass\n\n        if isinstance(value, np.ndarray):  # write arrays as datasets\n            self._obj.create_dataset(key, data=value)\n        else:  # any other type as attribute\n            self._obj.attrs[key] = value\n\n    self._file.single_process_queue.add(_write, (self, key, value))\n\n    # also send the updated parameter to the SQL database\n    self._simulation.update_index(parameters={key: value})"
                    },
                    "update": {
                      "name": "update",
                      "path": "bamboost.core.simulation.dict.Parameters.update",
                      "signature": "(self, update_dict) -> None",
                      "description": "Update the parameters dictionary. This method pushes the update to\nthe HDF5 file, and the SQL database.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Parameters",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "update_dict",
                          "annotation": "dict",
                          "description": [
                            {
                              "kind": "text",
                              "value": "new parameters"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef update(self: Parameters[Mutable], update_dict: dict) -> None:\n    \"\"\"Update the parameters dictionary. This method pushes the update to\n    the HDF5 file, and the SQL database.\n\n    Args:\n        update_dict: new parameters\n    \"\"\"\n    # flatten dictionary\n    update_dict = utilities.flatten_dict(update_dict)\n\n    # update dictionary in memory\n    self._dict.update(update_dict)\n\n    # try update the sql database\n    self._simulation.update_index(parameters=update_dict)\n\n    # Filter out numpy arrays\n    arrays = {}\n    attributes = {}\n    for k, v in update_dict.items():\n        if isinstance(v, np.ndarray):\n            arrays[k] = update_dict.get(k)\n        else:\n            attributes[k] = update_dict.get(k)\n\n    with self._file.open(FileMode.APPEND):\n        # write arrays as datasets\n        for k, v in arrays.items():\n            if k in self._obj:\n                del self._obj[k]\n            self._obj.create_dataset(k, data=v)\n\n        # write the rest\n        self._obj.attrs.update(attributes)"
                    }
                  },
                  "source": "class Parameters(AttrsDict[_MT]):\n    _simulation: _Simulation\n    _dict: SimulationParameterT\n\n    def __init__(self, simulation: _Simulation[_MT]):\n        path = \"/.parameters\"\n        super().__init__(simulation._file, path)\n        self._simulation = simulation\n\n    @property\n    def _obj(self) -> h5py.Group:\n        obj = self._file[self._path]\n        assert isinstance(obj, h5py.Group), f\"Expected a group, got {type(obj)}\"\n        return obj\n\n    @with_file_open(FileMode.READ)\n    def read(self) -> dict:\n        \"\"\"Read the parameters from the HDF5 file.\n\n        In addition to the attributes from the group, this method also reads in\n        all datasets in the group.\n        \"\"\"\n        tmp_dict = dict()\n\n        try:\n            grp = cast(h5py.Group, self._file[self._path])\n        except KeyError:\n            raise KeyError(\n                f\"Group {self._path} not found in file {self._file._filename}.\"\n            )\n\n        # Read in attributes\n        tmp_dict.update(grp.attrs)\n\n        # Read in datasets\n        for key, value in grp.items():\n            if not isinstance(value, h5py.Dataset):\n                continue\n            tmp_dict.update({key: value[()]})\n\n        return utilities.unflatten_dict(tmp_dict)\n\n    def _ipython_key_completions_(self) -> Generator[str, None, None]:\n        for key, obj in self._dict.items():\n            yield key\n            if isinstance(obj, dict):\n                for subkey in obj.keys():\n                    yield f\"{key}.{subkey}\"\n\n    def __getitem__(self, key: str) -> Any:\n        \"\"\"Get a parameter. Can use nested access with dot notation.\"\"\"\n        return reduce(lambda obj, k: obj[k], key.split(\".\"), self._dict)\n\n    @mutable_only\n    def __setitem__(self: Parameters[Mutable], key: str, value: Any) -> None:\n        active_dict = reduce(lambda obj, k: obj[k], key.split(\".\")[:-1], self._dict)\n        active_dict[key.split(\".\")[-1]] = value\n\n        def _write(self, key, value):\n            # because values can be stored as datasets or attributes, we need\n            # to check if the key already exists and remove it before writing\n            # the new value -> to avoid duplicates\n            try:\n                del self._obj.attrs[key]  # remove existing attribute\n            except KeyError:\n                pass\n            try:\n                del self._obj[key]  # remove existing dataset\n            except KeyError:\n                pass\n\n            if isinstance(value, np.ndarray):  # write arrays as datasets\n                self._obj.create_dataset(key, data=value)\n            else:  # any other type as attribute\n                self._obj.attrs[key] = value\n\n        self._file.single_process_queue.add(_write, (self, key, value))\n\n        # also send the updated parameter to the SQL database\n        self._simulation.update_index(parameters={key: value})\n\n    @mutable_only\n    def update(self: Parameters[Mutable], update_dict: dict) -> None:\n        \"\"\"Update the parameters dictionary. This method pushes the update to\n        the HDF5 file, and the SQL database.\n\n        Args:\n            update_dict: new parameters\n        \"\"\"\n        # flatten dictionary\n        update_dict = utilities.flatten_dict(update_dict)\n\n        # update dictionary in memory\n        self._dict.update(update_dict)\n\n        # try update the sql database\n        self._simulation.update_index(parameters=update_dict)\n\n        # Filter out numpy arrays\n        arrays = {}\n        attributes = {}\n        for k, v in update_dict.items():\n            if isinstance(v, np.ndarray):\n                arrays[k] = update_dict.get(k)\n            else:\n                attributes[k] = update_dict.get(k)\n\n        with self._file.open(FileMode.APPEND):\n            # write arrays as datasets\n            for k, v in arrays.items():\n                if k in self._obj:\n                    del self._obj[k]\n                self._obj.create_dataset(k, data=v)\n\n            # write the rest\n            self._obj.attrs.update(attributes)",
                  "inherited_members": {
                    "bamboost.core.hdf5.attrs_dict.AttrsDict": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.mutable"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__new__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__len__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__str__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._repr_pretty_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__delitem__"
                      }
                    ]
                  }
                },
                "Links": {
                  "name": "Links",
                  "path": "bamboost.core.simulation.dict.Links",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "_Simulation",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.dict.Links.__init__",
                      "signature": "(self, simulation) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "_Simulation",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: _Simulation) -> None:\n    super().__init__(cast(HDF5File[_MT], simulation._file), \"/.links\")"
                    }
                  },
                  "source": "class Links(AttrsDict[_MT]):\n    def __init__(self, simulation: _Simulation) -> None:\n        super().__init__(cast(HDF5File[_MT], simulation._file), \"/.links\")",
                  "inherited_members": {
                    "bamboost.core.hdf5.attrs_dict.AttrsDict": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.mutable"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._path"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._dict"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__new__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.read"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__getitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__len__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__str__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._repr_pretty_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._obj"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.update"
                      }
                    ]
                  }
                },
                "Metadata": {
                  "name": "Metadata",
                  "path": "bamboost.core.simulation.dict.Metadata",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "_Simulation",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_simulation",
                      "annotation": "_Simulation",
                      "description": null,
                      "value": "simulation"
                    },
                    {
                      "name": "_dict",
                      "annotation": "SimulationMetadataT",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.dict.Metadata.__init__",
                      "signature": "(self, simulation) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "_Simulation",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: _Simulation[_MT]) -> None:\n    super().__init__(simulation._file, \"/\")\n    self._simulation = simulation\n\n    # transform strings to datetime if type should be datetime\n    for k, v in self._dict.items():\n        if (\n            isinstance(v, str)\n            and SimulationMetadataT.__annotations__[k] == datetime\n        ):\n            self._dict[k] = datetime.fromisoformat(v)"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.simulation.dict.Metadata.__setitem__",
                      "signature": "(self, key, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Metadata",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "Any",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __setitem__(self: Metadata[Mutable], key: str, value: Any) -> None:\n    self._dict[key] = value\n\n    def _write(self, key, value):\n        self._obj.attrs[key] = (\n            value.isoformat() if isinstance(value, datetime) else value\n        )\n\n    self._file.single_process_queue.add(_write, (self, key, value))\n\n    # also send the updated parameter to the SQL database\n    self._simulation.update_index(metadata={key: value})  # type: ignore"
                    },
                    "update": {
                      "name": "update",
                      "path": "bamboost.core.simulation.dict.Metadata.update",
                      "signature": "(self, update_dict) -> None",
                      "description": "Update the metadata dictionary. This method pushes the update to the\nHDF5 file, and the SQL database.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Metadata",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "update_dict",
                          "annotation": "SimulationMetadataT",
                          "description": [
                            {
                              "kind": "text",
                              "value": "new metadata"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef update(self: Metadata[Mutable], update_dict: SimulationMetadataT) -> None:\n    \"\"\"Update the metadata dictionary. This method pushes the update to the\n    HDF5 file, and the SQL database.\n\n    Args:\n        update_dict: new metadata\n    \"\"\"\n    from datetime import datetime\n\n    # update dictionary in memory and hdf5 file\n    dict_stringified = {\n        k: v.isoformat() if isinstance(v, datetime) else v\n        for k, v in update_dict.items()\n    }\n    AttrsDict.update(self, dict_stringified)  # type: ignore\n\n    # try update the sql database\n    self._simulation.update_index(metadata=update_dict)"
                    }
                  },
                  "source": "class Metadata(AttrsDict[_MT]):\n    _simulation: _Simulation\n    _dict: SimulationMetadataT\n\n    def __init__(self, simulation: _Simulation[_MT]) -> None:\n        super().__init__(simulation._file, \"/\")\n        self._simulation = simulation\n\n        # transform strings to datetime if type should be datetime\n        for k, v in self._dict.items():\n            if (\n                isinstance(v, str)\n                and SimulationMetadataT.__annotations__[k] == datetime\n            ):\n                self._dict[k] = datetime.fromisoformat(v)\n\n    @mutable_only\n    def __setitem__(self: Metadata[Mutable], key: str, value: Any) -> None:\n        self._dict[key] = value\n\n        def _write(self, key, value):\n            self._obj.attrs[key] = (\n                value.isoformat() if isinstance(value, datetime) else value\n            )\n\n        self._file.single_process_queue.add(_write, (self, key, value))\n\n        # also send the updated parameter to the SQL database\n        self._simulation.update_index(metadata={key: value})  # type: ignore\n\n    @mutable_only\n    def update(self: Metadata[Mutable], update_dict: SimulationMetadataT) -> None:\n        \"\"\"Update the metadata dictionary. This method pushes the update to the\n        HDF5 file, and the SQL database.\n\n        Args:\n            update_dict: new metadata\n        \"\"\"\n        from datetime import datetime\n\n        # update dictionary in memory and hdf5 file\n        dict_stringified = {\n            k: v.isoformat() if isinstance(v, datetime) else v\n            for k, v in update_dict.items()\n        }\n        AttrsDict.update(self, dict_stringified)  # type: ignore\n\n        # try update the sql database\n        self._simulation.update_index(metadata=update_dict)",
                  "inherited_members": {
                    "bamboost.core.hdf5.attrs_dict.AttrsDict": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.mutable"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__new__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.read"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__getitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__len__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__str__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._repr_pretty_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._obj"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__delitem__"
                      }
                    ]
                  }
                }
              },
              "functions": {}
            },
            "_repr": {
              "name": "_repr",
              "path": "bamboost.core.simulation._repr",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/simulation/_repr.py",
              "description": null,
              "docstring": [],
              "attributes": [],
              "modules": {},
              "classes": {},
              "functions": {
                "simulation_html_repr": {
                  "name": "simulation_html_repr",
                  "path": "bamboost.core.simulation._repr.simulation_html_repr",
                  "signature": "(simulation) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "simulation",
                      "annotation": "Simulation",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def simulation_html_repr(simulation: \"Simulation\") -> str:\n    metadata = simulation.metadata\n    parameters_filtered = {\n        k: \"...\"\n        if isinstance(v, Sized) and not isinstance(v, str) and len(v) > 5\n        else v\n        for k, v in simulation.parameters.items()\n    }\n\n    def get_pill_div(text: str, color: str) -> str:\n        return (\n            f'<div class=\"status\" style=\"background-color:'\n            f'var(--bb-{color});\">{text}</div>'\n        )\n\n    status_options = {\n        \"finished\": get_pill_div(\"finished\", \"green\"),\n        \"failed\": get_pill_div(\"failed\", \"red\"),\n        \"initialized\": get_pill_div(\"initialized\", \"grey\"),\n    }\n    submitted_options = {\n        True: get_pill_div(\"Submitted\", \"green\"),\n        False: get_pill_div(\"Not submitted\", \"grey\"),\n    }\n\n    from jinja2 import Template\n\n    html_string = pkgutil.get_data(\"bamboost\", \"_repr/simulation.html\").decode()\n    icon = pkgutil.get_data(\"bamboost\", \"_repr/icon.txt\").decode()\n    template = Template(html_string)\n\n    return template.render(\n        uid=simulation.name,\n        icon=icon,\n        tree=repr(simulation.files).replace(\"\\n\", \"</br>\").replace(\" \", \"&nbsp;\"),\n        parameters=parameters_filtered,\n        note=metadata.get(\"description\"),\n        status=status_options.get(\n            metadata.get(\"status\", \"Initiated\"),\n            f'<div class=\"status\">{metadata[\"status\"]}</div>',\n        ),\n        submitted=submitted_options[metadata.get(\"submitted\", False)],\n        timestamp=metadata.get(\"created_at\", \"N/A\"),\n    )"
                }
              }
            },
            "groups": {
              "name": "groups",
              "path": "bamboost.core.simulation.groups",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/simulation/groups.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "log",
                  "annotation": null,
                  "description": null,
                  "value": "BAMBOOST_LOGGER.getChild(__name__)"
                }
              ],
              "modules": {},
              "classes": {
                "GroupData": {
                  "name": "GroupData",
                  "path": "bamboost.core.simulation.groups.GroupData",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "'_Simulation'",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_simulation",
                      "annotation": null,
                      "description": null,
                      "value": "simulation"
                    },
                    {
                      "name": "last_step",
                      "annotation": "int",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "fields",
                      "annotation": "GroupFieldData",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "scalars",
                      "annotation": "GroupScalarData",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "timesteps",
                      "annotation": "np.ndarray",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GroupData.__init__",
                      "signature": "(self, simulation)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "'_Simulation'",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: \"_Simulation\"):\n    super().__init__(PATH_DATA, simulation._file)\n    self._simulation = simulation"
                    },
                    "create_step": {
                      "name": "create_step",
                      "path": "bamboost.core.simulation.groups.GroupData.create_step",
                      "signature": "(self, time=np.nan, step=None) -> StepWriter",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "GroupData",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "time",
                          "annotation": "float",
                          "description": null,
                          "value": "np.nan"
                        },
                        {
                          "name": "step",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.simulation.groups.StepWriter",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef create_step(\n    self: GroupData[Mutable],\n    time: float = np.nan,\n    step: Optional[int] = None,\n) -> StepWriter:\n    self._file._comm.barrier()\n    if step is None:\n        step = self.last_step + 1\n    self.attrs[\"last_step\"] = step\n\n    # store the timestep if given\n    self._store_time(step, time)\n\n    return StepWriter(self, step)"
                    },
                    "_store_time": {
                      "name": "_store_time",
                      "path": "bamboost.core.simulation.groups.GroupData._store_time",
                      "signature": "(self, step, time) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "GroupData",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "time",
                          "annotation": "float",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\n@add_to_file_queue\ndef _store_time(self: GroupData[Mutable], step: int, time: float) -> None:\n    self.require_self()\n\n    # require the dataset for the timesteps\n    dataset = self.require_dataset(\n        constants.DS_NAME_TIMESTEPS,\n        shape=(step + 1,),\n        dtype=np.float64,\n        chunks=True,\n        maxshape=(None,),\n        fillvalue=np.nan,\n    )\n\n    # resize the dataset and store the time\n    new_size = max(step + 1, dataset.shape[0])\n    log.debug(f\"Resizing dataset {dataset.name} to {new_size}\")\n    dataset.resize(new_size, axis=0)\n\n    log.debug(f\"Storing timestep {time} for step {step}\")\n    dataset[step] = time"
                    },
                    "create_xdmf": {
                      "name": "create_xdmf",
                      "path": "bamboost.core.simulation.groups.GroupData.create_xdmf",
                      "signature": "(self, field_names=None, timesteps=None, *, filename=None, mesh_name=DEFAULT_MESH_NAME)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "field_names",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "timesteps",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "filename",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": null,
                          "value": "DEFAULT_MESH_NAME"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def create_xdmf(\n    self,\n    field_names: Optional[Union[tuple[str], list[str], set[str]]] = None,\n    timesteps: Optional[Iterable[float]] = None,\n    *,\n    filename: Optional[StrPath] = None,\n    mesh_name: str = DEFAULT_MESH_NAME,\n):\n    from bamboost.core.simulation.xdmf import XDMFWriter\n\n    fields = self.fields[field_names] if field_names else self.fields[()]\n    filename = filename or self._simulation.path.joinpath(constants.XDMF_FILE_NAME)\n\n    def _create_xdmf(group: GroupData, timesteps: Optional[Iterable[float]]):\n        timesteps = timesteps or self.timesteps\n        xdmf = XDMFWriter(group._file)\n        xdmf.add_mesh(group._simulation.meshes[mesh_name])\n        xdmf.add_timeseries(timesteps, fields, mesh_name)\n        xdmf.write_file(filename)\n        log.debug(f\"produced XDMF file at {filename}\")\n\n    self._file.single_process_queue.add(_create_xdmf, (self, timesteps))"
                    }
                  },
                  "source": "class GroupData(Group[_MT]):\n    def __init__(self, simulation: \"_Simulation\"):\n        super().__init__(PATH_DATA, simulation._file)\n        self._simulation = simulation\n\n    @property\n    def last_step(self) -> int:\n        return self.attrs.get(\"last_step\", -1)\n\n    @cached_property\n    def fields(self) -> GroupFieldData[_MT]:\n        return GroupFieldData(self)\n\n    @cached_property\n    def scalars(self) -> GroupScalarData[_MT]:\n        return GroupScalarData(self)\n\n    @property\n    def timesteps(self) -> np.ndarray:\n        return self[constants.DS_NAME_TIMESTEPS][:]\n\n    @mutable_only\n    def create_step(\n        self: GroupData[Mutable],\n        time: float = np.nan,\n        step: Optional[int] = None,\n    ) -> StepWriter:\n        self._file._comm.barrier()\n        if step is None:\n            step = self.last_step + 1\n        self.attrs[\"last_step\"] = step\n\n        # store the timestep if given\n        self._store_time(step, time)\n\n        return StepWriter(self, step)\n\n    @mutable_only\n    @add_to_file_queue\n    def _store_time(self: GroupData[Mutable], step: int, time: float) -> None:\n        self.require_self()\n\n        # require the dataset for the timesteps\n        dataset = self.require_dataset(\n            constants.DS_NAME_TIMESTEPS,\n            shape=(step + 1,),\n            dtype=np.float64,\n            chunks=True,\n            maxshape=(None,),\n            fillvalue=np.nan,\n        )\n\n        # resize the dataset and store the time\n        new_size = max(step + 1, dataset.shape[0])\n        log.debug(f\"Resizing dataset {dataset.name} to {new_size}\")\n        dataset.resize(new_size, axis=0)\n\n        log.debug(f\"Storing timestep {time} for step {step}\")\n        dataset[step] = time\n\n    def create_xdmf(\n        self,\n        field_names: Optional[Union[tuple[str], list[str], set[str]]] = None,\n        timesteps: Optional[Iterable[float]] = None,\n        *,\n        filename: Optional[StrPath] = None,\n        mesh_name: str = DEFAULT_MESH_NAME,\n    ):\n        from bamboost.core.simulation.xdmf import XDMFWriter\n\n        fields = self.fields[field_names] if field_names else self.fields[()]\n        filename = filename or self._simulation.path.joinpath(constants.XDMF_FILE_NAME)\n\n        def _create_xdmf(group: GroupData, timesteps: Optional[Iterable[float]]):\n            timesteps = timesteps or self.timesteps\n            xdmf = XDMFWriter(group._file)\n            xdmf.add_mesh(group._simulation.meshes[mesh_name])\n            xdmf.add_timeseries(timesteps, fields, mesh_name)\n            xdmf.write_file(filename)\n            log.debug(f\"produced XDMF file at {filename}\")\n\n        self._file.single_process_queue.add(_create_xdmf, (self, timesteps))",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__getitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "StepWriter": {
                  "name": "StepWriter",
                  "path": "bamboost.core.simulation.groups.StepWriter",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data_group",
                      "annotation": "GroupData",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "step",
                      "annotation": "int",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_data_group",
                      "annotation": null,
                      "description": null,
                      "value": "data_group"
                    },
                    {
                      "name": "_step",
                      "annotation": null,
                      "description": null,
                      "value": "step"
                    },
                    {
                      "name": "fields",
                      "annotation": null,
                      "description": null,
                      "value": "data_group.fields"
                    },
                    {
                      "name": "scalars",
                      "annotation": null,
                      "description": null,
                      "value": "data_group.scalars"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.StepWriter.__init__",
                      "signature": "(self, data_group, step)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "data_group",
                          "annotation": "GroupData",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, data_group: GroupData[Mutable], step: int):\n    self._data_group = data_group\n    self._step = step\n\n    self.fields = data_group.fields\n    self.scalars = data_group.scalars"
                    },
                    "add_field": {
                      "name": "add_field",
                      "path": "bamboost.core.simulation.groups.StepWriter.add_field",
                      "signature": "(self, name, data, *, mesh_name=DEFAULT_MESH_NAME, field_type=FieldType.NODE) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "data",
                          "annotation": "np.ndarray",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": null,
                          "value": "DEFAULT_MESH_NAME"
                        },
                        {
                          "name": "field_type",
                          "annotation": "FieldType",
                          "description": null,
                          "value": "FieldType.NODE"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_field(\n    self,\n    name: str,\n    data: np.ndarray,\n    *,\n    mesh_name: str = DEFAULT_MESH_NAME,\n    field_type: FieldType = FieldType.NODE,\n) -> None:\n    field = self.fields[name]\n    field.require_self()\n    field.add_numerical_dataset(\n        str(self._step),\n        data,\n        file_map=False,\n        attrs={\"mesh\": mesh_name, \"type\": field_type.value},\n    )\n    log.debug(f\"Added field {name} for step {self._step}\")"
                    },
                    "add_fields": {
                      "name": "add_fields",
                      "path": "bamboost.core.simulation.groups.StepWriter.add_fields",
                      "signature": "(self, fields, mesh_name=DEFAULT_MESH_NAME, field_type=FieldType.NODE) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "fields",
                          "annotation": "dict",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": null,
                          "value": "DEFAULT_MESH_NAME"
                        },
                        {
                          "name": "field_type",
                          "annotation": "FieldType",
                          "description": null,
                          "value": "FieldType.NODE"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_fields(\n    self,\n    fields: dict[str, np.ndarray],\n    mesh_name: str = DEFAULT_MESH_NAME,\n    field_type: FieldType = FieldType.NODE,\n) -> None:\n    for name, data in fields.items():\n        self.add_field(name, data, mesh_name=mesh_name, field_type=field_type)"
                    },
                    "add_scalar": {
                      "name": "add_scalar",
                      "path": "bamboost.core.simulation.groups.StepWriter.add_scalar",
                      "signature": "(self, name, data) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "data",
                          "annotation": "Union",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_scalar(self, name: str, data: Union[int, float, Iterable]) -> None:\n    data_arr = np.array(data)\n\n    # with self._data_group._file.open(FileMode.APPEND):\n    def _write_scalar(group: GroupData, name: str, data_arr, step: int):\n        dataset = group.scalars.require_dataset(\n            name,\n            shape=(1, *data_arr.shape),\n            dtype=data_arr.dtype,\n            maxshape=(None, *data_arr.shape),\n            chunks=True,\n            fillvalue=np.full_like(data_arr, np.nan),\n        )\n        dataset.resize(step + 1, axis=0)\n        dataset[step] = data_arr\n\n    self._data_group._file.single_process_queue.add(\n        _write_scalar, (self._data_group, name, data_arr, self._step)\n    )\n    log.debug(f\"Added scalar {name} for step {self._step}\")"
                    },
                    "add_scalars": {
                      "name": "add_scalars",
                      "path": "bamboost.core.simulation.groups.StepWriter.add_scalars",
                      "signature": "(self, scalars) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "scalars",
                          "annotation": "dict",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_scalars(self, scalars: dict[str, Union[int, float, Iterable]]) -> None:\n    for name, data in scalars.items():\n        self.add_scalar(name, data)"
                    }
                  },
                  "source": "class StepWriter:\n    def __init__(self, data_group: GroupData[Mutable], step: int):\n        self._data_group = data_group\n        self._step = step\n\n        self.fields = data_group.fields\n        self.scalars = data_group.scalars\n\n    def add_field(\n        self,\n        name: str,\n        data: np.ndarray,\n        *,\n        mesh_name: str = DEFAULT_MESH_NAME,\n        field_type: FieldType = FieldType.NODE,\n    ) -> None:\n        field = self.fields[name]\n        field.require_self()\n        field.add_numerical_dataset(\n            str(self._step),\n            data,\n            file_map=False,\n            attrs={\"mesh\": mesh_name, \"type\": field_type.value},\n        )\n        log.debug(f\"Added field {name} for step {self._step}\")\n\n    def add_fields(\n        self,\n        fields: dict[str, np.ndarray],\n        mesh_name: str = DEFAULT_MESH_NAME,\n        field_type: FieldType = FieldType.NODE,\n    ) -> None:\n        for name, data in fields.items():\n            self.add_field(name, data, mesh_name=mesh_name, field_type=field_type)\n\n    def add_scalar(self, name: str, data: Union[int, float, Iterable]) -> None:\n        data_arr = np.array(data)\n\n        # with self._data_group._file.open(FileMode.APPEND):\n        def _write_scalar(group: GroupData, name: str, data_arr, step: int):\n            dataset = group.scalars.require_dataset(\n                name,\n                shape=(1, *data_arr.shape),\n                dtype=data_arr.dtype,\n                maxshape=(None, *data_arr.shape),\n                chunks=True,\n                fillvalue=np.full_like(data_arr, np.nan),\n            )\n            dataset.resize(step + 1, axis=0)\n            dataset[step] = data_arr\n\n        self._data_group._file.single_process_queue.add(\n            _write_scalar, (self._data_group, name, data_arr, self._step)\n        )\n        log.debug(f\"Added scalar {name} for step {self._step}\")\n\n    def add_scalars(self, scalars: dict[str, Union[int, float, Iterable]]) -> None:\n        for name, data in scalars.items():\n            self.add_scalar(name, data)",
                  "inherited_members": {}
                },
                "GroupFieldData": {
                  "name": "GroupFieldData",
                  "path": "bamboost.core.simulation.groups.GroupFieldData",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data_group",
                      "annotation": "GroupData",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_data_group",
                      "annotation": null,
                      "description": null,
                      "value": "data_group"
                    },
                    {
                      "name": "_field_instances",
                      "annotation": "dict",
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GroupFieldData.__init__",
                      "signature": "(self, data_group)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "data_group",
                          "annotation": "GroupData",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, data_group: GroupData[_MT]):\n    super().__init__(PATH_FIELD_DATA, data_group._file)\n\n    self._data_group = data_group\n    self._field_instances: dict[str, FieldData[_MT]] = {}"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.groups.GroupFieldData.__getitem__",
                      "signature": "(self, key)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key):\n    if isinstance(key, str):\n        return FieldData(self, key)\n    if isinstance(key, tuple) and len(key) == 0:\n        return [FieldData(self, k) for k in self.keys()]\n    # else the key is a iterable of strings\n    return [FieldData(self, k) for k in key]"
                    }
                  },
                  "source": "class GroupFieldData(Group[_MT]):\n    def __init__(self, data_group: GroupData[_MT]):\n        super().__init__(PATH_FIELD_DATA, data_group._file)\n\n        self._data_group = data_group\n        self._field_instances: dict[str, FieldData[_MT]] = {}\n\n    @overload\n    def __getitem__(self, key: tuple[()]) -> list[FieldData[_MT]]: ...\n    @overload\n    def __getitem__(\n        self, key: Union[list[str], tuple[str], set[str]]\n    ) -> list[FieldData[_MT]]: ...\n    @overload\n    def __getitem__(self, key: str) -> FieldData[_MT]: ...\n    def __getitem__(self, key):\n        if isinstance(key, str):\n            return FieldData(self, key)\n        if isinstance(key, tuple) and len(key) == 0:\n            return [FieldData(self, k) for k in self.keys()]\n        # else the key is a iterable of strings\n        return [FieldData(self, k) for k in key]",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "FieldData": {
                  "name": "FieldData",
                  "path": "bamboost.core.simulation.groups.FieldData",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "field",
                      "annotation": "GroupFieldData",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_field",
                      "annotation": "GroupFieldData",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__new__": {
                      "name": "__new__",
                      "path": "bamboost.core.simulation.groups.FieldData.__new__",
                      "signature": "(cls, field, name)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "field",
                          "annotation": "GroupFieldData",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __new__(cls, field: GroupFieldData[_MT], name: str):\n    if name not in field._field_instances:\n        instance = super().__new__(cls)\n\n        # Initialize the instance\n        super(FieldData, instance).__init__(\n            HDF5Path(PATH_FIELD_DATA).joinpath(name), field._file\n        )\n        instance._field = field\n        instance.name = name\n\n        # Store the instance and return\n        field._field_instances[name] = instance\n\n    return field._field_instances[name]"
                    },
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.FieldData.__init__",
                      "signature": "(self, field, name)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "field",
                          "annotation": "GroupFieldData",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, field: GroupFieldData[_MT], name: str):\n    # initialization is done in __new__ for simplicity\n    pass"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.groups.FieldData.__getitem__",
                      "signature": "(self, key) -> np.ndarray",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "Union",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "numpy.numpy.ndarray",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(\n    self, key: Union[int, slice, tuple[slice | int, ...]]\n) -> np.ndarray:\n    if isinstance(key, Iterable):\n        step = key[0]\n        rest = key[1:]\n    else:\n        step = key\n        rest = ()\n\n    with self._file.open(FileMode.READ):\n        if isinstance(step, int):\n            step_positive = self._handle_negative_index(step)\n            try:\n                return self._obj[str(step_positive)][rest]  # type: ignore\n            except KeyError:\n                raise IndexError(\n                    f\"Index ({step_positive}) out of range for (0-{self._field._data_group.last_step})\"\n                )\n        else:\n            return np.array([self._obj[i][rest] for i in self._slice_step(step)])  # type: ignore"
                    },
                    "_handle_negative_index": {
                      "name": "_handle_negative_index",
                      "path": "bamboost.core.simulation.groups.FieldData._handle_negative_index",
                      "signature": "(self, index) -> int",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "index",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "int",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _handle_negative_index(self, index: int) -> int:\n    if index < 0:\n        return (self._field._data_group.last_step or 0) + index + 1\n    return index"
                    },
                    "_slice_step": {
                      "name": "_slice_step",
                      "path": "bamboost.core.simulation.groups.FieldData._slice_step",
                      "signature": "(self, step) -> list[str]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "slice",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "list[str]",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _slice_step(self, step: slice) -> list[str]:\n    indices = [\n        str(i)\n        for i in range(*step.indices((self._field._data_group.last_step or 0) + 1))\n    ]\n    return indices"
                    }
                  },
                  "source": "class FieldData(Group[_MT]):\n    _field: GroupFieldData[_MT]\n    name: str\n\n    def __new__(cls, field: GroupFieldData[_MT], name: str):\n        if name not in field._field_instances:\n            instance = super().__new__(cls)\n\n            # Initialize the instance\n            super(FieldData, instance).__init__(\n                HDF5Path(PATH_FIELD_DATA).joinpath(name), field._file\n            )\n            instance._field = field\n            instance.name = name\n\n            # Store the instance and return\n            field._field_instances[name] = instance\n\n        return field._field_instances[name]\n\n    def __init__(self, field: GroupFieldData[_MT], name: str):\n        # initialization is done in __new__ for simplicity\n        pass\n\n    def __getitem__(\n        self, key: Union[int, slice, tuple[slice | int, ...]]\n    ) -> np.ndarray:\n        if isinstance(key, Iterable):\n            step = key[0]\n            rest = key[1:]\n        else:\n            step = key\n            rest = ()\n\n        with self._file.open(FileMode.READ):\n            if isinstance(step, int):\n                step_positive = self._handle_negative_index(step)\n                try:\n                    return self._obj[str(step_positive)][rest]  # type: ignore\n                except KeyError:\n                    raise IndexError(\n                        f\"Index ({step_positive}) out of range for (0-{self._field._data_group.last_step})\"\n                    )\n            else:\n                return np.array([self._obj[i][rest] for i in self._slice_step(step)])  # type: ignore\n\n    def _handle_negative_index(self, index: int) -> int:\n        if index < 0:\n            return (self._field._data_group.last_step or 0) + index + 1\n        return index\n\n    def _slice_step(self, step: slice) -> list[str]:\n        indices = [\n            str(i)\n            for i in range(*step.indices((self._field._data_group.last_step or 0) + 1))\n        ]\n        return indices",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "GroupScalarData": {
                  "name": "GroupScalarData",
                  "path": "bamboost.core.simulation.groups.GroupScalarData",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data_group",
                      "annotation": "GroupData",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "df",
                      "annotation": "pd.DataFrame",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GroupScalarData.__init__",
                      "signature": "(self, data_group)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "data_group",
                          "annotation": "GroupData",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, data_group: GroupData[_MT]):\n    super().__init__(PATH_SCALAR_DATA, data_group._file)"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.groups.GroupScalarData.__getitem__",
                      "signature": "(self, key) -> Dataset[_MT]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.hdf5.ref.Dataset[bamboost._typing._MT]",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> Dataset[_MT]:\n    return super().__getitem__((key, Dataset[_MT]))"
                    }
                  },
                  "source": "class GroupScalarData(Group[_MT]):\n    def __init__(self, data_group: GroupData[_MT]):\n        super().__init__(PATH_SCALAR_DATA, data_group._file)\n\n    def __getitem__(self, key: str) -> Dataset[_MT]:\n        return super().__getitem__((key, Dataset[_MT]))\n\n    @property\n    def df(self) -> pd.DataFrame:\n        from pandas import DataFrame\n\n        return DataFrame({k: list(v[:]) for k, v in self.items()})",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "GroupMeshes": {
                  "name": "GroupMeshes",
                  "path": "bamboost.core.simulation.groups.GroupMeshes",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "'_Simulation'",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_simulation",
                      "annotation": null,
                      "description": null,
                      "value": "simulation"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GroupMeshes.__init__",
                      "signature": "(self, simulation)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "'_Simulation'",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: \"_Simulation\"):\n    super().__init__(PATH_MESH, simulation._file)\n    self._simulation = simulation"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.groups.GroupMeshes.__getitem__",
                      "signature": "(self, key) -> GroupMesh[_MT]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.simulation.groups.GroupMesh[bamboost._typing._MT]",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> GroupMesh[_MT]:\n    return GroupMesh(self._simulation, key)"
                    },
                    "add": {
                      "name": "add",
                      "path": "bamboost.core.simulation.groups.GroupMeshes.add",
                      "signature": "(self, nodes, cells, name=DEFAULT_MESH_NAME, cell_type=CellType.TRIANGLE) -> None",
                      "description": "Add a mesh with the given name to the simulation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "GroupMeshes",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "nodes",
                          "annotation": "np.ndarray",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Node coordinates"
                            }
                          ]
                        },
                        {
                          "name": "cells",
                          "annotation": "np.ndarray",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Cell connectivity"
                            }
                          ]
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Name of the mesh"
                            }
                          ],
                          "value": "DEFAULT_MESH_NAME"
                        },
                        {
                          "name": "cell_type",
                          "annotation": "CellType",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Cell type (default: \"triangle\"). In general, we do not care about\nthe cell type and leave it up to the user to make sense of the data they\nprovide. However, the cell type specified is needed for writing an XDMF\nfile. For possible types, consult the XDMF/paraview manual."
                            }
                          ],
                          "value": "CellType.TRIANGLE"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add(\n    self: GroupMeshes[Mutable],\n    nodes: np.ndarray,\n    cells: np.ndarray,\n    name: str = DEFAULT_MESH_NAME,\n    cell_type: CellType = CellType.TRIANGLE,\n) -> None:\n    \"\"\"Add a mesh with the given name to the simulation.\n\n    Args:\n        nodes: Node coordinates\n        cells: Cell connectivity\n        name: Name of the mesh\n        cell_type: Cell type (default: \"triangle\"). In general, we do not care about\n            the cell type and leave it up to the user to make sense of the data they\n            provide. However, the cell type specified is needed for writing an XDMF\n            file. For possible types, consult the XDMF/paraview manual.\n    \"\"\"\n    with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n        new_grp = self.require_group(name)\n        new_grp.add_numerical_dataset(\"coordinates\", vector=nodes)\n        new_grp.add_numerical_dataset(\n            \"topology\", vector=cells, attrs={\"cell_type\": cell_type.value}\n        )"
                    }
                  },
                  "source": "class GroupMeshes(Group[_MT]):\n    def __init__(self, simulation: \"_Simulation\"):\n        super().__init__(PATH_MESH, simulation._file)\n        self._simulation = simulation\n\n    def __getitem__(self, key: str) -> GroupMesh[_MT]:\n        return GroupMesh(self._simulation, key)\n\n    def add(\n        self: GroupMeshes[Mutable],\n        nodes: np.ndarray,\n        cells: np.ndarray,\n        name: str = DEFAULT_MESH_NAME,\n        cell_type: CellType = CellType.TRIANGLE,\n    ) -> None:\n        \"\"\"Add a mesh with the given name to the simulation.\n\n        Args:\n            nodes: Node coordinates\n            cells: Cell connectivity\n            name: Name of the mesh\n            cell_type: Cell type (default: \"triangle\"). In general, we do not care about\n                the cell type and leave it up to the user to make sense of the data they\n                provide. However, the cell type specified is needed for writing an XDMF\n                file. For possible types, consult the XDMF/paraview manual.\n        \"\"\"\n        with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n            new_grp = self.require_group(name)\n            new_grp.add_numerical_dataset(\"coordinates\", vector=nodes)\n            new_grp.add_numerical_dataset(\n                \"topology\", vector=cells, attrs={\"cell_type\": cell_type.value}\n            )",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "GroupMesh": {
                  "name": "GroupMesh",
                  "path": "bamboost.core.simulation.groups.GroupMesh",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "'_Simulation'",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "NODES",
                      "annotation": null,
                      "description": null,
                      "value": "'coordinates'"
                    },
                    {
                      "name": "CELLS",
                      "annotation": null,
                      "description": null,
                      "value": "'topology'"
                    },
                    {
                      "name": "coordinates",
                      "annotation": "np.ndarray",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "cells",
                      "annotation": "np.ndarray",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "cell_type",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GroupMesh.__init__",
                      "signature": "(self, simulation, name)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "'_Simulation'",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: \"_Simulation\", name: str):\n    super().__init__(f\"{PATH_MESH}/{name}\", simulation._file)"
                    }
                  },
                  "source": "class GroupMesh(Group[_MT]):\n    NODES = \"coordinates\"\n    CELLS = \"topology\"\n\n    def __init__(self, simulation: \"_Simulation\", name: str):\n        super().__init__(f\"{PATH_MESH}/{name}\", simulation._file)\n\n    @property\n    def coordinates(self) -> np.ndarray[tuple[int, ...], np.dtype[np.float64]]:\n        return self[self.NODES][:]\n\n    @property\n    def cells(self) -> np.ndarray[tuple[int, ...], np.dtype[np.int64]]:\n        return self[self.CELLS][:]\n\n    @property\n    def cell_type(self) -> str:\n        return self.attrs[\"cell_type\"]",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__getitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "_GitStatus": {
                  "name": "_GitStatus",
                  "path": "bamboost.core.simulation.groups._GitStatus",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "origin",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "commit",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "branch",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "patch",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {},
                  "source": "class _GitStatus(TypedDict):\n    origin: str\n    commit: str\n    branch: str\n    patch: str",
                  "inherited_members": {}
                },
                "GroupGit": {
                  "name": "GroupGit",
                  "path": "bamboost.core.simulation.groups.GroupGit",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation",
                      "annotation": "'_Simulation'",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GroupGit.__init__",
                      "signature": "(self, simulation)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "simulation",
                          "annotation": "'_Simulation'",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, simulation: \"_Simulation\"):\n    super().__init__(\".git\", simulation._file)"
                    },
                    "add": {
                      "name": "add",
                      "path": "bamboost.core.simulation.groups.GroupGit.add",
                      "signature": "(self, repo_path) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "GroupGit",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "repo_path",
                          "annotation": "StrPath",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add(self: GroupGit[Mutable], repo_path: StrPath) -> None:\n    # Make sure the .git group exists\n    self.require_self()\n\n    status = get_git_status(repo_path)\n    name = status[\"origin\"].split(\"/\")[-1].replace(\".git\", \"\")\n    if name in self.keys():  # delete if already exists\n        del self[name]\n\n    new_grp = self.require_group(name)\n    new_grp.attrs.update(\n        {k: v for k, v in status.items() if k in {\"origin\", \"commit\", \"branch\"}}\n    )\n    new_grp.add_dataset(\"patch\", data=status[\"patch\"])"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.simulation.groups.GroupGit.__getitem__",
                      "signature": "(self, key) -> GitItem",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.simulation.groups.GitItem",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> GitItem:\n    grp = super().__getitem__((key, Group[_MT]))\n    return GitItem(key, grp.attrs._dict, grp[\"patch\"][()])"
                    }
                  },
                  "source": "class GroupGit(Group[_MT]):\n    def __init__(self, simulation: \"_Simulation\"):\n        super().__init__(\".git\", simulation._file)\n\n    def add(self: GroupGit[Mutable], repo_path: StrPath) -> None:\n        # Make sure the .git group exists\n        self.require_self()\n\n        status = get_git_status(repo_path)\n        name = status[\"origin\"].split(\"/\")[-1].replace(\".git\", \"\")\n        if name in self.keys():  # delete if already exists\n            del self[name]\n\n        new_grp = self.require_group(name)\n        new_grp.attrs.update(\n            {k: v for k, v in status.items() if k in {\"origin\", \"commit\", \"branch\"}}\n        )\n        new_grp.add_dataset(\"patch\", data=status[\"patch\"])\n\n    def __getitem__(self, key: str) -> GitItem:\n        grp = super().__getitem__((key, Group[_MT]))\n        return GitItem(key, grp.attrs._dict, grp[\"patch\"][()])",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "GitItem": {
                  "name": "GitItem",
                  "path": "bamboost.core.simulation.groups.GitItem",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "attrs",
                      "annotation": "dict",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "patch",
                      "annotation": "bytes",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "name",
                      "annotation": null,
                      "description": null,
                      "value": "name"
                    },
                    {
                      "name": "branch",
                      "annotation": null,
                      "description": null,
                      "value": "status"
                    },
                    {
                      "name": "commit",
                      "annotation": null,
                      "description": null,
                      "value": "status"
                    },
                    {
                      "name": "origin",
                      "annotation": null,
                      "description": null,
                      "value": "status"
                    },
                    {
                      "name": "patch",
                      "annotation": null,
                      "description": null,
                      "value": "patch.decode()"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.groups.GitItem.__init__",
                      "signature": "(self, name, attrs, patch)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "attrs",
                          "annotation": "dict",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "patch",
                          "annotation": "bytes",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, name: str, attrs: dict[str, str], patch: bytes):\n    self.name = name\n    status: _GitStatus = cast(_GitStatus, attrs)\n    self.branch = status[\"branch\"]\n    self.commit = status[\"commit\"]\n    self.origin = status[\"origin\"]\n    self.patch = patch.decode()"
                    },
                    "__repr__": {
                      "name": "__repr__",
                      "path": "bamboost.core.simulation.groups.GitItem.__repr__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __repr__(self) -> str:\n    return f\"GitItem(name={self.name}, branch={self.branch}, commit={self.commit}, origin={self.origin}, patch={self.patch[:10]}...)\""
                    }
                  },
                  "source": "class GitItem:\n    def __init__(self, name: str, attrs: dict[str, str], patch: bytes):\n        self.name = name\n        status: _GitStatus = cast(_GitStatus, attrs)\n        self.branch = status[\"branch\"]\n        self.commit = status[\"commit\"]\n        self.origin = status[\"origin\"]\n        self.patch = patch.decode()\n\n    def __repr__(self) -> str:\n        return f\"GitItem(name={self.name}, branch={self.branch}, commit={self.commit}, origin={self.origin}, patch={self.patch[:10]}...)\"",
                  "inherited_members": {}
                }
              },
              "functions": {
                "get_git_status": {
                  "name": "get_git_status",
                  "path": "bamboost.core.simulation.groups.get_git_status",
                  "signature": "(repo_path) -> _GitStatus",
                  "description": null,
                  "parameters": [
                    {
                      "name": "repo_path",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.core.simulation.groups._GitStatus",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_git_status(repo_path) -> _GitStatus:\n    import subprocess\n\n    def run_git_command(command: str) -> str:\n        return subprocess.run(\n            [\"git\", \"-C\", str(repo_path), *command.split()],\n            capture_output=True,\n            text=True,\n            check=True,\n        ).stdout.strip()\n\n    return {\n        \"origin\": run_git_command(\"remote get-url origin\"),\n        \"commit\": run_git_command(\"rev-parse HEAD\"),\n        \"branch\": run_git_command(\"rev-parse --abbrev-ref HEAD\"),\n        \"patch\": run_git_command(\"diff HEAD\"),\n    }"
                }
              }
            },
            "base": {
              "name": "base",
              "path": "bamboost.core.simulation.base",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/simulation/base.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "log",
                  "annotation": null,
                  "description": null,
                  "value": "BAMBOOST_LOGGER.getChild('simulation')"
                }
              ],
              "modules": {},
              "classes": {
                "SimulationName": {
                  "name": "SimulationName",
                  "path": "bamboost.core.simulation.base.SimulationName",
                  "description": "Name of a simulation.",
                  "parameters": [],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__new__": {
                      "name": "__new__",
                      "path": "bamboost.core.simulation.base.SimulationName.__new__",
                      "signature": "(cls, name=None, length=10)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "length",
                          "annotation": "int",
                          "description": null,
                          "value": "10"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __new__(cls, name: Optional[str] = None, length: int = 10):\n    name = name or cls.generate_name(length)\n    return super().__new__(cls, name)"
                    },
                    "generate_name": {
                      "name": "generate_name",
                      "path": "bamboost.core.simulation.base.SimulationName.generate_name",
                      "signature": "(length) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "length",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@staticmethod\ndef generate_name(length: int) -> str:\n    return uuid.uuid4().hex[:length]"
                    }
                  },
                  "source": "class SimulationName(str):\n    \"\"\"Name of a simulation.\"\"\"\n\n    def __new__(cls, name: Optional[str] = None, length: int = 10):\n        name = name or cls.generate_name(length)\n        return super().__new__(cls, name)\n\n    @staticmethod\n    def generate_name(length: int) -> str:\n        return uuid.uuid4().hex[:length]",
                  "inherited_members": {}
                },
                "_Simulation": {
                  "name": "_Simulation",
                  "path": "bamboost.core.simulation.base._Simulation",
                  "description": "Simulation accessor.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name for the simulation."
                        }
                      ]
                    },
                    {
                      "name": "parent",
                      "annotation": "StrPath",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path to parent/collection directory."
                        }
                      ]
                    },
                    {
                      "name": "comm",
                      "annotation": "Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "MPI communicator. Defaults to MPI.COMM_WORLD."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "index",
                      "annotation": "Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Index object. Defaults to the global index file."
                        }
                      ],
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_repr_html_",
                      "annotation": null,
                      "description": null,
                      "value": "reprs.simulation_html_repr"
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": "name"
                    },
                    {
                      "name": "path",
                      "annotation": "Path",
                      "description": null,
                      "value": "Path(parent).joinpath(name).absolute()"
                    },
                    {
                      "name": "_comm",
                      "annotation": "Comm",
                      "description": null,
                      "value": "comm or MPI.COMM_WORLD"
                    },
                    {
                      "name": "_psize",
                      "annotation": "int",
                      "description": null,
                      "value": "self._comm.size"
                    },
                    {
                      "name": "_prank",
                      "annotation": "int",
                      "description": null,
                      "value": "self._comm.rank"
                    },
                    {
                      "name": "_ranks",
                      "annotation": null,
                      "description": null,
                      "value": "np.array([i for i in range(self._psize)])"
                    },
                    {
                      "name": "_index",
                      "annotation": "Index",
                      "description": null,
                      "value": "index or Index(comm=self._comm)"
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "CollectionUID",
                      "description": null,
                      "value": "kwargs.pop('collection_uid', None) or self._index.resolve_uid(self.path.parent)"
                    },
                    {
                      "name": "_data_file",
                      "annotation": "Path",
                      "description": null,
                      "value": "self.path.joinpath(constants.HDF_DATA_FILE_NAME)"
                    },
                    {
                      "name": "_xdmf_file",
                      "annotation": "Path",
                      "description": null,
                      "value": "self.path.joinpath(constants.XDMF_FILE_NAME)"
                    },
                    {
                      "name": "_bash_file",
                      "annotation": "Path",
                      "description": null,
                      "value": "self.path.joinpath(constants.RUN_FILE_NAME)"
                    },
                    {
                      "name": "root",
                      "annotation": "Group",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Access to HDF5 file root group."
                        }
                      ],
                      "value": "self._file.root"
                    },
                    {
                      "name": "_file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The full uid of the simulation (collection_uid:simulation_name)."
                        }
                      ],
                      "value": null
                    },
                    {
                      "name": "parameters",
                      "annotation": "Parameters",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "metadata",
                      "annotation": "Metadata",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "links",
                      "annotation": "Links",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "files",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "git",
                      "annotation": "GroupGit",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "GroupData",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "meshes",
                      "annotation": "GroupMeshes",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "mesh",
                      "annotation": "GroupMesh",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data_info",
                      "annotation": "pd.DataFrame",
                      "description": [
                        {
                          "kind": "text",
                          "value": "View the data stored."
                        },
                        {
                          "kind": "returns",
                          "value": [
                            {
                              "name": "",
                              "annotation": "pd.DataFrame",
                              "description": "class:`pd.DataFrame`"
                            }
                          ]
                        }
                      ],
                      "value": null
                    }
                  ],
                  "docstring": [
                    {
                      "kind": "raises",
                      "value": [
                        {
                          "annotation": "FileNotFoundError",
                          "description": "If the simulation doesn't exist."
                        }
                      ]
                    }
                  ],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.base._Simulation.__init__",
                      "signature": "(self, name, parent, comm=None, index=None, **kwargs)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "parent",
                          "annotation": "StrPath",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "comm",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "index",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self,\n    name: str,\n    parent: StrPath,\n    comm: Optional[Comm] = None,\n    index: Optional[Index] = None,\n    **kwargs,\n):\n    self.name: str = name\n    self.path: Path = Path(parent).joinpath(name).absolute()\n    if not self.path.is_dir():\n        raise FileNotFoundError(\n            f\"Simulation {self.name} does not exist in {self.path}.\"\n        )\n\n    # MPI information\n    self._comm: Comm = comm or MPI.COMM_WORLD\n    self._psize: int = self._comm.size\n    self._prank: int = self._comm.rank\n    self._ranks = np.array([i for i in range(self._psize)])\n\n    self._index: Index = index or Index(comm=self._comm)\n\n    # Shortcut to collection uid if available, otherwise resolve it\n    self.collection_uid: CollectionUID = kwargs.pop(\n        \"collection_uid\", None\n    ) or self._index.resolve_uid(self.path.parent)\n\n    self._data_file: Path = self.path.joinpath(constants.HDF_DATA_FILE_NAME)\n    self._xdmf_file: Path = self.path.joinpath(constants.XDMF_FILE_NAME)\n    self._bash_file: Path = self.path.joinpath(constants.RUN_FILE_NAME)\n\n    # Alias attributes\n    self.root: Group[_MT] = self._file.root\n    \"\"\"Access to HDF5 file root group.\"\"\""
                    },
                    "from_uid": {
                      "name": "from_uid",
                      "path": "bamboost.core.simulation.base._Simulation.from_uid",
                      "signature": "(cls, uid, **kwargs) -> Self",
                      "description": "Return the `Simulation` with given UID.",
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "uid",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "the full id (Collection uid : simulation name)"
                            }
                          ]
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "typing_extensions.Self",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@classmethod\ndef from_uid(cls, uid: str, **kwargs) -> Self:\n    \"\"\"Return the `Simulation` with given UID.\n\n    Args:\n        uid: the full id (Collection uid : simulation name)\n        **kwargs: additional arguments to pass to the constructor\n    \"\"\"\n    collection_uid, name = uid.split(constants.UID_SEPARATOR)\n    index = kwargs.pop(\"index\", None) or Index()\n    collection_path = index.resolve_path(collection_uid)\n    return cls(name, collection_path, index=index, **kwargs)"
                    },
                    "edit": {
                      "name": "edit",
                      "path": "bamboost.core.simulation.base._Simulation.edit",
                      "signature": "(self) -> SimulationWriter",
                      "description": "Return an object with writing rights to edit the simulation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.simulation.base.SimulationWriter",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def edit(self) -> SimulationWriter:\n    \"\"\"Return an object with writing rights to edit the simulation.\"\"\"\n    return SimulationWriter(self.name, self.path.parent, self._comm, self._index)"
                    },
                    "update_index": {
                      "name": "update_index",
                      "path": "bamboost.core.simulation.base._Simulation.update_index",
                      "signature": "(self, *, metadata=None, parameters=None) -> None",
                      "description": "Push update to sqlite database.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "metadata",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "parameters",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def update_index(\n    self,\n    *,\n    metadata: Optional[SimulationMetadataT] = None,\n    parameters: Optional[SimulationParameterT] = None,\n) -> None:\n    \"\"\"Push update to sqlite database.\n\n    Args:\n        - update_dict (dict): key value pair to push\n    \"\"\"\n    if not config.index.syncTables:\n        return\n\n    if metadata:\n        self._index.update_simulation_metadata(\n            self.collection_uid, self.name, metadata\n        )\n    if parameters:\n        self._index.update_simulation_parameters(\n            self.collection_uid, self.name, parameters\n        )"
                    },
                    "open_in_paraview": {
                      "name": "open_in_paraview",
                      "path": "bamboost.core.simulation.base._Simulation.open_in_paraview",
                      "signature": "(self) -> None",
                      "description": "Open the xdmf file in paraview.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def open_in_paraview(self) -> None:\n    \"\"\"Open the xdmf file in paraview.\"\"\"\n    subprocess.call([\"paraview\", self._xdmf_file])"
                    },
                    "open": {
                      "name": "open",
                      "path": "bamboost.core.simulation.base._Simulation.open",
                      "signature": "(self, mode='r', driver=None) -> h5py.File",
                      "description": "Use this as a context manager in a `with` statement.\nPurpose: keeping the file open to directly access/edit something in the\nHDF5 file of this simulation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mode",
                          "annotation": "FileMode | str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "file mode (see h5py docs)"
                            }
                          ],
                          "value": "'r'"
                        },
                        {
                          "name": "driver",
                          "annotation": null,
                          "description": [
                            {
                              "kind": "text",
                              "value": "file driver (see h5py docs)"
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "h5py.h5py.File",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def open(self, mode: FileMode | str = \"r\", driver=None) -> h5py.File:\n    \"\"\"Use this as a context manager in a `with` statement.\n    Purpose: keeping the file open to directly access/edit something in the\n    HDF5 file of this simulation.\n\n    Args:\n        mode: file mode (see h5py docs)\n        driver: file driver (see h5py docs)\n        comm: mpi communicator\n    \"\"\"\n    mode = FileMode(mode)\n    return self._file.open(mode, driver)"
                    },
                    "get_mesh": {
                      "name": "get_mesh",
                      "path": "bamboost.core.simulation.base._Simulation.get_mesh",
                      "signature": "(self, mesh_name=None) -> Tuple[np.ndarray, np.ndarray]",
                      "description": "Return coordinates and connectivity. Currently returns numpy arrays.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "`str`",
                          "description": [
                            {
                              "kind": "text",
                              "value": "optional, name of mesh to read (default = mesh)"
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "typing.Tuple[numpy.numpy.ndarray, numpy.numpy.ndarray]",
                        "description": null
                      },
                      "docstring": [
                        {
                          "kind": "text",
                          "value": "Returns:\n    Tuple of np.arrays (coordinates, connectivity)"
                        }
                      ],
                      "source": "@with_file_open(\"r\")\ndef get_mesh(self, mesh_name: str = None) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Return coordinates and connectivity. Currently returns numpy arrays.\n\n    Args:\n        mesh_name (`str`): optional, name of mesh to read (default = mesh)\n    Returns:\n        Tuple of np.arrays (coordinates, connectivity)\n    \"\"\"\n    if mesh_name is None:\n        mesh_name = self._default_mesh\n\n    # Raise an error if the mesh is not found\n    if (self._mesh_location.split(\"/\")[0] not in self._file.keys()) or (\n        mesh_name not in self._file[self._mesh_location].keys()\n    ):\n        raise KeyError(f\"Mesh location {self._mesh_location} not found in file.\")\n\n    mesh = self.meshes[mesh_name]\n    return mesh.coordinates, mesh.connectivity"
                    },
                    "show_h5tree": {
                      "name": "show_h5tree",
                      "path": "bamboost.core.simulation.base._Simulation.show_h5tree",
                      "signature": "(self) -> None",
                      "description": "Print the tree inside the h5 file.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open()\ndef show_h5tree(self) -> None:\n    \"\"\"Print the tree inside the h5 file.\"\"\"\n    # print('\\U00002B57 ' + os.path.basename(self.h5file))\n    print(\"\\U0001f43c \" + os.path.basename(self._data_file))\n    utilities.h5_tree(self._file.root._obj)"
                    },
                    "enter_path": {
                      "name": "enter_path",
                      "path": "bamboost.core.simulation.base._Simulation.enter_path",
                      "signature": "(self)",
                      "description": "A context manager for changing the working directory to this simulations' path.\n\n>>> with sim.working_directory():\n>>>     ...",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@contextmanager\ndef enter_path(self):\n    \"\"\"A context manager for changing the working directory to this simulations' path.\n\n    >>> with sim.working_directory():\n    >>>     ...\n    \"\"\"\n\n    current_dir = os.getcwd()\n    try:\n        os.chdir(self.path)\n        yield\n    finally:\n        os.chdir(current_dir)"
                    }
                  },
                  "source": "class _Simulation(ABC, Generic[_MT]):\n    \"\"\"Simulation accessor.\n\n    Args:\n        name: Name for the simulation.\n        parent: Path to parent/collection directory.\n        comm: MPI communicator. Defaults to MPI.COMM_WORLD.\n        index: Index object. Defaults to the global index file.\n\n    Raises:\n        FileNotFoundError: If the simulation doesn't exist.\n    \"\"\"\n\n    _repr_html_ = reprs.simulation_html_repr\n\n    def __init__(\n        self,\n        name: str,\n        parent: StrPath,\n        comm: Optional[Comm] = None,\n        index: Optional[Index] = None,\n        **kwargs,\n    ):\n        self.name: str = name\n        self.path: Path = Path(parent).joinpath(name).absolute()\n        if not self.path.is_dir():\n            raise FileNotFoundError(\n                f\"Simulation {self.name} does not exist in {self.path}.\"\n            )\n\n        # MPI information\n        self._comm: Comm = comm or MPI.COMM_WORLD\n        self._psize: int = self._comm.size\n        self._prank: int = self._comm.rank\n        self._ranks = np.array([i for i in range(self._psize)])\n\n        self._index: Index = index or Index(comm=self._comm)\n\n        # Shortcut to collection uid if available, otherwise resolve it\n        self.collection_uid: CollectionUID = kwargs.pop(\n            \"collection_uid\", None\n        ) or self._index.resolve_uid(self.path.parent)\n\n        self._data_file: Path = self.path.joinpath(constants.HDF_DATA_FILE_NAME)\n        self._xdmf_file: Path = self.path.joinpath(constants.XDMF_FILE_NAME)\n        self._bash_file: Path = self.path.joinpath(constants.RUN_FILE_NAME)\n\n        # Alias attributes\n        self.root: Group[_MT] = self._file.root\n        \"\"\"Access to HDF5 file root group.\"\"\"\n\n    @property\n    @abstractmethod\n    def _file(self) -> HDF5File[_MT]: ...\n\n    @classmethod\n    def from_uid(cls, uid: str, **kwargs) -> Self:\n        \"\"\"Return the `Simulation` with given UID.\n\n        Args:\n            uid: the full id (Collection uid : simulation name)\n            **kwargs: additional arguments to pass to the constructor\n        \"\"\"\n        collection_uid, name = uid.split(constants.UID_SEPARATOR)\n        index = kwargs.pop(\"index\", None) or Index()\n        collection_path = index.resolve_path(collection_uid)\n        return cls(name, collection_path, index=index, **kwargs)\n\n    @property\n    def uid(self) -> str:\n        \"\"\"The full uid of the simulation (collection_uid:simulation_name).\"\"\"\n        return f\"{self.collection_uid}{constants.UID_SEPARATOR}{self.name}\"\n\n    def edit(self) -> SimulationWriter:\n        \"\"\"Return an object with writing rights to edit the simulation.\"\"\"\n        return SimulationWriter(self.name, self.path.parent, self._comm, self._index)\n\n    def update_index(\n        self,\n        *,\n        metadata: Optional[SimulationMetadataT] = None,\n        parameters: Optional[SimulationParameterT] = None,\n    ) -> None:\n        \"\"\"Push update to sqlite database.\n\n        Args:\n            - update_dict (dict): key value pair to push\n        \"\"\"\n        if not config.index.syncTables:\n            return\n\n        if metadata:\n            self._index.update_simulation_metadata(\n                self.collection_uid, self.name, metadata\n            )\n        if parameters:\n            self._index.update_simulation_parameters(\n                self.collection_uid, self.name, parameters\n            )\n\n    @cached_property\n    def parameters(self) -> Parameters[_MT]:\n        return Parameters(self)\n\n    @cached_property\n    def metadata(self) -> Metadata[_MT]:\n        return Metadata(self)\n\n    @cached_property\n    def links(self) -> Links[_MT]:\n        return Links(self)\n\n    @cached_property\n    def files(self):\n        return utilities.FilePicker(self.path)\n\n    @cached_property\n    def git(self) -> GroupGit[_MT]:\n        return GroupGit(self)\n\n    @cached_property\n    def data(self) -> GroupData[_MT]:\n        return GroupData(self)\n\n    @cached_property\n    def meshes(self) -> GroupMeshes[_MT]:\n        return GroupMeshes(self)\n\n    @cached_property\n    def mesh(self) -> GroupMesh:\n        return GroupMesh(self, constants.DEFAULT_MESH_NAME)\n\n    def open_in_paraview(self) -> None:\n        \"\"\"Open the xdmf file in paraview.\"\"\"\n        subprocess.call([\"paraview\", self._xdmf_file])\n\n    def open(self, mode: FileMode | str = \"r\", driver=None) -> h5py.File:\n        \"\"\"Use this as a context manager in a `with` statement.\n        Purpose: keeping the file open to directly access/edit something in the\n        HDF5 file of this simulation.\n\n        Args:\n            mode: file mode (see h5py docs)\n            driver: file driver (see h5py docs)\n            comm: mpi communicator\n        \"\"\"\n        mode = FileMode(mode)\n        return self._file.open(mode, driver)\n\n    @with_file_open(\"r\")\n    def get_mesh(self, mesh_name: str = None) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Return coordinates and connectivity. Currently returns numpy arrays.\n\n        Args:\n            mesh_name (`str`): optional, name of mesh to read (default = mesh)\n        Returns:\n            Tuple of np.arrays (coordinates, connectivity)\n        \"\"\"\n        if mesh_name is None:\n            mesh_name = self._default_mesh\n\n        # Raise an error if the mesh is not found\n        if (self._mesh_location.split(\"/\")[0] not in self._file.keys()) or (\n            mesh_name not in self._file[self._mesh_location].keys()\n        ):\n            raise KeyError(f\"Mesh location {self._mesh_location} not found in file.\")\n\n        mesh = self.meshes[mesh_name]\n        return mesh.coordinates, mesh.connectivity\n\n    @property\n    @deprecated(\"Use `data.info` instead\")\n    @with_file_open(\"r\")\n    def data_info(self) -> pd.DataFrame:\n        \"\"\"View the data stored.\n\n        Returns:\n            :class:`pd.DataFrame`\n        \"\"\"\n        import pandas as pd\n\n        tmp_dictionary = dict()\n        for data in self.data:\n            steps = len(data)\n            shape = data.obj[\"0\"].shape\n            dtype = data.obj[\"0\"].dtype\n            tmp_dictionary[data._name] = {\n                \"dtype\": dtype,\n                \"shape\": shape,\n                \"steps\": steps,\n            }\n        return pd.DataFrame.from_dict(tmp_dictionary)\n\n    @with_file_open()\n    def show_h5tree(self) -> None:\n        \"\"\"Print the tree inside the h5 file.\"\"\"\n        # print('\\U00002B57 ' + os.path.basename(self.h5file))\n        print(\"\\U0001f43c \" + os.path.basename(self._data_file))\n        utilities.h5_tree(self._file.root._obj)\n\n    @contextmanager\n    def enter_path(self):\n        \"\"\"A context manager for changing the working directory to this simulations' path.\n\n        >>> with sim.working_directory():\n        >>>     ...\n        \"\"\"\n\n        current_dir = os.getcwd()\n        try:\n            os.chdir(self.path)\n            yield\n        finally:\n            os.chdir(current_dir)",
                  "inherited_members": {}
                },
                "Simulation": {
                  "name": "Simulation",
                  "path": "bamboost.core.simulation.base.Simulation",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "StrPath",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "comm",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "index",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {},
                  "source": "class Simulation(_Simulation[Immutable]):\n    @cached_property\n    def _file(self) -> HDF5File[Immutable]:\n        return HDF5File(self._data_file, comm=self._comm, mutable=False)",
                  "inherited_members": {
                    "bamboost.core.simulation.base._Simulation": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.__init__"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.name"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.path"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._psize"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._prank"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._ranks"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._index"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.collection_uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._data_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._xdmf_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._bash_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.root"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.from_uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.uid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.edit"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.update_index"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.parameters"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.metadata"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.links"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.files"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.git"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.data"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.meshes"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.mesh"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.open_in_paraview"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.get_mesh"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.data_info"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.show_h5tree"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.enter_path"
                      }
                    ]
                  }
                },
                "SimulationWriter": {
                  "name": "SimulationWriter",
                  "path": "bamboost.core.simulation.base.SimulationWriter",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "StrPath",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "comm",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "index",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.base.SimulationWriter.__init__",
                      "signature": "(self, name, parent, comm=None, index=None, **kwargs)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "parent",
                          "annotation": "StrPath",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "comm",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "index",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self,\n    name: str,\n    parent: StrPath,\n    comm: Optional[Comm] = None,\n    index: Optional[Index] = None,\n    **kwargs,\n):\n    super().__init__(name, parent, comm, index, **kwargs)"
                    },
                    "__enter__": {
                      "name": "__enter__",
                      "path": "bamboost.core.simulation.base.SimulationWriter.__enter__",
                      "signature": "(self) -> SimulationWriter",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.simulation.base.SimulationWriter",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __enter__(self) -> SimulationWriter:\n    self.metadata[\"status\"] = \"started\"\n    return self"
                    },
                    "__exit__": {
                      "name": "__exit__",
                      "path": "bamboost.core.simulation.base.SimulationWriter.__exit__",
                      "signature": "(self, exc_type, exc_val, exc_tb)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exc_type",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exc_val",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exc_tb",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __exit__(self, exc_type, exc_val, exc_tb):\n    if exc_type:\n        self.change_status(f\"failed [{exc_type.__name__}]\")\n        log.error(\n            f\"Simulation failed with {exc_type.__name__}: {exc_val}\\nTraceback: {exc_tb}\"\n        )\n    self.metadata[\"status\"] = \"finished\"\n    self._comm.barrier()"
                    },
                    "initialize": {
                      "name": "initialize",
                      "path": "bamboost.core.simulation.base.SimulationWriter.initialize",
                      "signature": "(self) -> None",
                      "description": "Initialize the simulation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def initialize(self) -> None:\n    \"\"\"Initialize the simulation.\"\"\"\n    # create the data file\n    with self._file.open(FileMode.APPEND, driver=\"mpio\") as f:\n        self.metadata.update(\n            {\n                \"status\": \"initialized\",\n                \"created_at\": datetime.now(),\n            }\n        )\n        # create groups\n        f.create_group(constants.PATH_PARAMETERS)\n        f.create_group(constants.PATH_LINKS)\n        f.create_group(constants.PATH_USERDATA)\n        f.create_group(constants.PATH_DATA)\n        f.create_group(constants.PATH_FIELD_DATA)\n        f.create_group(constants.PATH_SCALAR_DATA)\n        f.create_group(constants.PATH_MESH)\n\n    self._comm.barrier()"
                    },
                    "change_status": {
                      "name": "change_status",
                      "path": "bamboost.core.simulation.base.SimulationWriter.change_status",
                      "signature": "(self, status) -> None",
                      "description": "Change status of simulation.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "status",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "new status"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def change_status(self, status: str) -> None:\n    \"\"\"Change status of simulation.\n\n    Args:\n        status (str): new status\n    \"\"\"\n    self.metadata[\"status\"] = status"
                    },
                    "copy_files": {
                      "name": "copy_files",
                      "path": "bamboost.core.simulation.base.SimulationWriter.copy_files",
                      "signature": "(self, files) -> None",
                      "description": "Copy files to the simulation folder.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "files",
                          "annotation": "Iterable",
                          "description": [
                            {
                              "kind": "text",
                              "value": "list of files/directories to copy"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def copy_files(self, files: Iterable[StrPath]) -> None:\n    \"\"\"Copy files to the simulation folder.\n\n    Args:\n        files: list of files/directories to copy\n    \"\"\"\n    import shutil\n\n    for file in files:\n        path = Path(file)\n        if path.is_file():\n            shutil.copy(path, self.path)\n        elif path.is_dir():\n            shutil.copytree(path, self.path)"
                    },
                    "create_run_script": {
                      "name": "create_run_script",
                      "path": "bamboost.core.simulation.base.SimulationWriter.create_run_script",
                      "signature": "(self, commands, euler=True, sbatch_kwargs=None) -> None",
                      "description": "Create a batch job and put it into the folder.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "commands",
                          "annotation": "list",
                          "description": [
                            {
                              "kind": "text",
                              "value": "A list of strings being the user defined commands to run"
                            }
                          ]
                        },
                        {
                          "name": "euler",
                          "annotation": "bool",
                          "description": [
                            {
                              "kind": "text",
                              "value": "If false, a local bash script will be written"
                            }
                          ],
                          "value": "True"
                        },
                        {
                          "name": "sbatch_kwargs",
                          "annotation": "Optional",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Additional sbatch arguments.\nThis parameter allows you to provide additional arguments to the `sbatch` command\nwhen submitting jobs to a Slurm workload manager. The arguments should be provided\nin the format of a dict of sbatch option name and values.\n\nUse this parameter to specify various job submission options such as the number of\ntasks, CPU cores, memory requirements, email notifications, and other sbatch options\nthat are not covered by default settings.\nBy default, the following sbatch options are set:\n- `--output`: The output file is set to `<uid>.out`.\n- `--job-name`: The job name is set to `<full_uid>`.\n\nThe following arguments should bring you far:\n- `--ntasks`: The number of tasks to run. This is the number of MPI processes to start.\n- `--mem-per-cpu`: The memory required per CPU core.\n- `--time`: The maximum time the job is allowed to run.\n- `--tmp`: Temporary scratch space to use for the job."
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def create_run_script(\n    self,\n    commands: list[str],\n    euler: bool = True,\n    sbatch_kwargs: Optional[dict[str, Any]] = None,\n) -> None:\n    \"\"\"Create a batch job and put it into the folder.\n\n    Args:\n        commands: A list of strings being the user defined commands to run\n        euler: If false, a local bash script will be written\n        sbatch_kwargs: Additional sbatch arguments.\n            This parameter allows you to provide additional arguments to the `sbatch` command\n            when submitting jobs to a Slurm workload manager. The arguments should be provided\n            in the format of a dict of sbatch option name and values.\n\n            Use this parameter to specify various job submission options such as the number of\n            tasks, CPU cores, memory requirements, email notifications, and other sbatch options\n            that are not covered by default settings.\n            By default, the following sbatch options are set:\n            - `--output`: The output file is set to `<uid>.out`.\n            - `--job-name`: The job name is set to `<full_uid>`.\n\n            The following arguments should bring you far:\n            - `--ntasks`: The number of tasks to run. This is the number of MPI processes to start.\n            - `--mem-per-cpu`: The memory required per CPU core.\n            - `--time`: The maximum time the job is allowed to run.\n            - `--tmp`: Temporary scratch space to use for the job.\n    \"\"\"\n    script = \"#!/bin/bash\\n\\n\"\n\n    # Add sbatch options\n    if euler:\n        if sbatch_kwargs is None:\n            sbatch_kwargs = {}\n\n        sbatch_kwargs.setdefault(\n            \"--output\", f\"{self.path.joinpath(self.name + '.out')}\"\n        )\n        sbatch_kwargs.setdefault(\"--job-name\", self.uid)\n\n        for key, value in sbatch_kwargs.items():\n            script += f\"#SBATCH {key}={value}\\n\"\n\n    # Add environment variables\n    script += \"\\n\"\n    script += (\n        f\"\"\"COLLECTION_DIR=$(sqlite3 {config.index.databaseFile} \"SELECT path FROM collections WHERE uid='{self.collection_uid}'\")\\n\"\"\"\n        f\"SIMULATION_DIR={self.path.as_posix()}\\n\"\n        f\"SIMULATION_ID={self.uid}\\n\\n\"\n    )\n    script += \"\\n\".join(commands)\n\n    with self._bash_file.open(\"w\") as file:\n        file.write(script)\n\n    self.metadata[\"submitted\"] = False"
                    },
                    "run_simulation": {
                      "name": "run_simulation",
                      "path": "bamboost.core.simulation.base.SimulationWriter.run_simulation",
                      "signature": "(self, executable='bash') -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "executable",
                          "annotation": "str",
                          "description": null,
                          "value": "'bash'"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def run_simulation(self, executable: str = \"bash\") -> None:\n    assert not MPI_ON, \"This method is not available during MPI execution.\"\n\n    if not self._bash_file.exists():\n        raise FileNotFoundError(\n            f\"Run script {self._bash_file} does not exist. Create one with `create_run_script`.\"\n        )\n\n    env = os.environ.copy()\n    _ = env.pop(\"BAMBOOST_MPI\", None)  # remove bamboost MPI environment variable\n    subprocess.run([executable, self._bash_file.as_posix()], env=env)\n    log.info(f'Simulation \"{self.name}\" submitted.')\n    self.metadata[\"submitted\"] = True"
                    },
                    "submit_simulation": {
                      "name": "submit_simulation",
                      "path": "bamboost.core.simulation.base.SimulationWriter.submit_simulation",
                      "signature": "(self) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def submit_simulation(self) -> None:\n    self.run_simulation(executable=\"sbatch\")"
                    }
                  },
                  "source": "class SimulationWriter(_Simulation[Mutable]):\n    def __init__(\n        self,\n        name: str,\n        parent: StrPath,\n        comm: Optional[Comm] = None,\n        index: Optional[Index] = None,\n        **kwargs,\n    ):\n        super().__init__(name, parent, comm, index, **kwargs)\n\n    def __enter__(self) -> SimulationWriter:\n        self.metadata[\"status\"] = \"started\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            self.change_status(f\"failed [{exc_type.__name__}]\")\n            log.error(\n                f\"Simulation failed with {exc_type.__name__}: {exc_val}\\nTraceback: {exc_tb}\"\n            )\n        self.metadata[\"status\"] = \"finished\"\n        self._comm.barrier()\n\n    @cached_property\n    def _file(self) -> HDF5File[Mutable]:\n        return HDF5File(self._data_file, comm=self._comm, mutable=True)\n\n    def initialize(self) -> None:\n        \"\"\"Initialize the simulation.\"\"\"\n        # create the data file\n        with self._file.open(FileMode.APPEND, driver=\"mpio\") as f:\n            self.metadata.update(\n                {\n                    \"status\": \"initialized\",\n                    \"created_at\": datetime.now(),\n                }\n            )\n            # create groups\n            f.create_group(constants.PATH_PARAMETERS)\n            f.create_group(constants.PATH_LINKS)\n            f.create_group(constants.PATH_USERDATA)\n            f.create_group(constants.PATH_DATA)\n            f.create_group(constants.PATH_FIELD_DATA)\n            f.create_group(constants.PATH_SCALAR_DATA)\n            f.create_group(constants.PATH_MESH)\n\n        self._comm.barrier()\n\n    def change_status(self, status: str) -> None:\n        \"\"\"Change status of simulation.\n\n        Args:\n            status (str): new status\n        \"\"\"\n        self.metadata[\"status\"] = status\n\n    def copy_files(self, files: Iterable[StrPath]) -> None:\n        \"\"\"Copy files to the simulation folder.\n\n        Args:\n            files: list of files/directories to copy\n        \"\"\"\n        import shutil\n\n        for file in files:\n            path = Path(file)\n            if path.is_file():\n                shutil.copy(path, self.path)\n            elif path.is_dir():\n                shutil.copytree(path, self.path)\n\n    def create_run_script(\n        self,\n        commands: list[str],\n        euler: bool = True,\n        sbatch_kwargs: Optional[dict[str, Any]] = None,\n    ) -> None:\n        \"\"\"Create a batch job and put it into the folder.\n\n        Args:\n            commands: A list of strings being the user defined commands to run\n            euler: If false, a local bash script will be written\n            sbatch_kwargs: Additional sbatch arguments.\n                This parameter allows you to provide additional arguments to the `sbatch` command\n                when submitting jobs to a Slurm workload manager. The arguments should be provided\n                in the format of a dict of sbatch option name and values.\n\n                Use this parameter to specify various job submission options such as the number of\n                tasks, CPU cores, memory requirements, email notifications, and other sbatch options\n                that are not covered by default settings.\n                By default, the following sbatch options are set:\n                - `--output`: The output file is set to `<uid>.out`.\n                - `--job-name`: The job name is set to `<full_uid>`.\n\n                The following arguments should bring you far:\n                - `--ntasks`: The number of tasks to run. This is the number of MPI processes to start.\n                - `--mem-per-cpu`: The memory required per CPU core.\n                - `--time`: The maximum time the job is allowed to run.\n                - `--tmp`: Temporary scratch space to use for the job.\n        \"\"\"\n        script = \"#!/bin/bash\\n\\n\"\n\n        # Add sbatch options\n        if euler:\n            if sbatch_kwargs is None:\n                sbatch_kwargs = {}\n\n            sbatch_kwargs.setdefault(\n                \"--output\", f\"{self.path.joinpath(self.name + '.out')}\"\n            )\n            sbatch_kwargs.setdefault(\"--job-name\", self.uid)\n\n            for key, value in sbatch_kwargs.items():\n                script += f\"#SBATCH {key}={value}\\n\"\n\n        # Add environment variables\n        script += \"\\n\"\n        script += (\n            f\"\"\"COLLECTION_DIR=$(sqlite3 {config.index.databaseFile} \"SELECT path FROM collections WHERE uid='{self.collection_uid}'\")\\n\"\"\"\n            f\"SIMULATION_DIR={self.path.as_posix()}\\n\"\n            f\"SIMULATION_ID={self.uid}\\n\\n\"\n        )\n        script += \"\\n\".join(commands)\n\n        with self._bash_file.open(\"w\") as file:\n            file.write(script)\n\n        self.metadata[\"submitted\"] = False\n\n    def run_simulation(self, executable: str = \"bash\") -> None:\n        assert not MPI_ON, \"This method is not available during MPI execution.\"\n\n        if not self._bash_file.exists():\n            raise FileNotFoundError(\n                f\"Run script {self._bash_file} does not exist. Create one with `create_run_script`.\"\n            )\n\n        env = os.environ.copy()\n        _ = env.pop(\"BAMBOOST_MPI\", None)  # remove bamboost MPI environment variable\n        subprocess.run([executable, self._bash_file.as_posix()], env=env)\n        log.info(f'Simulation \"{self.name}\" submitted.')\n        self.metadata[\"submitted\"] = True\n\n    def submit_simulation(self) -> None:\n        self.run_simulation(executable=\"sbatch\")",
                  "inherited_members": {
                    "bamboost.core.simulation.base._Simulation": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._repr_html_"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.name"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.path"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._comm"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._psize"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._prank"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._ranks"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._index"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.collection_uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._data_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._xdmf_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation._bash_file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.root"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.from_uid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.uid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.edit"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.update_index"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.parameters"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.metadata"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.links"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.files"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.git"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.data"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.meshes"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.mesh"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.open_in_paraview"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.get_mesh"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.simulation.base._Simulation.data_info"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.show_h5tree"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.simulation.base._Simulation.enter_path"
                      }
                    ]
                  }
                }
              },
              "functions": {}
            },
            "xdmf": {
              "name": "xdmf",
              "path": "bamboost.core.simulation.xdmf",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/simulation/xdmf.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "__all__",
                  "annotation": null,
                  "description": null,
                  "value": "['XDMFWriter']"
                },
                {
                  "name": "numpy_to_xdmf_dtype",
                  "annotation": null,
                  "description": null,
                  "value": "{'int8': ('Int', '1'), 'int16': ('Int', '2'), 'int32': ('Int', '4'), 'int64': ('Int', '8'), 'uint8': ('UInt', '1'), 'uint16': ('UInt', '2'), 'uint32': ('UInt', '4'), 'uint64': ('UInt', '8'), 'float32': ('Float', '4'), 'float64': ('Float', '8')}"
                }
              ],
              "modules": {},
              "classes": {
                "XDMFWriter": {
                  "name": "XDMFWriter",
                  "path": "bamboost.core.simulation.xdmf.XDMFWriter",
                  "description": "Write xdmf file for a subset of the stored data in the H5 file.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_file",
                      "annotation": null,
                      "description": null,
                      "value": "file"
                    },
                    {
                      "name": "_comm",
                      "annotation": null,
                      "description": null,
                      "value": "file._comm"
                    },
                    {
                      "name": "root_element",
                      "annotation": null,
                      "description": null,
                      "value": "ET.Element('Xdmf', Version='3.0')"
                    },
                    {
                      "name": "domain",
                      "annotation": null,
                      "description": null,
                      "value": "ET.SubElement(self.root_element, 'Domain')"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter.__init__",
                      "signature": "(self, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "HDF5File",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file: HDF5File):\n    self._file = file\n    self._comm = file._comm  # needed for MPISafeMeta metaclass\n    self.root_element = ET.Element(\"Xdmf\", Version=\"3.0\")\n    self.domain = ET.SubElement(self.root_element, \"Domain\")\n    ET.register_namespace(\"xi\", \"https://www.w3.org/2001/XInclude/\")"
                    },
                    "write_file": {
                      "name": "write_file",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter.write_file",
                      "signature": "(self, filename)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "filename",
                          "annotation": "StrPath",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def write_file(self, filename: StrPath):\n    filename = Path(filename)\n    tree = ET.ElementTree(self.root_element)\n    self._pretty_print(tree.getroot())\n    tree.write(filename)"
                    },
                    "_pretty_print": {
                      "name": "_pretty_print",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._pretty_print",
                      "signature": "(self, elem, level=0)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "elem",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "level",
                          "annotation": null,
                          "description": null,
                          "value": "0"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _pretty_print(self, elem, level=0):\n    indent = \"  \"  # 4 spaces\n    if len(elem):\n        if not elem.text or not elem.text.strip():\n            elem.text = \"\\n\" + indent * (level + 1)\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = \"\\n\" + indent * level\n        for elem in elem:\n            self._pretty_print(elem, level + 1)\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = \"\\n\" + indent * level\n    else:\n        if level and (not elem.tail or not elem.tail.strip()):\n            elem.tail = \"\\n\" + indent * level"
                    },
                    "add_mesh": {
                      "name": "add_mesh",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter.add_mesh",
                      "signature": "(self, mesh)",
                      "description": "Add the mesh to the xdmf tree.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh",
                          "annotation": "GroupMesh",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_mesh(self, mesh: \"GroupMesh\"):\n    \"\"\"Add the mesh to the xdmf tree.\n\n    Args:\n        nodes_location: String to geometry/nodes in hdf file\n        cells_location: String to topology/cells in hdf file\n    \"\"\"\n    grid = ET.SubElement(\n        self.domain, \"Grid\", Name=mesh._path.basename, GridType=\"Uniform\"\n    )\n    with self._file.open(FileMode.READ):\n        self._add_nodes(grid, mesh._path.joinpath(\"coordinates\"))\n        self._add_cells(grid, mesh._path.joinpath(\"topology\"))"
                    },
                    "_add_nodes": {
                      "name": "_add_nodes",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._add_nodes",
                      "signature": "(self, grid, nodes_path)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "grid",
                          "annotation": "ET.Element",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "nodes_path",
                          "annotation": "HDF5Path",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _add_nodes(self, grid: ET.Element, nodes_path: HDF5Path):\n    geometry_type = \"XY\"\n\n    points = cast(h5py.Dataset, self._file[nodes_path])\n    geo = ET.SubElement(grid, \"Geometry\", GeometryType=geometry_type)\n    dtype, precission = numpy_to_xdmf_dtype[points.dtype.name]\n    dim = \"{} {}\".format(*points.shape)\n    data_item = ET.SubElement(\n        geo,\n        \"DataItem\",\n        DataType=dtype,\n        Dimensions=dim,\n        Format=\"HDF\",\n        Precision=precission,\n    )\n    data_item.text = f\"{self._file._path.as_posix()}:{nodes_path}\""
                    },
                    "_add_cells": {
                      "name": "_add_cells",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._add_cells",
                      "signature": "(self, grid, cells_path)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "grid",
                          "annotation": "ET.Element",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "cells_path",
                          "annotation": "HDF5Path",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _add_cells(self, grid: ET.Element, cells_path: HDF5Path):\n    cells = cast(h5py.Dataset, self._file[cells_path])\n    nb_cells = cells.shape[0]\n    topo = ET.SubElement(\n        grid,\n        \"Topology\",\n        TopologyType=cells.attrs.get(\"cell_type\", \"Triangle\"),\n        NumberOfElements=str(nb_cells),\n    )\n    dim = \"{} {}\".format(*cells.shape)\n    dt, prec = numpy_to_xdmf_dtype[cells.dtype.name]\n    data_item = ET.SubElement(\n        topo,\n        \"DataItem\",\n        DataType=dt,\n        Dimensions=dim,\n        Format=\"HDF\",\n        Precision=prec,\n    )\n    data_item.text = f\"{self._file._path.as_posix()}:{cells_path}\""
                    },
                    "add_timeseries": {
                      "name": "add_timeseries",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter.add_timeseries",
                      "signature": "(self, timesteps, fields, mesh_name)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "timesteps",
                          "annotation": "Iterable",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "fields",
                          "annotation": "list",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def add_timeseries(\n    self, timesteps: Iterable[float], fields: \"list[FieldData]\", mesh_name: str\n):\n    collection = ET.SubElement(\n        self.domain,\n        \"Grid\",\n        Name=\"TimeSeries\",\n        GridType=\"Collection\",\n        CollectionType=\"Temporal\",\n    )\n\n    with self._file.open(FileMode.READ):\n        for i, t in enumerate(timesteps):\n            self._add_step(i, t, fields, collection, mesh_name)"
                    },
                    "_add_step": {
                      "name": "_add_step",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._add_step",
                      "signature": "(self, step, time, fields, collection, mesh_name)",
                      "description": "Write the data array for time t.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "time",
                          "annotation": "float",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "fields",
                          "annotation": "list",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "collection",
                          "annotation": "ET.Element",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mesh_name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _add_step(\n    self,\n    step: int,\n    time: float,\n    fields: \"list[FieldData]\",\n    collection: ET.Element,\n    mesh_name: str,\n):\n    \"\"\"Write the data array for time t.\n\n    Args:\n        t (float): time\n        data_location (str): String to data in h5 file\n        name (str): Name for the field in the Xdmf file\n    \"\"\"\n    grid = ET.SubElement(collection, \"Grid\")\n    ptr = (\n        f'xpointer(//Grid[@Name=\"{mesh_name}\"]/*[self::Topology or self::Geometry])'\n    )\n\n    ET.SubElement(grid, \"{http://www.w3.org/2003/XInclude}include\", xpointer=ptr)\n    ET.SubElement(grid, \"Time\", Value=str(time))\n\n    for field in fields:\n        self._add_attribute(grid, field, step)"
                    },
                    "_add_attribute": {
                      "name": "_add_attribute",
                      "path": "bamboost.core.simulation.xdmf.XDMFWriter._add_attribute",
                      "signature": "(self, grid, field, step) -> None",
                      "description": "Write an attribute/field.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "grid",
                          "annotation": "ET.Element",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "field",
                          "annotation": "FieldData",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "step",
                          "annotation": "int",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _add_attribute(self, grid: ET.Element, field: \"FieldData\", step: int) -> None:\n    \"\"\"Write an attribute/field.\"\"\"\n    data = field._obj[str(step)]\n    assert isinstance(data, h5py.Dataset), \"Data is not a dataset\"\n\n    if data.ndim == 1 or data.shape[1] <= 1:\n        att_type = \"Scalar\"\n    elif data.ndim == 2:\n        att_type = \"Vector\"\n    elif data.ndim == 3 and len(set(data.shape[1:])) == 1:\n        # Square shape -> Tensor\n        att_type = \"Tensor\"\n    else:\n        att_type = \"Matrix\"\n\n    # Cell or Node data\n    data_type = FieldType(data.attrs.get(\"type\", FieldType.NODE))\n\n    att = ET.SubElement(\n        grid,\n        \"Attribute\",\n        Name=field.name,\n        AttributeType=att_type,\n        Center=data_type.value,\n    )\n\n    dt, prec = numpy_to_xdmf_dtype[data.dtype.name]\n    dim = \" \".join([str(i) for i in data.shape])\n\n    data_item = ET.SubElement(\n        att,\n        \"DataItem\",\n        DataType=dt,\n        Dimensions=dim,\n        Format=\"HDF\",\n        Precision=prec,\n    )\n    data_item.text = f\"{self._file._path.as_posix()}:{field._path}/{step}\""
                    }
                  },
                  "source": "class XDMFWriter(metaclass=RootProcessMeta):\n    \"\"\"Write xdmf file for a subset of the stored data in the H5 file.\n\n    Args:\n        filename (str): xdmf file path\n        h5file (str): h5 file path\"\"\"\n\n    def __init__(self, file: HDF5File):\n        self._file = file\n        self._comm = file._comm  # needed for MPISafeMeta metaclass\n        self.root_element = ET.Element(\"Xdmf\", Version=\"3.0\")\n        self.domain = ET.SubElement(self.root_element, \"Domain\")\n        ET.register_namespace(\"xi\", \"https://www.w3.org/2001/XInclude/\")\n\n    def write_file(self, filename: StrPath):\n        filename = Path(filename)\n        tree = ET.ElementTree(self.root_element)\n        self._pretty_print(tree.getroot())\n        tree.write(filename)\n\n    def _pretty_print(self, elem, level=0):\n        indent = \"  \"  # 4 spaces\n        if len(elem):\n            if not elem.text or not elem.text.strip():\n                elem.text = \"\\n\" + indent * (level + 1)\n            if not elem.tail or not elem.tail.strip():\n                elem.tail = \"\\n\" + indent * level\n            for elem in elem:\n                self._pretty_print(elem, level + 1)\n            if not elem.tail or not elem.tail.strip():\n                elem.tail = \"\\n\" + indent * level\n        else:\n            if level and (not elem.tail or not elem.tail.strip()):\n                elem.tail = \"\\n\" + indent * level\n\n    def add_mesh(self, mesh: \"GroupMesh\"):\n        \"\"\"Add the mesh to the xdmf tree.\n\n        Args:\n            nodes_location: String to geometry/nodes in hdf file\n            cells_location: String to topology/cells in hdf file\n        \"\"\"\n        grid = ET.SubElement(\n            self.domain, \"Grid\", Name=mesh._path.basename, GridType=\"Uniform\"\n        )\n        with self._file.open(FileMode.READ):\n            self._add_nodes(grid, mesh._path.joinpath(\"coordinates\"))\n            self._add_cells(grid, mesh._path.joinpath(\"topology\"))\n\n    def _add_nodes(self, grid: ET.Element, nodes_path: HDF5Path):\n        geometry_type = \"XY\"\n\n        points = cast(h5py.Dataset, self._file[nodes_path])\n        geo = ET.SubElement(grid, \"Geometry\", GeometryType=geometry_type)\n        dtype, precission = numpy_to_xdmf_dtype[points.dtype.name]\n        dim = \"{} {}\".format(*points.shape)\n        data_item = ET.SubElement(\n            geo,\n            \"DataItem\",\n            DataType=dtype,\n            Dimensions=dim,\n            Format=\"HDF\",\n            Precision=precission,\n        )\n        data_item.text = f\"{self._file._path.as_posix()}:{nodes_path}\"\n\n    def _add_cells(self, grid: ET.Element, cells_path: HDF5Path):\n        cells = cast(h5py.Dataset, self._file[cells_path])\n        nb_cells = cells.shape[0]\n        topo = ET.SubElement(\n            grid,\n            \"Topology\",\n            TopologyType=cells.attrs.get(\"cell_type\", \"Triangle\"),\n            NumberOfElements=str(nb_cells),\n        )\n        dim = \"{} {}\".format(*cells.shape)\n        dt, prec = numpy_to_xdmf_dtype[cells.dtype.name]\n        data_item = ET.SubElement(\n            topo,\n            \"DataItem\",\n            DataType=dt,\n            Dimensions=dim,\n            Format=\"HDF\",\n            Precision=prec,\n        )\n        data_item.text = f\"{self._file._path.as_posix()}:{cells_path}\"\n\n    def add_timeseries(\n        self, timesteps: Iterable[float], fields: \"list[FieldData]\", mesh_name: str\n    ):\n        collection = ET.SubElement(\n            self.domain,\n            \"Grid\",\n            Name=\"TimeSeries\",\n            GridType=\"Collection\",\n            CollectionType=\"Temporal\",\n        )\n\n        with self._file.open(FileMode.READ):\n            for i, t in enumerate(timesteps):\n                self._add_step(i, t, fields, collection, mesh_name)\n\n    def _add_step(\n        self,\n        step: int,\n        time: float,\n        fields: \"list[FieldData]\",\n        collection: ET.Element,\n        mesh_name: str,\n    ):\n        \"\"\"Write the data array for time t.\n\n        Args:\n            t (float): time\n            data_location (str): String to data in h5 file\n            name (str): Name for the field in the Xdmf file\n        \"\"\"\n        grid = ET.SubElement(collection, \"Grid\")\n        ptr = (\n            f'xpointer(//Grid[@Name=\"{mesh_name}\"]/*[self::Topology or self::Geometry])'\n        )\n\n        ET.SubElement(grid, \"{http://www.w3.org/2003/XInclude}include\", xpointer=ptr)\n        ET.SubElement(grid, \"Time\", Value=str(time))\n\n        for field in fields:\n            self._add_attribute(grid, field, step)\n\n    def _add_attribute(self, grid: ET.Element, field: \"FieldData\", step: int) -> None:\n        \"\"\"Write an attribute/field.\"\"\"\n        data = field._obj[str(step)]\n        assert isinstance(data, h5py.Dataset), \"Data is not a dataset\"\n\n        if data.ndim == 1 or data.shape[1] <= 1:\n            att_type = \"Scalar\"\n        elif data.ndim == 2:\n            att_type = \"Vector\"\n        elif data.ndim == 3 and len(set(data.shape[1:])) == 1:\n            # Square shape -> Tensor\n            att_type = \"Tensor\"\n        else:\n            att_type = \"Matrix\"\n\n        # Cell or Node data\n        data_type = FieldType(data.attrs.get(\"type\", FieldType.NODE))\n\n        att = ET.SubElement(\n            grid,\n            \"Attribute\",\n            Name=field.name,\n            AttributeType=att_type,\n            Center=data_type.value,\n        )\n\n        dt, prec = numpy_to_xdmf_dtype[data.dtype.name]\n        dim = \" \".join([str(i) for i in data.shape])\n\n        data_item = ET.SubElement(\n            att,\n            \"DataItem\",\n            DataType=dt,\n            Dimensions=dim,\n            Format=\"HDF\",\n            Precision=prec,\n        )\n        data_item.text = f\"{self._file._path.as_posix()}:{field._path}/{step}\"",
                  "inherited_members": {}
                }
              },
              "functions": {}
            }
          },
          "classes": {
            "FieldType": {
              "name": "FieldType",
              "path": "bamboost.core.simulation.FieldType",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "NODE",
                  "annotation": null,
                  "description": null,
                  "value": "'Node'"
                },
                {
                  "name": "ELEMENT",
                  "annotation": null,
                  "description": null,
                  "value": "'Cell'"
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class FieldType(Enum):\n    NODE = \"Node\"\n    ELEMENT = \"Cell\"",
              "inherited_members": {}
            },
            "CellType": {
              "name": "CellType",
              "path": "bamboost.core.simulation.CellType",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "VERTEX",
                  "annotation": null,
                  "description": null,
                  "value": "'Vertex'"
                },
                {
                  "name": "LINE",
                  "annotation": null,
                  "description": null,
                  "value": "'Line'"
                },
                {
                  "name": "TRIANGLE",
                  "annotation": null,
                  "description": null,
                  "value": "'Triangle'"
                },
                {
                  "name": "QUAD",
                  "annotation": null,
                  "description": null,
                  "value": "'Quadrilateral'"
                },
                {
                  "name": "TETRAHEDRON",
                  "annotation": null,
                  "description": null,
                  "value": "'Tetrahedron'"
                },
                {
                  "name": "HEXAHEDRON",
                  "annotation": null,
                  "description": null,
                  "value": "'Hexahedron'"
                },
                {
                  "name": "WEDGE",
                  "annotation": null,
                  "description": null,
                  "value": "'Wedge'"
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class CellType(Enum):\n    # 2D types\n    VERTEX = \"Vertex\"\n    LINE = \"Line\"\n    TRIANGLE = \"Triangle\"\n    QUAD = \"Quadrilateral\"\n\n    # 3D types\n    TETRAHEDRON = \"Tetrahedron\"\n    HEXAHEDRON = \"Hexahedron\"\n    WEDGE = \"Wedge\"",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "hdf5": {
          "name": "hdf5",
          "path": "bamboost.core.hdf5",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/__init__.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {
            "attrs_dict": {
              "name": "attrs_dict",
              "path": "bamboost.core.hdf5.attrs_dict",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/attrs_dict.py",
              "description": null,
              "docstring": [],
              "attributes": [],
              "modules": {},
              "classes": {
                "AttrsDict": {
                  "name": "AttrsDict",
                  "path": "bamboost.core.hdf5.attrs_dict.AttrsDict",
                  "description": "A dictionary-like object for the attributes of a group in the HDF5\nfile.\n\nThis object is tied to a simulation. If the simulation is read-only, the\nobject is immutable. If mutable, changes are pushed to the HDF5 file\nimmediately.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "path to the group in the HDF5 file"
                        }
                      ]
                    }
                  ],
                  "attributes": [
                    {
                      "name": "mutable",
                      "annotation": "bool",
                      "description": null,
                      "value": "file.mutable"
                    },
                    {
                      "name": "_file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": "file"
                    },
                    {
                      "name": "_path",
                      "annotation": "str",
                      "description": null,
                      "value": "path"
                    },
                    {
                      "name": "_dict",
                      "annotation": "dict",
                      "description": null,
                      "value": "self.read()"
                    },
                    {
                      "name": "_obj",
                      "annotation": "h5py.HLObject",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__new__": {
                      "name": "__new__",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__new__",
                      "signature": "(cls, *args, **kwargs)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "args",
                          "annotation": null,
                          "description": null,
                          "value": "()"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __new__(cls, *args, **kwargs):\n    if cls is not AttrsDict:\n        return super().__new__(cls)\n\n    # Singleton pattern for base attrs dict class\n    # signature: __new__(cls, file: HDF5File[_MT], path: str)\n    file = args[0] if args else kwargs.get(\"file\")\n    path = HDF5Path(args[1]) if len(args) > 1 else kwargs.get(\"path\")\n\n    instances = file._attrs_dict_instances\n    if path not in instances:\n        instances[path] = super().__new__(cls)\n    return instances[path]"
                    },
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__init__",
                      "signature": "(self, file, path)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "HDF5File",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file: HDF5File[_MT], path: str):\n    self._file = file\n    self._path = path\n    self._dict = self.read()\n    self.mutable = file.mutable"
                    },
                    "read": {
                      "name": "read",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.read",
                      "signature": "(self) -> dict",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "dict",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef read(self) -> dict:\n    return dict(self._obj.attrs)"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__getitem__",
                      "signature": "(self, key) -> Any",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "typing.Any",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: str) -> Any:\n    return self._dict[key]"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._ipython_key_completions_",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self):\n    return tuple(self._dict.keys())"
                    },
                    "__iter__": {
                      "name": "__iter__",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__iter__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __iter__(self):\n    return iter(self._dict)"
                    },
                    "__len__": {
                      "name": "__len__",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__len__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __len__(self):\n    return len(self._dict)"
                    },
                    "__repr__": {
                      "name": "__repr__",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__repr__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __repr__(self) -> str:\n    return self._dict.__repr__()"
                    },
                    "__str__": {
                      "name": "__str__",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__str__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __str__(self) -> str:\n    return f\"<AttrsDict(path={self._path})>\""
                    },
                    "_repr_pretty_": {
                      "name": "_repr_pretty_",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict._repr_pretty_",
                      "signature": "(self, p, cycle)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "p",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "cycle",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _repr_pretty_(self, p, cycle):\n    cls_name = type(self).__name__\n    if cycle:\n        p.text(f\"{cls_name}(...)\")\n    else:\n        with p.group(8, f\"{cls_name}(\", \")\"):\n            p.pretty(self._dict)"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__setitem__",
                      "signature": "(self, key, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "AttrsDict",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "Any",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __setitem__(self: AttrsDict[Mutable], key: str, value: Any) -> None:\n    self._dict[key] = value\n\n    self._file.single_process_queue.add(\n        lambda self: self._obj.attrs.__setitem__(key, value),\n        (self,),\n    )"
                    },
                    "__delitem__": {
                      "name": "__delitem__",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.__delitem__",
                      "signature": "(self, key) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "AttrsDict",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __delitem__(self: AttrsDict[Mutable], key: str) -> None:\n    if self._file._comm.rank == 0:\n        with self._file.open(FileMode.APPEND):\n            del self._obj.attrs[key]\n    del self._dict[key]"
                    },
                    "update": {
                      "name": "update",
                      "path": "bamboost.core.hdf5.attrs_dict.AttrsDict.update",
                      "signature": "(self, update_dict) -> None",
                      "description": "Update the dictionary. This method pushes the update to the HDF5\nfile.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "AttrsDict",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "update_dict",
                          "annotation": "dict",
                          "description": [
                            {
                              "kind": "text",
                              "value": "new dictionary"
                            }
                          ]
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef update(self: AttrsDict[Mutable], update_dict: dict) -> None:\n    \"\"\"Update the dictionary. This method pushes the update to the HDF5\n    file.\n\n    Args:\n        update_dict: new dictionary\n    \"\"\"\n    self._dict.update(update_dict)\n\n    self._file.single_process_queue.add(\n        lambda self: self._obj.attrs.update(update_dict),\n        (self,),\n    )"
                    }
                  },
                  "source": "class AttrsDict(Mapping, Generic[_MT]):\n    \"\"\"A dictionary-like object for the attributes of a group in the HDF5\n    file.\n\n    This object is tied to a simulation. If the simulation is read-only, the\n    object is immutable. If mutable, changes are pushed to the HDF5 file\n    immediately.\n\n    Args:\n        simulation: the simulation object\n        path: path to the group in the HDF5 file\n    \"\"\"\n\n    mutable: bool = False\n    _file: HDF5File[_MT]\n    _path: str\n    _dict: dict\n\n    def __new__(cls, *args, **kwargs):\n        if cls is not AttrsDict:\n            return super().__new__(cls)\n\n        # Singleton pattern for base attrs dict class\n        # signature: __new__(cls, file: HDF5File[_MT], path: str)\n        file = args[0] if args else kwargs.get(\"file\")\n        path = HDF5Path(args[1]) if len(args) > 1 else kwargs.get(\"path\")\n\n        instances = file._attrs_dict_instances\n        if path not in instances:\n            instances[path] = super().__new__(cls)\n        return instances[path]\n\n    def __init__(self, file: HDF5File[_MT], path: str):\n        self._file = file\n        self._path = path\n        self._dict = self.read()\n        self.mutable = file.mutable\n\n    @with_file_open(FileMode.READ)\n    def read(self) -> dict:\n        return dict(self._obj.attrs)\n\n    def __getitem__(self, key: str) -> Any:\n        return self._dict[key]\n\n    def _ipython_key_completions_(self):\n        return tuple(self._dict.keys())\n\n    def __iter__(self):\n        return iter(self._dict)\n\n    def __len__(self):\n        return len(self._dict)\n\n    def __repr__(self) -> str:\n        return self._dict.__repr__()\n\n    def __str__(self) -> str:\n        return f\"<AttrsDict(path={self._path})>\"\n\n    def _repr_pretty_(self, p, cycle):\n        cls_name = type(self).__name__\n        if cycle:\n            p.text(f\"{cls_name}(...)\")\n        else:\n            with p.group(8, f\"{cls_name}(\", \")\"):\n                p.pretty(self._dict)\n\n    @property\n    def _obj(self) -> h5py.HLObject:\n        obj = self._file[self._path]\n        return obj\n\n    @mutable_only\n    def __setitem__(self: AttrsDict[Mutable], key: str, value: Any) -> None:\n        self._dict[key] = value\n\n        self._file.single_process_queue.add(\n            lambda self: self._obj.attrs.__setitem__(key, value),\n            (self,),\n        )\n\n    @mutable_only\n    def __delitem__(self: AttrsDict[Mutable], key: str) -> None:\n        if self._file._comm.rank == 0:\n            with self._file.open(FileMode.APPEND):\n                del self._obj.attrs[key]\n        del self._dict[key]\n\n    @mutable_only\n    def update(self: AttrsDict[Mutable], update_dict: dict) -> None:\n        \"\"\"Update the dictionary. This method pushes the update to the HDF5\n        file.\n\n        Args:\n            update_dict: new dictionary\n        \"\"\"\n        self._dict.update(update_dict)\n\n        self._file.single_process_queue.add(\n            lambda self: self._obj.attrs.update(update_dict),\n            (self,),\n        )",
                  "inherited_members": {}
                }
              },
              "functions": {}
            },
            "file": {
              "name": "file",
              "path": "bamboost.core.hdf5.file",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/file.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "log",
                  "annotation": null,
                  "description": null,
                  "value": "BAMBOOST_LOGGER.getChild('hdf5')"
                },
                {
                  "name": "MPI_ACTIVE",
                  "annotation": null,
                  "description": null,
                  "value": "'mpio' in h5py.registered_drivers() and h5py.get_config().mpi and MPI_ON"
                },
                {
                  "name": "_VT_filemap",
                  "annotation": null,
                  "description": null,
                  "value": "Type"
                },
                {
                  "name": "HasFileSubtype",
                  "annotation": null,
                  "description": null,
                  "value": "TypeVar('HasFileSubtype', bound=HasFile)"
                }
              ],
              "modules": {},
              "classes": {
                "FileMode": {
                  "name": "FileMode",
                  "path": "bamboost.core.hdf5.file.FileMode",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "READ",
                      "annotation": null,
                      "description": null,
                      "value": "'r'"
                    },
                    {
                      "name": "READ_WRITE",
                      "annotation": null,
                      "description": null,
                      "value": "'r+'"
                    },
                    {
                      "name": "APPEND",
                      "annotation": null,
                      "description": null,
                      "value": "'a'"
                    },
                    {
                      "name": "WRITE",
                      "annotation": null,
                      "description": null,
                      "value": "'w'"
                    },
                    {
                      "name": "WRITE_FAIL",
                      "annotation": null,
                      "description": null,
                      "value": "'w-'"
                    },
                    {
                      "name": "WRITE_CREATE",
                      "annotation": null,
                      "description": null,
                      "value": "'x'"
                    },
                    {
                      "name": "__hirarchy__",
                      "annotation": null,
                      "description": null,
                      "value": "{'r': 0, 'r+': 1, 'a': 1, 'w': 1, 'w-': 1, 'x': 1}"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__lt__": {
                      "name": "__lt__",
                      "path": "bamboost.core.hdf5.file.FileMode.__lt__",
                      "signature": "(self, other) -> bool",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bool",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __lt__(self, other) -> bool:\n    return self.__hirarchy__[self.value] < self.__hirarchy__[other.value]"
                    },
                    "__eq__": {
                      "name": "__eq__",
                      "path": "bamboost.core.hdf5.file.FileMode.__eq__",
                      "signature": "(self, other) -> bool",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bool",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __eq__(self, other) -> bool:\n    return self.__hirarchy__[self.value] == self.__hirarchy__[other.value]"
                    }
                  },
                  "source": "@total_ordering\nclass FileMode(Enum):\n    READ = \"r\"\n    READ_WRITE = \"r+\"\n    APPEND = \"a\"\n    WRITE = \"w\"\n    WRITE_FAIL = \"w-\"\n    WRITE_CREATE = \"x\"\n\n    __hirarchy__ = {\"r\": 0, \"r+\": 1, \"a\": 1, \"w\": 1, \"w-\": 1, \"x\": 1}\n\n    def __lt__(self, other) -> bool:\n        return self.__hirarchy__[self.value] < self.__hirarchy__[other.value]\n\n    def __eq__(self, other) -> bool:\n        return self.__hirarchy__[self.value] == self.__hirarchy__[other.value]",
                  "inherited_members": {}
                },
                "HDF5Path": {
                  "name": "HDF5Path",
                  "path": "bamboost.core.hdf5.file.HDF5Path",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "parent",
                      "annotation": "HDF5Path",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "basename",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "PurePosixPath",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__new__": {
                      "name": "__new__",
                      "path": "bamboost.core.hdf5.file.HDF5Path.__new__",
                      "signature": "(cls, path, absolute=True)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "absolute",
                          "annotation": "bool",
                          "description": null,
                          "value": "True"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __new__(cls, path: str, absolute: bool = True):\n    if isinstance(path, HDF5Path):\n        return path\n    prefix = \"/\" if absolute else \"\"\n    return super().__new__(cls, prefix + \"/\".join(filter(None, path.split(\"/\"))))"
                    },
                    "__truediv__": {
                      "name": "__truediv__",
                      "path": "bamboost.core.hdf5.file.HDF5Path.__truediv__",
                      "signature": "(self, other) -> HDF5Path",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.hdf5.file.HDF5Path",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __truediv__(self, other: str) -> HDF5Path:\n    return self.joinpath(other)"
                    },
                    "joinpath": {
                      "name": "joinpath",
                      "path": "bamboost.core.hdf5.file.HDF5Path.joinpath",
                      "signature": "(self, *other) -> HDF5Path",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": "str",
                          "description": null,
                          "value": "()"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.hdf5.file.HDF5Path",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def joinpath(self, *other: str) -> HDF5Path:\n    return HDF5Path(\"/\".join([self, *other]))"
                    },
                    "relative_to": {
                      "name": "relative_to",
                      "path": "bamboost.core.hdf5.file.HDF5Path.relative_to",
                      "signature": "(self, other) -> HDF5Path",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "other",
                          "annotation": "Union",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.hdf5.file.HDF5Path",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def relative_to(self, other: Union[HDF5Path, str]) -> HDF5Path:\n    other = HDF5Path(other)\n    if not self.startswith(other):\n        raise ValueError(f\"{self} is not a subpath of {other}\")\n    return HDF5Path(self[len(other) :], absolute=False)"
                    }
                  },
                  "source": "class HDF5Path(str):\n    def __new__(cls, path: str, absolute: bool = True):\n        if isinstance(path, HDF5Path):\n            return path\n        prefix = \"/\" if absolute else \"\"\n        return super().__new__(cls, prefix + \"/\".join(filter(None, path.split(\"/\"))))\n\n    def __truediv__(self, other: str) -> HDF5Path:\n        return self.joinpath(other)\n\n    def joinpath(self, *other: str) -> HDF5Path:\n        return HDF5Path(\"/\".join([self, *other]))\n\n    def relative_to(self, other: Union[HDF5Path, str]) -> HDF5Path:\n        other = HDF5Path(other)\n        if not self.startswith(other):\n            raise ValueError(f\"{self} is not a subpath of {other}\")\n        return HDF5Path(self[len(other) :], absolute=False)\n\n    @property\n    def parent(self) -> HDF5Path:\n        return HDF5Path(self.rsplit(\"/\", 1)[0] or \"/\")\n\n    @property\n    def basename(self) -> str:\n        return self.rsplit(\"/\", 1)[-1]\n\n    @property\n    def path(self) -> PurePosixPath:\n        return PurePosixPath(self)",
                  "inherited_members": {}
                },
                "HasFile": {
                  "name": "HasFile",
                  "path": "bamboost.core.hdf5.file.HasFile",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "_file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {},
                  "source": "class HasFile(Protocol[_MT]):\n    _file: HDF5File[_MT]",
                  "inherited_members": {}
                },
                "KeysViewHDF5": {
                  "name": "KeysViewHDF5",
                  "path": "bamboost.core.hdf5.file.KeysViewHDF5",
                  "description": null,
                  "parameters": [],
                  "attributes": [
                    {
                      "name": "__repr__",
                      "annotation": null,
                      "description": null,
                      "value": "__str__"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__str__": {
                      "name": "__str__",
                      "path": "bamboost.core.hdf5.file.KeysViewHDF5.__str__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __str__(self) -> str:\n    return \"<KeysViewHDF5 {}>\".format(list(self))"
                    }
                  },
                  "source": "class KeysViewHDF5(KeysView):\n    def __str__(self) -> str:\n        return \"<KeysViewHDF5 {}>\".format(list(self))\n\n    __repr__ = __str__",
                  "inherited_members": {}
                },
                "_FileMapMixin": {
                  "name": "_FileMapMixin",
                  "path": "bamboost.core.hdf5.file._FileMapMixin",
                  "description": null,
                  "parameters": [],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "keys": {
                      "name": "keys",
                      "path": "bamboost.core.hdf5.file._FileMapMixin.keys",
                      "signature": "(self) -> KeysViewHDF5",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.hdf5.file.KeysViewHDF5",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def keys(self) -> KeysViewHDF5:\n    return KeysViewHDF5(self)"
                    },
                    "items": {
                      "name": "items",
                      "path": "bamboost.core.hdf5.file._FileMapMixin.items",
                      "signature": "(self, all=False)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "all",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def items(self, all: bool = False):\n    if not all:\n        return ((k, v) for k, v in super().items() if \"/\" not in k)\n    return super().items()"
                    },
                    "datasets": {
                      "name": "datasets",
                      "path": "bamboost.core.hdf5.file._FileMapMixin.datasets",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def datasets(self):\n    return tuple(k for k, v in self.items() if v is h5py.Dataset)"
                    },
                    "groups": {
                      "name": "groups",
                      "path": "bamboost.core.hdf5.file._FileMapMixin.groups",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def groups(self):\n    return tuple(k for k, v in self.items() if v is h5py.Group)"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.hdf5.file._FileMapMixin._ipython_key_completions_",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self):\n    return self.keys()"
                    }
                  },
                  "source": "class _FileMapMixin(Mapping[str, _VT_filemap]):\n    def keys(self) -> KeysViewHDF5:\n        return KeysViewHDF5(self)\n\n    def items(self, all: bool = False):\n        if not all:\n            return ((k, v) for k, v in super().items() if \"/\" not in k)\n        return super().items()\n\n    def datasets(self):\n        return tuple(k for k, v in self.items() if v is h5py.Dataset)\n\n    def groups(self):\n        return tuple(k for k, v in self.items() if v is h5py.Group)\n\n    def _ipython_key_completions_(self):\n        return self.keys()",
                  "inherited_members": {}
                },
                "FileMap": {
                  "name": "FileMap",
                  "path": "bamboost.core.hdf5.file.FileMap",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_valid",
                      "annotation": "bool",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "_file",
                      "annotation": null,
                      "description": null,
                      "value": "file"
                    },
                    {
                      "name": "_dict",
                      "annotation": "dict",
                      "description": null,
                      "value": "{}"
                    },
                    {
                      "name": "valid",
                      "annotation": null,
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.file.FileMap.__init__",
                      "signature": "(self, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "HDF5File",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file: HDF5File):\n    self._file = file\n    self._dict: dict[HDF5Path, _VT_filemap] = {}\n    self.valid = False"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.file.FileMap.__getitem__",
                      "signature": "(self, key) -> _VT_filemap",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "HDF5Path",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.hdf5.file._VT_filemap",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key: HDF5Path, /) -> _VT_filemap:\n    return self._dict[key]"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.hdf5.file.FileMap.__setitem__",
                      "signature": "(self, key, value) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "HDF5Path",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": "_VT_filemap",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __setitem__(self, key: HDF5Path, value: _VT_filemap) -> None:\n    self._dict[key] = value"
                    },
                    "__delitem__": {
                      "name": "__delitem__",
                      "path": "bamboost.core.hdf5.file.FileMap.__delitem__",
                      "signature": "(self, key) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "HDF5Path",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __delitem__(self, key: HDF5Path) -> None:\n    self._dict.pop(key)"
                    },
                    "__iter__": {
                      "name": "__iter__",
                      "path": "bamboost.core.hdf5.file.FileMap.__iter__",
                      "signature": "(self) -> Iterator[HDF5Path]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "typing.Iterator[bamboost.core.hdf5.file.HDF5Path]",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __iter__(self) -> Iterator[HDF5Path]:\n    return iter(self._dict)"
                    },
                    "__len__": {
                      "name": "__len__",
                      "path": "bamboost.core.hdf5.file.FileMap.__len__",
                      "signature": "(self) -> int",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "int",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __len__(self) -> int:\n    return len(self._dict)"
                    },
                    "populate": {
                      "name": "populate",
                      "path": "bamboost.core.hdf5.file.FileMap.populate",
                      "signature": "(self, *, exclude_numeric=True) -> None",
                      "description": "Assumes the file is open.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exclude_numeric",
                          "annotation": "bool",
                          "description": null,
                          "value": "True"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def populate(self, *, exclude_numeric: bool = True) -> None:\n    \"\"\"Assumes the file is open.\"\"\"\n\n    # visit all groups and datasets to cache them\n    def cache_items(name, _obj):\n        path = HDF5Path(name)\n        if exclude_numeric and path.basename.isdigit():\n            return\n        self._dict[path] = type(_obj)\n\n    self._file.visititems(cache_items)\n    self.valid = True"
                    },
                    "invalidate": {
                      "name": "invalidate",
                      "path": "bamboost.core.hdf5.file.FileMap.invalidate",
                      "signature": "(self) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def invalidate(self) -> None:\n    self.valid = False"
                    }
                  },
                  "source": "class FileMap(MutableMapping[str, _VT_filemap], _FileMapMixin):\n    _valid: bool\n\n    def __init__(self, file: HDF5File):\n        self._file = file\n        self._dict: dict[HDF5Path, _VT_filemap] = {}\n        self.valid = False\n\n    def __getitem__(self, key: HDF5Path, /) -> _VT_filemap:\n        return self._dict[key]\n\n    def __setitem__(self, key: HDF5Path, value: _VT_filemap) -> None:\n        self._dict[key] = value\n\n    def __delitem__(self, key: HDF5Path) -> None:\n        self._dict.pop(key)\n\n    def __iter__(self) -> Iterator[HDF5Path]:\n        return iter(self._dict)\n\n    def __len__(self) -> int:\n        return len(self._dict)\n\n    def populate(self, *, exclude_numeric: bool = True) -> None:\n        \"\"\"Assumes the file is open.\"\"\"\n\n        # visit all groups and datasets to cache them\n        def cache_items(name, _obj):\n            path = HDF5Path(name)\n            if exclude_numeric and path.basename.isdigit():\n                return\n            self._dict[path] = type(_obj)\n\n        self._file.visititems(cache_items)\n        self.valid = True\n\n    def invalidate(self) -> None:\n        self.valid = False",
                  "inherited_members": {
                    "bamboost.core.hdf5.file._FileMapMixin": [
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin._ipython_key_completions_"
                      }
                    ]
                  }
                },
                "FilteredFileMap": {
                  "name": "FilteredFileMap",
                  "path": "bamboost.core.hdf5.file.FilteredFileMap",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file_map",
                      "annotation": "FileMap",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "parent",
                      "annotation": null,
                      "description": null,
                      "value": "HDF5Path(parent)"
                    },
                    {
                      "name": "file_map",
                      "annotation": null,
                      "description": null,
                      "value": "file_map"
                    },
                    {
                      "name": "valid",
                      "annotation": null,
                      "description": null,
                      "value": "self.file_map.valid"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.file.FilteredFileMap.__init__",
                      "signature": "(self, file_map, parent) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file_map",
                          "annotation": "FileMap",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "parent",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file_map: FileMap, parent: str) -> None:\n    self.parent = HDF5Path(parent)\n    self.file_map = file_map\n    self.valid = self.file_map.valid"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.file.FilteredFileMap.__getitem__",
                      "signature": "(self, key)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __getitem__(self, key, /):\n    return self.file_map[self.parent.joinpath(key)]"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.hdf5.file.FilteredFileMap.__setitem__",
                      "signature": "(self, key, value)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __setitem__(self, key: str, value):\n    self.file_map[self.parent.joinpath(key)] = value"
                    },
                    "__delitem__": {
                      "name": "__delitem__",
                      "path": "bamboost.core.hdf5.file.FilteredFileMap.__delitem__",
                      "signature": "(self, key)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __delitem__(self, key):\n    del self.file_map[self.parent.joinpath(key)]"
                    },
                    "__iter__": {
                      "name": "__iter__",
                      "path": "bamboost.core.hdf5.file.FilteredFileMap.__iter__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __iter__(self):\n    return map(\n        lambda x: HDF5Path(x).relative_to(self.parent),\n        filter(\n            lambda x: x.startswith(self.parent) and not x == self.parent,\n            self.file_map,\n        ),\n    )"
                    },
                    "__len__": {
                      "name": "__len__",
                      "path": "bamboost.core.hdf5.file.FilteredFileMap.__len__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __len__(self):\n    return sum(1 for _ in self.__iter__())"
                    }
                  },
                  "source": "class FilteredFileMap(MutableMapping[str, _VT_filemap], _FileMapMixin):\n    def __init__(self, file_map: FileMap, parent: str) -> None:\n        self.parent = HDF5Path(parent)\n        self.file_map = file_map\n        self.valid = self.file_map.valid\n\n    def __getitem__(self, key, /):\n        return self.file_map[self.parent.joinpath(key)]\n\n    def __setitem__(self, key: str, value):\n        self.file_map[self.parent.joinpath(key)] = value\n\n    def __delitem__(self, key):\n        del self.file_map[self.parent.joinpath(key)]\n\n    def __iter__(self):\n        return map(\n            lambda x: HDF5Path(x).relative_to(self.parent),\n            filter(\n                lambda x: x.startswith(self.parent) and not x == self.parent,\n                self.file_map,\n            ),\n        )\n\n    def __len__(self):\n        return sum(1 for _ in self.__iter__())",
                  "inherited_members": {
                    "bamboost.core.hdf5.file._FileMapMixin": [
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.file._FileMapMixin._ipython_key_completions_"
                      }
                    ]
                  }
                },
                "ProcessQueue": {
                  "name": "ProcessQueue",
                  "path": "bamboost.core.hdf5.file.ProcessQueue",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_file",
                      "annotation": null,
                      "description": null,
                      "value": "file"
                    },
                    {
                      "name": "_comm",
                      "annotation": null,
                      "description": null,
                      "value": "file._comm"
                    },
                    {
                      "name": "deque",
                      "annotation": null,
                      "description": null,
                      "value": "deque[tuple[Callable, tuple]]()"
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.file.ProcessQueue.__init__",
                      "signature": "(self, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "HDF5File",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, file: HDF5File):\n    self._file = file\n    self._comm = file._comm  # needed for MPISafeMeta to work\n    self.deque = deque[tuple[Callable, tuple]]()"
                    },
                    "add": {
                      "name": "add",
                      "path": "bamboost.core.hdf5.file.ProcessQueue.add",
                      "signature": "(self, func, args) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "func",
                          "annotation": "Callable",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "args",
                          "annotation": "tuple",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@RootProcessMeta.exclude\ndef add(self, func: Callable, args: tuple) -> None:\n    # if file is not open, open it and apply the function immediately\n    if not self._file.is_open:\n        if self._file._comm.rank == 0:\n            with self._file.open(FileMode.APPEND):\n                func(*args)\n    # if file is open and not using mpio, apply the function immediately\n    elif self._file.driver != \"mpio\":\n        func(*args)\n    # else, the file is open with mpio, so we add the function to the queue\n    self.deque.append((func, args))\n    log.debug(\n        f\"Added {func.__qualname__} to process queue (args: {','.join(map(str, args))})\"\n    )"
                    },
                    "apply": {
                      "name": "apply",
                      "path": "bamboost.core.hdf5.file.ProcessQueue.apply",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def apply(self):\n    if not self.deque:\n        log.debug(\"Process queue is empty\")\n        return\n\n    with self._file.open(FileMode.APPEND):\n        log.debug(\"Applying process queue...\")\n        while self.deque:\n            func, args = self.deque.popleft()\n            func(*args)\n            log.debug(\n                f\"Applied {func.__qualname__} (args: {','.join(map(str, args))})\"\n            )"
                    }
                  },
                  "source": "class ProcessQueue(metaclass=RootProcessMeta):\n    def __init__(self, file: HDF5File):\n        self._file = file\n        self._comm = file._comm  # needed for MPISafeMeta to work\n        self.deque = deque[tuple[Callable, tuple]]()\n\n    @RootProcessMeta.exclude\n    def add(self, func: Callable, args: tuple) -> None:\n        # if file is not open, open it and apply the function immediately\n        if not self._file.is_open:\n            if self._file._comm.rank == 0:\n                with self._file.open(FileMode.APPEND):\n                    func(*args)\n        # if file is open and not using mpio, apply the function immediately\n        elif self._file.driver != \"mpio\":\n            func(*args)\n        # else, the file is open with mpio, so we add the function to the queue\n        self.deque.append((func, args))\n        log.debug(\n            f\"Added {func.__qualname__} to process queue (args: {','.join(map(str, args))})\"\n        )\n\n    def apply(self):\n        if not self.deque:\n            log.debug(\"Process queue is empty\")\n            return\n\n        with self._file.open(FileMode.APPEND):\n            log.debug(\"Applying process queue...\")\n            while self.deque:\n                func, args = self.deque.popleft()\n                func(*args)\n                log.debug(\n                    f\"Applied {func.__qualname__} (args: {','.join(map(str, args))})\"\n                )",
                  "inherited_members": {}
                },
                "HDF5File": {
                  "name": "HDF5File",
                  "path": "bamboost.core.hdf5.file.HDF5File",
                  "description": "Wrapper for h5py.File to add some functionality",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "StrPath",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "comm",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "mutable",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_filename",
                      "annotation": "str",
                      "description": null,
                      "value": "file.as_posix() if isinstance(file, Path) else file"
                    },
                    {
                      "name": "_comm",
                      "annotation": "Comm",
                      "description": null,
                      "value": "comm or MPI.COMM_WORLD"
                    },
                    {
                      "name": "_context_stack",
                      "annotation": "int",
                      "description": null,
                      "value": "0"
                    },
                    {
                      "name": "mutable",
                      "annotation": "bool",
                      "description": null,
                      "value": "mutable"
                    },
                    {
                      "name": "file_map",
                      "annotation": "FileMap",
                      "description": null,
                      "value": "FileMap(self)"
                    },
                    {
                      "name": "_is_open_on_root_only",
                      "annotation": "bool",
                      "description": null,
                      "value": "False"
                    },
                    {
                      "name": "_attrs_dict_instances",
                      "annotation": "dict",
                      "description": null,
                      "value": "{}"
                    },
                    {
                      "name": "_path",
                      "annotation": null,
                      "description": null,
                      "value": "Path(self._filename).absolute()"
                    },
                    {
                      "name": "single_process_queue",
                      "annotation": null,
                      "description": null,
                      "value": "ProcessQueue(self)"
                    },
                    {
                      "name": "is_open",
                      "annotation": "bool",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": "Group",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.file.HDF5File.__init__",
                      "signature": "(self, file, comm=None, mutable=False)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "StrPath",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "comm",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "mutable",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(\n    self,\n    file: StrPath,\n    comm: Optional[Comm] = None,\n    mutable: bool = False,\n):\n    self._filename = file.as_posix() if isinstance(file, Path) else file\n    self._comm = comm or MPI.COMM_WORLD\n    self._path = Path(self._filename).absolute()\n    self.file_map = FileMap(self)\n    self.mutable = mutable\n\n    # Single process queue: Stuff in here is applied when the file is closed (at\n    # latest)\n    if self.mutable:\n        self.single_process_queue = ProcessQueue(self)"
                    },
                    "__repr__": {
                      "name": "__repr__",
                      "path": "bamboost.core.hdf5.file.HDF5File.__repr__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __repr__(self) -> str:\n    mode_info = self.mode if self.is_open else \"proxy\"\n    status = \"open\" if self.is_open else \"closed\"\n    mutability = Mutable if self.mutable else Immutable\n    return (\n        f'<{mutability} HDF5 file \"{self._filename}\" (mode {mode_info}, {status})>'\n    )"
                    },
                    "open": {
                      "name": "open",
                      "path": "bamboost.core.hdf5.file.HDF5File.open",
                      "signature": "(self, mode='r', driver=None) -> HDF5File",
                      "description": "Context manager to opens the HDF5 file with the specified mode and\ndriver.\n\nThis method attempts to open the file, and if it's locked, it will\nretry until the file becomes available.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mode",
                          "annotation": "Union",
                          "description": [
                            {
                              "kind": "text",
                              "value": "The mode to open the file with. Defaults to \"r\" (read-only)."
                            }
                          ],
                          "value": "'r'"
                        },
                        {
                          "name": "driver",
                          "annotation": null,
                          "description": [
                            {
                              "kind": "text",
                              "value": "The driver to use for file I/O. If \"mpio\" and MPI is\nactive, it will use MPI I/O. Defaults to None."
                            }
                          ],
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "HDF5File",
                        "annotation": "bamboost.core.hdf5.file.HDF5File",
                        "description": "The opened HDF5 file object."
                      },
                      "docstring": [
                        {
                          "kind": "raises",
                          "value": [
                            {
                              "annotation": "BlockingIOError",
                              "description": "If the file is locked (handled internally with retries)."
                            }
                          ]
                        }
                      ],
                      "source": "def open(\n    self,\n    mode: Union[FileMode, str] = \"r\",\n    driver=None,\n) -> HDF5File:\n    \"\"\"Context manager to opens the HDF5 file with the specified mode and\n    driver.\n\n    This method attempts to open the file, and if it's locked, it will\n    retry until the file becomes available.\n\n    Args:\n        mode: The mode to open the file with. Defaults to \"r\" (read-only).\n        driver: The driver to use for file I/O. If \"mpio\" and MPI is\n            active, it will use MPI I/O. Defaults to None.\n\n    Returns:\n        HDF5File: The opened HDF5 file object.\n\n    Raises:\n        BlockingIOError: If the file is locked (handled internally with retries).\n    \"\"\"\n    mode = FileMode(mode)\n\n    if not self.mutable and mode > FileMode.READ:\n        log.error(\n            f\"File is read-only, cannot open in mode {mode.value} (open in read-only mode)\"\n        )\n        mode = FileMode.READ\n\n    self._context_stack += 1\n    log.debug(f\"[{id(self)}] context stack + ({self._context_stack})\")\n\n    if self.is_open:\n        if mode > FileMode(self.mode):\n            # if the new operation requires a higher mode, we close the file\n            # to reopen it with the new mode\n            super().close()\n        else:\n            # if the file is already open with the same or higher mode, we\n            # just increase the context stack and return\n            return self\n\n    return self._try_open_repeat(mode, driver)"
                    },
                    "_try_open_repeat": {
                      "name": "_try_open_repeat",
                      "path": "bamboost.core.hdf5.file.HDF5File._try_open_repeat",
                      "signature": "(self, mode, driver=None) -> Self",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "mode",
                          "annotation": "FileMode",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "driver",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "typing_extensions.Self",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _try_open_repeat(\n    self, mode: FileMode, driver: Optional[Literal[\"mpio\"]] = None\n) -> Self:\n    waiting_logged = False\n\n    # try to open the file until it is available\n    while True:\n        try:\n            if MPI_ACTIVE and mode > FileMode.READ and driver == \"mpio\":\n                h5py.File.__init__(\n                    self, self._filename, mode.value, driver=driver, comm=self._comm\n                )\n            else:\n                h5py.File.__init__(self, self._filename, mode.value)\n            log.debug(\n                f\"[{id(self)}] opened file (mode {mode.value}) {self._filename}\"\n            )\n\n            # create file map\n            if not self.file_map.valid:\n                self.file_map.populate()\n\n            return self\n        except BlockingIOError:\n            # If the file is locked, we wait and try again\n            if not waiting_logged:\n                log.warning(f\"[{id(self)}] file locked (waiting) {self._filename}\")\n            waiting_logged = True\n            time.sleep(0.01)"
                    },
                    "close": {
                      "name": "close",
                      "path": "bamboost.core.hdf5.file.HDF5File.close",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def close(self):\n    self._context_stack = max(0, self._context_stack - 1)\n\n    # if the context stack is 0, we close the file\n    if self._context_stack <= 0:\n        log.debug(f\"[{id(self)}] closed file {self._filename}\")\n        super().close()\n\n        # if the file is mutable, we further apply the single process queue\n        if self.mutable:\n            self.single_process_queue.apply()\n\n    log.debug(f\"[{id(self)}] context stack - ({self._context_stack})\")"
                    },
                    "force_close": {
                      "name": "force_close",
                      "path": "bamboost.core.hdf5.file.HDF5File.force_close",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def force_close(self):\n    super().close()\n    self._context_stack = 0"
                    }
                  },
                  "source": "class HDF5File(h5py.File, Generic[_MT]):\n    \"\"\"Wrapper for h5py.File to add some functionality\"\"\"\n\n    _filename: str\n    _comm: Comm\n    _context_stack: int = 0\n    mutable: bool\n    file_map: FileMap\n    _is_open_on_root_only: bool = False\n    _attrs_dict_instances: dict[str, \"AttrsDict[_MT]\"] = {}\n\n    @overload\n    def __init__(\n        self: HDF5File[Immutable],\n        file: StrPath,\n        comm: Optional[Comm] = None,\n        mutable: Literal[False] = False,\n    ): ...\n    @overload\n    def __init__(\n        self: HDF5File[Mutable],\n        file: StrPath,\n        comm: Optional[Comm] = None,\n        mutable: Literal[True] = True,\n    ): ...\n    def __init__(\n        self,\n        file: StrPath,\n        comm: Optional[Comm] = None,\n        mutable: bool = False,\n    ):\n        self._filename = file.as_posix() if isinstance(file, Path) else file\n        self._comm = comm or MPI.COMM_WORLD\n        self._path = Path(self._filename).absolute()\n        self.file_map = FileMap(self)\n        self.mutable = mutable\n\n        # Single process queue: Stuff in here is applied when the file is closed (at\n        # latest)\n        if self.mutable:\n            self.single_process_queue = ProcessQueue(self)\n\n    def __repr__(self) -> str:\n        mode_info = self.mode if self.is_open else \"proxy\"\n        status = \"open\" if self.is_open else \"closed\"\n        mutability = Mutable if self.mutable else Immutable\n        return (\n            f'<{mutability} HDF5 file \"{self._filename}\" (mode {mode_info}, {status})>'\n        )\n\n    @overload\n    def open(\n        self: HDF5File[Immutable],\n        mode: Literal[FileMode.READ, \"r\"] = \"r\",\n        driver: Optional[Literal[\"mpio\"]] = None,\n    ) -> HDF5File[Immutable]: ...\n    @overload\n    def open(\n        self: HDF5File[Mutable],\n        mode: Union[FileMode, Literal[\"r\", \"r+\", \"w\", \"w-\", \"x\", \"a\"]] = \"r\",\n        driver: Optional[Literal[\"mpio\"]] = None,\n    ) -> HDF5File[Mutable]: ...\n    @overload\n    def open(\n        self: HDF5File,\n        mode: Union[FileMode, str] = \"r\",\n        driver: Optional[Literal[\"mpio\"]] = None,\n    ) -> HDF5File: ...\n    def open(\n        self,\n        mode: Union[FileMode, str] = \"r\",\n        driver=None,\n    ) -> HDF5File:\n        \"\"\"Context manager to opens the HDF5 file with the specified mode and\n        driver.\n\n        This method attempts to open the file, and if it's locked, it will\n        retry until the file becomes available.\n\n        Args:\n            mode: The mode to open the file with. Defaults to \"r\" (read-only).\n            driver: The driver to use for file I/O. If \"mpio\" and MPI is\n                active, it will use MPI I/O. Defaults to None.\n\n        Returns:\n            HDF5File: The opened HDF5 file object.\n\n        Raises:\n            BlockingIOError: If the file is locked (handled internally with retries).\n        \"\"\"\n        mode = FileMode(mode)\n\n        if not self.mutable and mode > FileMode.READ:\n            log.error(\n                f\"File is read-only, cannot open in mode {mode.value} (open in read-only mode)\"\n            )\n            mode = FileMode.READ\n\n        self._context_stack += 1\n        log.debug(f\"[{id(self)}] context stack + ({self._context_stack})\")\n\n        if self.is_open:\n            if mode > FileMode(self.mode):\n                # if the new operation requires a higher mode, we close the file\n                # to reopen it with the new mode\n                super().close()\n            else:\n                # if the file is already open with the same or higher mode, we\n                # just increase the context stack and return\n                return self\n\n        return self._try_open_repeat(mode, driver)\n\n    def _try_open_repeat(\n        self, mode: FileMode, driver: Optional[Literal[\"mpio\"]] = None\n    ) -> Self:\n        waiting_logged = False\n\n        # try to open the file until it is available\n        while True:\n            try:\n                if MPI_ACTIVE and mode > FileMode.READ and driver == \"mpio\":\n                    h5py.File.__init__(\n                        self, self._filename, mode.value, driver=driver, comm=self._comm\n                    )\n                else:\n                    h5py.File.__init__(self, self._filename, mode.value)\n                log.debug(\n                    f\"[{id(self)}] opened file (mode {mode.value}) {self._filename}\"\n                )\n\n                # create file map\n                if not self.file_map.valid:\n                    self.file_map.populate()\n\n                return self\n            except BlockingIOError:\n                # If the file is locked, we wait and try again\n                if not waiting_logged:\n                    log.warning(f\"[{id(self)}] file locked (waiting) {self._filename}\")\n                waiting_logged = True\n                time.sleep(0.01)\n\n    def close(self):\n        self._context_stack = max(0, self._context_stack - 1)\n\n        # if the context stack is 0, we close the file\n        if self._context_stack <= 0:\n            log.debug(f\"[{id(self)}] closed file {self._filename}\")\n            super().close()\n\n            # if the file is mutable, we further apply the single process queue\n            if self.mutable:\n                self.single_process_queue.apply()\n\n        log.debug(f\"[{id(self)}] context stack - ({self._context_stack})\")\n\n    def force_close(self):\n        super().close()\n        self._context_stack = 0\n\n    @property\n    def is_open(self) -> bool:\n        return bool(hasattr(self, \"id\") and self.id.valid)\n\n    @property\n    def root(self) -> Group[_MT]:\n        from .ref import Group\n\n        return Group(\"/\", self)",
                  "inherited_members": {}
                }
              },
              "functions": {
                "mutable_only": {
                  "name": "mutable_only",
                  "path": "bamboost.core.hdf5.file.mutable_only",
                  "signature": "(method) -> Callable[Concatenate[HasFileSubtype, _P], _T]",
                  "description": "Decorator to raise an error if the file is not mutable.",
                  "parameters": [
                    {
                      "name": "method",
                      "annotation": "Callable",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Callable[typing_extensions.Concatenate[bamboost.core.hdf5.file.HasFileSubtype, bamboost._typing._P], bamboost._typing._T]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def mutable_only(\n    method: Callable[Concatenate[HasFileSubtype, _P], _T],\n) -> Callable[Concatenate[HasFileSubtype, _P], _T]:\n    \"\"\"Decorator to raise an error if the file is not mutable.\"\"\"\n\n    @wraps(method)\n    def inner(self: HasFileSubtype, *args: _P.args, **kwargs: _P.kwargs) -> _T:\n        if not self._file.mutable:\n            raise PermissionError(\"Simulation file is read-only.\")\n        return method(self, *args, **kwargs)\n\n    inner._mutable_only = True  # type: ignore\n    return inner"
                },
                "with_file_open": {
                  "name": "with_file_open",
                  "path": "bamboost.core.hdf5.file.with_file_open",
                  "signature": "(mode=FileMode.READ, driver=None) -> Callable[[Callable[Concatenate[HasFileSubtype, _P], _T]], Callable[Concatenate[HasFileSubtype, _P], _T]]",
                  "description": "Decorator for context manager to open and close the file for a method of a class\nwith a file attribute (self._file).",
                  "parameters": [
                    {
                      "name": "mode",
                      "annotation": "FileMode",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The mode to open the file with. Defaults to FileMode.READ."
                        }
                      ],
                      "value": "FileMode.READ"
                    },
                    {
                      "name": "driver",
                      "annotation": "Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The driver to use for file I/O. If \"mpio\" and MPI is active, it will\nuse MPI I/O. Defaults to None."
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Callable[[typing.Callable[typing_extensions.Concatenate[bamboost.core.hdf5.file.HasFileSubtype, bamboost._typing._P], bamboost._typing._T]], typing.Callable[typing_extensions.Concatenate[bamboost.core.hdf5.file.HasFileSubtype, bamboost._typing._P], bamboost._typing._T]]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def with_file_open(\n    mode: FileMode = FileMode.READ,\n    driver: Optional[Literal[\"mpio\"]] = None,\n) -> Callable[\n    [Callable[Concatenate[HasFileSubtype, _P], _T]],\n    Callable[Concatenate[HasFileSubtype, _P], _T],\n]:\n    \"\"\"Decorator for context manager to open and close the file for a method of a class\n    with a file attribute (self._file).\n\n    Args:\n        mode: The mode to open the file with. Defaults to FileMode.READ.\n        driver: The driver to use for file I/O. If \"mpio\" and MPI is active, it will\n            use MPI I/O. Defaults to None.\n    \"\"\"\n\n    def decorator(\n        method: Callable[Concatenate[HasFileSubtype, _P], _T],\n    ) -> Callable[Concatenate[HasFileSubtype, _P], _T]:\n        @wraps(method)\n        def inner(self: HasFileSubtype, *args: _P.args, **kwargs: _P.kwargs) -> _T:\n            with self._file.open(mode, driver):\n                return method(self, *args, **kwargs)\n\n        return inner\n\n    return decorator"
                },
                "add_to_file_queue": {
                  "name": "add_to_file_queue",
                  "path": "bamboost.core.hdf5.file.add_to_file_queue",
                  "signature": "(method) -> Callable[Concatenate[HasFileSubtype, _P], None]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "method",
                      "annotation": "Callable",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Callable[typing_extensions.Concatenate[bamboost.core.hdf5.file.HasFileSubtype, bamboost._typing._P], None]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def add_to_file_queue(\n    method: Callable[Concatenate[HasFileSubtype, _P], None],\n) -> Callable[Concatenate[HasFileSubtype, _P], None]:\n    @wraps(method)\n    def inner(self: HasFileSubtype, *args: _P.args, **kwargs: _P.kwargs) -> None:\n        self._file.single_process_queue.add(method, (self, *args, *kwargs))\n\n    return inner"
                }
              }
            },
            "ref": {
              "name": "ref",
              "path": "bamboost.core.hdf5.ref",
              "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/core/hdf5/ref.py",
              "description": null,
              "docstring": [],
              "attributes": [
                {
                  "name": "log",
                  "annotation": null,
                  "description": null,
                  "value": "BAMBOOST_LOGGER.getChild('hdf5')"
                },
                {
                  "name": "MPI_ACTIVE",
                  "annotation": null,
                  "description": null,
                  "value": "'mpio' in h5py.registered_drivers() and h5py.get_config().mpi and MPI_ON"
                },
                {
                  "name": "_RT_group",
                  "annotation": null,
                  "description": null,
                  "value": "TypeVar('_RT_group', bound=Union['Group', 'Dataset'])"
                },
                {
                  "name": "_g",
                  "annotation": null,
                  "description": null,
                  "value": "Group"
                },
                {
                  "name": "_d",
                  "annotation": null,
                  "description": null,
                  "value": "Dataset"
                }
              ],
              "modules": {},
              "classes": {
                "H5Reference": {
                  "name": "H5Reference",
                  "path": "bamboost.core.hdf5.ref.H5Reference",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_valid",
                      "annotation": "bool | None",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "_file",
                      "annotation": null,
                      "description": null,
                      "value": "file"
                    },
                    {
                      "name": "_path",
                      "annotation": null,
                      "description": null,
                      "value": "HDF5Path(path)"
                    },
                    {
                      "name": "_obj",
                      "annotation": "Union",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "attrs",
                      "annotation": "AttrsDict",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parent",
                      "annotation": "Group",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "mutable",
                      "annotation": "bool",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.ref.H5Reference.__init__",
                      "signature": "(self, path, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "HDF5File",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, path: str, file: HDF5File[_MT]):\n    self._file = file\n    self._path = HDF5Path(path)\n\n    # if the file is open, we check if the object exists\n    # Otherwise, we assume it exists and check when the file is opened\n    if file.is_open:\n        self._valid = self._path in file"
                    },
                    "__repr__": {
                      "name": "__repr__",
                      "path": "bamboost.core.hdf5.ref.H5Reference.__repr__",
                      "signature": "(self) -> str",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "str",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __repr__(self) -> str:\n    valid_str = (\n        \"not checked\"\n        if self._valid is None\n        else \"valid\"\n        if self._valid\n        else \"invalid\"\n    )\n    return f'<HDF5 {type(self).__name__} \"{self._path}\" ({valid_str}, file {self._file._filename})>'"
                    },
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.ref.H5Reference.__getitem__",
                      "signature": "(self, value)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "value",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef __getitem__(self, value):\n    obj = self._obj\n    assert not isinstance(\n        obj, h5py.Datatype\n    ), \"__getitem__ not implemented for Datatype\"\n\n    # If the value is a slice or empty tuple, we return the sliced dataset\n    if isinstance(value, slice) or (isinstance(value, tuple) and len(value) == 0):\n        return obj[value]\n\n    # Here we know that we are looking for a group or dataset\n    if isinstance(value, tuple):\n        name, _type = value\n    else:\n        name, _type = cast(str, value), None\n    return self.new(self._path / name, self._file, _type)"
                    },
                    "open": {
                      "name": "open",
                      "path": "bamboost.core.hdf5.ref.H5Reference.open",
                      "signature": "(self, *args, **kwargs) -> HDF5File[_MT]",
                      "description": "Convenience context manager to open the file of this object (see\nHDF5File.open).",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "args",
                          "annotation": null,
                          "description": null,
                          "value": "()"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.hdf5.file.HDF5File[bamboost._typing._MT]",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def open(self, *args, **kwargs) -> HDF5File[_MT]:\n    \"\"\"Convenience context manager to open the file of this object (see\n    HDF5File.open).\n    \"\"\"\n    return self._file.open(*args, **kwargs)"
                    },
                    "new": {
                      "name": "new",
                      "path": "bamboost.core.hdf5.ref.H5Reference.new",
                      "signature": "(cls, path, file, _type=None) -> _RT_group",
                      "description": "Returns a new pointer object.",
                      "parameters": [
                        {
                          "name": "cls",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": "HDF5File",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "_type",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "bamboost.core.hdf5.ref._RT_group",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@classmethod\ndef new(\n    cls,\n    path: str,\n    file: HDF5File[_MT],\n    _type: Optional[Type[_RT_group]] = None,\n) -> _RT_group:\n    \"\"\"Returns a new pointer object.\"\"\"\n    if _type:\n        return _type(path, file)\n\n    with file.open(FileMode.READ):\n        _obj = file[path]\n        if isinstance(_obj, h5py.Group):\n            return cast(_RT_group, Group(path, file))\n        elif isinstance(_obj, h5py.Dataset):\n            return cast(_RT_group, Dataset(path, file))\n        else:\n            raise ValueError(f\"Object {path} is not a group or dataset\")"
                    }
                  },
                  "source": "class H5Reference(Generic[_MT]):\n    _valid: bool | None = None\n\n    def __init__(self, path: str, file: HDF5File[_MT]):\n        self._file = file\n        self._path = HDF5Path(path)\n\n        # if the file is open, we check if the object exists\n        # Otherwise, we assume it exists and check when the file is opened\n        if file.is_open:\n            self._valid = self._path in file\n\n    @property\n    def _obj(self) -> Union[h5py.Group, h5py.Dataset, h5py.Datatype]:\n        _obj = self._file[self._path]\n        self._valid = True\n        return _obj\n\n    def __repr__(self) -> str:\n        valid_str = (\n            \"not checked\"\n            if self._valid is None\n            else \"valid\"\n            if self._valid\n            else \"invalid\"\n        )\n        return f'<HDF5 {type(self).__name__} \"{self._path}\" ({valid_str}, file {self._file._filename})>'\n\n    @overload\n    def __getitem__(self, value: str) -> Union[Self, Dataset]: ...\n    @overload\n    def __getitem__(self, value: Union[slice, Tuple[()]]) -> Any: ...\n    @overload\n    def __getitem__(self, value: tuple[str, Type[Group]]) -> Group[_MT]: ...\n    @overload\n    def __getitem__(self, value: tuple[str, Type[Dataset]]) -> Dataset[_MT]: ...\n    @with_file_open(FileMode.READ)\n    def __getitem__(self, value):\n        obj = self._obj\n        assert not isinstance(\n            obj, h5py.Datatype\n        ), \"__getitem__ not implemented for Datatype\"\n\n        # If the value is a slice or empty tuple, we return the sliced dataset\n        if isinstance(value, slice) or (isinstance(value, tuple) and len(value) == 0):\n            return obj[value]\n\n        # Here we know that we are looking for a group or dataset\n        if isinstance(value, tuple):\n            name, _type = value\n        else:\n            name, _type = cast(str, value), None\n        return self.new(self._path / name, self._file, _type)\n\n    def open(self, *args, **kwargs) -> HDF5File[_MT]:\n        \"\"\"Convenience context manager to open the file of this object (see\n        HDF5File.open).\n        \"\"\"\n        return self._file.open(*args, **kwargs)\n\n    @classmethod\n    def new(\n        cls,\n        path: str,\n        file: HDF5File[_MT],\n        _type: Optional[Type[_RT_group]] = None,\n    ) -> _RT_group:\n        \"\"\"Returns a new pointer object.\"\"\"\n        if _type:\n            return _type(path, file)\n\n        with file.open(FileMode.READ):\n            _obj = file[path]\n            if isinstance(_obj, h5py.Group):\n                return cast(_RT_group, Group(path, file))\n            elif isinstance(_obj, h5py.Dataset):\n                return cast(_RT_group, Dataset(path, file))\n            else:\n                raise ValueError(f\"Object {path} is not a group or dataset\")\n\n    @cached_property\n    def attrs(self) -> AttrsDict[_MT]:\n        return AttrsDict(self._file, self._path)\n\n    @property\n    @with_file_open(FileMode.READ)\n    def parent(self) -> Group[_MT]:\n        return Group(self._obj.parent.name or \"\", self._file)\n\n    @property\n    def mutable(self) -> bool:\n        return self._file.mutable",
                  "inherited_members": {}
                },
                "Group": {
                  "name": "Group",
                  "path": "bamboost.core.hdf5.ref.Group",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_group_map",
                      "annotation": null,
                      "description": null,
                      "value": "FilteredFileMap(file.file_map, path)"
                    },
                    {
                      "name": "_obj",
                      "annotation": "h5py.Group",
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__init__": {
                      "name": "__init__",
                      "path": "bamboost.core.hdf5.ref.Group.__init__",
                      "signature": "(self, path, file)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "path",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "file",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __init__(self, path, file):\n    super().__init__(path, file)\n\n    # Create a subset view of the file map with all objects\n    self._group_map = FilteredFileMap(file.file_map, path)"
                    },
                    "__setitem__": {
                      "name": "__setitem__",
                      "path": "bamboost.core.hdf5.ref.Group.__setitem__",
                      "signature": "(self, key, newvalue)",
                      "description": "Used to set an attribute.\nWill be written as an attribute to the group.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Group",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "newvalue",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef __setitem__(self: Group[Mutable], key, newvalue):\n    \"\"\"Used to set an attribute.\n    Will be written as an attribute to the group.\n    \"\"\"\n    self.add_numerical_dataset(key, np.array(newvalue))"
                    },
                    "__delitem__": {
                      "name": "__delitem__",
                      "path": "bamboost.core.hdf5.ref.Group.__delitem__",
                      "signature": "(self, key) -> None",
                      "description": "Deletes an item.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Group",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\n@with_file_open(FileMode.APPEND)\ndef __delitem__(self: Group[Mutable], key) -> None:\n    \"\"\"Deletes an item.\"\"\"\n    if key in self.attrs.keys():\n        del self._obj.attrs[key]\n    else:\n        del self._obj[key]"
                    },
                    "_ipython_key_completions_": {
                      "name": "_ipython_key_completions_",
                      "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _ipython_key_completions_(self):\n    return self.keys()"
                    },
                    "__iter__": {
                      "name": "__iter__",
                      "path": "bamboost.core.hdf5.ref.Group.__iter__",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def __iter__(self):\n    for key in self.keys():\n        yield self.__getitem__(key)"
                    },
                    "_assert_file_map_is_valid": {
                      "name": "_assert_file_map_is_valid",
                      "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def _assert_file_map_is_valid(self):\n    if not self._group_map.valid:\n        with self._file.open(FileMode.READ):\n            self._group_map.file_map.populate()"
                    },
                    "keys": {
                      "name": "keys",
                      "path": "bamboost.core.hdf5.ref.Group.keys",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def keys(self):\n    self._assert_file_map_is_valid()\n    return self._group_map.keys()"
                    },
                    "groups": {
                      "name": "groups",
                      "path": "bamboost.core.hdf5.ref.Group.groups",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def groups(self):\n    self._assert_file_map_is_valid()\n    return self._group_map.groups()"
                    },
                    "datasets": {
                      "name": "datasets",
                      "path": "bamboost.core.hdf5.ref.Group.datasets",
                      "signature": "(self)",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "def datasets(self):\n    self._assert_file_map_is_valid()\n    return self._group_map.datasets()"
                    },
                    "items": {
                      "name": "items",
                      "path": "bamboost.core.hdf5.ref.Group.items",
                      "signature": "(self) -> Generator[Tuple[str, Union[Group[_MT], Dataset[_MT]]], None, None]",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "typing.Generator[typing.Tuple[str, typing.Union[bamboost.core.hdf5.ref.Group[bamboost._typing._MT], bamboost.core.hdf5.ref.Dataset[bamboost._typing._MT]]], None, None]",
                        "description": null
                      },
                      "docstring": [],
                      "source": "def items(\n    self,\n) -> Generator[Tuple[str, Union[Group[_MT], Dataset[_MT]]], None, None]:\n    for key in self.keys():\n        yield key, self.__getitem__(key)"
                    },
                    "_repr_html_": {
                      "name": "_repr_html_",
                      "path": "bamboost.core.hdf5.ref.Group._repr_html_",
                      "signature": "(self)",
                      "description": "Repr showing the content of the group.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef _repr_html_(self):\n    \"\"\"Repr showing the content of the group.\"\"\"\n    # If the object is not a group, return a simple representation\n    try:\n        _obj = self._obj\n    except ValueError:\n        self._valid = False\n        return f\"Invalid HDF5 object: <b>{self._path}</b> is not a group\"\n    except KeyError:\n        self._valid = False\n        return f\"Invalid HDF5 object: <b>{self._path}</b> not found in file\"\n\n    from jinja2 import Template\n\n    attrs = dict(_obj.attrs)\n    groups = {key: len(_obj[self._path / key]) for key in self.groups()}  # type: ignore\n    datasets = {\n        key: (_obj[self._path / key].dtype, _obj[self._path / key].shape)  # type: ignore\n        for key in self.datasets()\n    }\n\n    path = self._path\n    path = path if path[0] == \"/\" else \"/\" + path\n\n    html_template = pkgutil.get_data(\n        bamboost.__name__, \"_repr/hdf5_group.html\"\n    ).decode()  # type: ignore\n    icon = pkgutil.get_data(bamboost.__name__, \"_repr/icon.txt\").decode()  # type: ignore\n    template = Template(html_template)\n\n    return template.render(\n        uid=Path(self._file._filename).parent.name,\n        name=path,\n        icon=icon,\n        version=bamboost.__version__,\n        attrs=attrs,\n        groups=groups,\n        datasets=datasets,\n    )"
                    },
                    "require_self": {
                      "name": "require_self",
                      "path": "bamboost.core.hdf5.ref.Group.require_self",
                      "signature": "(self) -> None",
                      "description": "Create the group if it doesn't exist yet.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Group",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\n@with_file_open(FileMode.APPEND)\ndef require_self(self: Group[Mutable]) -> None:\n    \"\"\"Create the group if it doesn't exist yet.\"\"\"\n    self._file.require_group(self._path)\n    self._file.file_map[self._path] = h5py.Group"
                    },
                    "require_group": {
                      "name": "require_group",
                      "path": "bamboost.core.hdf5.ref.Group.require_group",
                      "signature": "(self, name, *, return_type=None)",
                      "description": "Create a group if it doesn't exist yet.",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "return_type",
                          "annotation": null,
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\n@with_file_open(FileMode.APPEND, driver=\"mpio\")\ndef require_group(self, name, *, return_type=None):\n    \"\"\"Create a group if it doesn't exist yet.\"\"\"\n    self._obj.require_group(name)\n\n    # update file_map\n    self._group_map[name] = h5py.Group\n\n    return self.new(self._path.joinpath(name), self._file, _type=return_type)"
                    },
                    "require_dataset": {
                      "name": "require_dataset",
                      "path": "bamboost.core.hdf5.ref.Group.require_dataset",
                      "signature": "(self, name, shape, dtype, exact=False, **kwargs) -> h5py.Dataset",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Group",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "shape",
                          "annotation": "tuple",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "dtype",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "exact",
                          "annotation": "bool",
                          "description": null,
                          "value": "False"
                        },
                        {
                          "name": "kwargs",
                          "annotation": null,
                          "description": null,
                          "value": "{}"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "h5py.h5py.Dataset",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef require_dataset(\n    self: Group[Mutable],\n    name: str,\n    shape: tuple[int, ...],\n    dtype,\n    exact: bool = False,\n    **kwargs,\n) -> h5py.Dataset:\n    grp = self._obj.require_dataset(name, shape, dtype, exact=exact, **kwargs)\n    self._group_map[name] = h5py.Dataset  # type: ignore\n    return grp"
                    },
                    "add_numerical_dataset": {
                      "name": "add_numerical_dataset",
                      "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset",
                      "signature": "(self, name, vector, attrs=None, dtype=None, *, file_map=True) -> None",
                      "description": "Add a dataset to the group. Error is thrown if attempting to overwrite\nwith different shape than before. If same shape, data is overwritten\n(this is inherited from h5py -> require_dataset)",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Group",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Name for the dataset"
                            }
                          ]
                        },
                        {
                          "name": "vector",
                          "annotation": "np.ndarray",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Data to write (max 2d)"
                            }
                          ]
                        },
                        {
                          "name": "attrs",
                          "annotation": "Optional",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. Attributes of dataset."
                            }
                          ],
                          "value": "None"
                        },
                        {
                          "name": "dtype",
                          "annotation": "Optional",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. dtype of dataset. If not specified, uses dtype of inpyt array"
                            }
                          ],
                          "value": "None"
                        },
                        {
                          "name": "file_map",
                          "annotation": "bool",
                          "description": [
                            {
                              "kind": "text",
                              "value": "Optional. If True, the dataset is added to the file map. Default is True."
                            }
                          ],
                          "value": "True"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef add_numerical_dataset(\n    self: Group[Mutable],\n    name: str,\n    vector: np.ndarray,\n    attrs: Optional[Dict[str, Any]] = None,\n    dtype: Optional[str] = None,\n    *,\n    file_map: bool = True,\n) -> None:\n    \"\"\"Add a dataset to the group. Error is thrown if attempting to overwrite\n    with different shape than before. If same shape, data is overwritten\n    (this is inherited from h5py -> require_dataset)\n\n    Args:\n        name: Name for the dataset\n        vector: Data to write (max 2d)\n        attrs: Optional. Attributes of dataset.\n        dtype: Optional. dtype of dataset. If not specified, uses dtype of inpyt array\n        file_map: Optional. If True, the dataset is added to the file map. Default is True.\n    \"\"\"\n    if attrs is None:\n        attrs = {}\n    length_local = vector.shape[0]\n    length_p = np.array(self._file._comm.allgather(length_local))\n    length = np.sum(length_p)\n    dim = vector.shape[1:]\n    vec_shape = length, *dim\n\n    ranks = np.array([i for i in range(self._file._comm.size)])\n    idx_start = np.sum(length_p[ranks < self._file._comm.rank])\n    idx_end = idx_start + length_local\n\n    with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n        dataset = self._obj.require_dataset(\n            name, shape=vec_shape, dtype=dtype if dtype else vector.dtype\n        )\n        dataset[idx_start:idx_end] = vector\n\n    self.attrs.update(attrs)\n    log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n    # update file_map\n    if file_map:\n        self._group_map[name] = h5py.Dataset"
                    },
                    "add_dataset": {
                      "name": "add_dataset",
                      "path": "bamboost.core.hdf5.ref.Group.add_dataset",
                      "signature": "(self, name, data, attrs=None, dtype=None) -> None",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": "Group",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "name",
                          "annotation": "str",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "data",
                          "annotation": "Any",
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "attrs",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        },
                        {
                          "name": "dtype",
                          "annotation": "Optional",
                          "description": null,
                          "value": "None"
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "None",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@mutable_only\ndef add_dataset(\n    self: Group[Mutable],\n    name: str,\n    data: Any,\n    attrs: Optional[Dict[str, Any]] = None,\n    dtype: Optional[str] = None,\n) -> None:\n    if self._file._comm.rank == 0:\n        with self._file.open(FileMode.APPEND):\n            self._obj.create_dataset(name, data=data, dtype=dtype)\n            if attrs:\n                self._obj[name].attrs.update(attrs)\n    log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n    # update file_map\n    self._group_map[name] = h5py.Dataset"
                    }
                  },
                  "source": "class Group(H5Reference[_MT]):\n    def __init__(self, path, file):\n        super().__init__(path, file)\n\n        # Create a subset view of the file map with all objects\n        self._group_map = FilteredFileMap(file.file_map, path)\n\n    @mutable_only\n    def __setitem__(self: Group[Mutable], key, newvalue):\n        \"\"\"Used to set an attribute.\n        Will be written as an attribute to the group.\n        \"\"\"\n        self.add_numerical_dataset(key, np.array(newvalue))\n\n    @mutable_only\n    @with_file_open(FileMode.APPEND)\n    def __delitem__(self: Group[Mutable], key) -> None:\n        \"\"\"Deletes an item.\"\"\"\n        if key in self.attrs.keys():\n            del self._obj.attrs[key]\n        else:\n            del self._obj[key]\n\n    def _ipython_key_completions_(self):\n        return self.keys()\n\n    @property\n    def _obj(self) -> h5py.Group:\n        _obj = super()._obj\n        if not isinstance(_obj, h5py.Group):\n            raise ValueError(f\"Object {self._path} is not a group\")\n        return _obj\n\n    def __iter__(self):\n        for key in self.keys():\n            yield self.__getitem__(key)\n\n    def _assert_file_map_is_valid(self):\n        if not self._group_map.valid:\n            with self._file.open(FileMode.READ):\n                self._group_map.file_map.populate()\n\n    def keys(self):\n        self._assert_file_map_is_valid()\n        return self._group_map.keys()\n\n    def groups(self):\n        self._assert_file_map_is_valid()\n        return self._group_map.groups()\n\n    def datasets(self):\n        self._assert_file_map_is_valid()\n        return self._group_map.datasets()\n\n    def items(\n        self,\n    ) -> Generator[Tuple[str, Union[Group[_MT], Dataset[_MT]]], None, None]:\n        for key in self.keys():\n            yield key, self.__getitem__(key)\n\n    @with_file_open(FileMode.READ)\n    def _repr_html_(self):\n        \"\"\"Repr showing the content of the group.\"\"\"\n        # If the object is not a group, return a simple representation\n        try:\n            _obj = self._obj\n        except ValueError:\n            self._valid = False\n            return f\"Invalid HDF5 object: <b>{self._path}</b> is not a group\"\n        except KeyError:\n            self._valid = False\n            return f\"Invalid HDF5 object: <b>{self._path}</b> not found in file\"\n\n        from jinja2 import Template\n\n        attrs = dict(_obj.attrs)\n        groups = {key: len(_obj[self._path / key]) for key in self.groups()}  # type: ignore\n        datasets = {\n            key: (_obj[self._path / key].dtype, _obj[self._path / key].shape)  # type: ignore\n            for key in self.datasets()\n        }\n\n        path = self._path\n        path = path if path[0] == \"/\" else \"/\" + path\n\n        html_template = pkgutil.get_data(\n            bamboost.__name__, \"_repr/hdf5_group.html\"\n        ).decode()  # type: ignore\n        icon = pkgutil.get_data(bamboost.__name__, \"_repr/icon.txt\").decode()  # type: ignore\n        template = Template(html_template)\n\n        return template.render(\n            uid=Path(self._file._filename).parent.name,\n            name=path,\n            icon=icon,\n            version=bamboost.__version__,\n            attrs=attrs,\n            groups=groups,\n            datasets=datasets,\n        )\n\n    @mutable_only\n    @with_file_open(FileMode.APPEND)\n    def require_self(self: Group[Mutable]) -> None:\n        \"\"\"Create the group if it doesn't exist yet.\"\"\"\n        self._file.require_group(self._path)\n        self._file.file_map[self._path] = h5py.Group\n\n    @overload\n    def require_group(\n        self: Group[Mutable],\n        name: str,\n        *,\n        return_type: Type[_RT_group],\n    ) -> _RT_group: ...\n    @overload\n    def require_group(self: Group[Mutable], name: str) -> Group[Mutable]: ...\n    @mutable_only\n    @with_file_open(FileMode.APPEND, driver=\"mpio\")\n    def require_group(self, name, *, return_type=None):\n        \"\"\"Create a group if it doesn't exist yet.\"\"\"\n        self._obj.require_group(name)\n\n        # update file_map\n        self._group_map[name] = h5py.Group\n\n        return self.new(self._path.joinpath(name), self._file, _type=return_type)\n\n    @mutable_only\n    def require_dataset(\n        self: Group[Mutable],\n        name: str,\n        shape: tuple[int, ...],\n        dtype,\n        exact: bool = False,\n        **kwargs,\n    ) -> h5py.Dataset:\n        grp = self._obj.require_dataset(name, shape, dtype, exact=exact, **kwargs)\n        self._group_map[name] = h5py.Dataset  # type: ignore\n        return grp\n\n    @mutable_only\n    def add_numerical_dataset(\n        self: Group[Mutable],\n        name: str,\n        vector: np.ndarray,\n        attrs: Optional[Dict[str, Any]] = None,\n        dtype: Optional[str] = None,\n        *,\n        file_map: bool = True,\n    ) -> None:\n        \"\"\"Add a dataset to the group. Error is thrown if attempting to overwrite\n        with different shape than before. If same shape, data is overwritten\n        (this is inherited from h5py -> require_dataset)\n\n        Args:\n            name: Name for the dataset\n            vector: Data to write (max 2d)\n            attrs: Optional. Attributes of dataset.\n            dtype: Optional. dtype of dataset. If not specified, uses dtype of inpyt array\n            file_map: Optional. If True, the dataset is added to the file map. Default is True.\n        \"\"\"\n        if attrs is None:\n            attrs = {}\n        length_local = vector.shape[0]\n        length_p = np.array(self._file._comm.allgather(length_local))\n        length = np.sum(length_p)\n        dim = vector.shape[1:]\n        vec_shape = length, *dim\n\n        ranks = np.array([i for i in range(self._file._comm.size)])\n        idx_start = np.sum(length_p[ranks < self._file._comm.rank])\n        idx_end = idx_start + length_local\n\n        with self._file.open(FileMode.APPEND, driver=\"mpio\"):\n            dataset = self._obj.require_dataset(\n                name, shape=vec_shape, dtype=dtype if dtype else vector.dtype\n            )\n            dataset[idx_start:idx_end] = vector\n\n        self.attrs.update(attrs)\n        log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n        # update file_map\n        if file_map:\n            self._group_map[name] = h5py.Dataset\n\n    @mutable_only\n    def add_dataset(\n        self: Group[Mutable],\n        name: str,\n        data: Any,\n        attrs: Optional[Dict[str, Any]] = None,\n        dtype: Optional[str] = None,\n    ) -> None:\n        if self._file._comm.rank == 0:\n            with self._file.open(FileMode.APPEND):\n                self._obj.create_dataset(name, data=data, dtype=dtype)\n                if attrs:\n                    self._obj[name].attrs.update(attrs)\n        log.info(f'Written dataset to \"{self._path}/{name}\"')\n\n        # update file_map\n        self._group_map[name] = h5py.Dataset",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__getitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ]
                  }
                },
                "MutableGroup": {
                  "name": "MutableGroup",
                  "path": "bamboost.core.hdf5.ref.MutableGroup",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [],
                  "docstring": [],
                  "functions": {
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.ref.MutableGroup.__getitem__",
                      "signature": "(self, key)",
                      "description": "Used to access datasets (:class:`~bamboost.common.hdf_pointer.Dataset`)\nor groups inside this group (:class:`~bamboost.common.hdf_pointer.MutableGroup`)",
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": null,
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": null,
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef __getitem__(self, key):\n    \"\"\"Used to access datasets (:class:`~bamboost.common.hdf_pointer.Dataset`)\n    or groups inside this group (:class:`~bamboost.common.hdf_pointer.MutableGroup`)\n    \"\"\"\n    if key in self.attrs:\n        return self.attrs[key]\n\n    return super().__getitem__(key)"
                    }
                  },
                  "source": "class MutableGroup(Group[Mutable]):\n    @overload\n    def __getitem__(self, key: str): ...\n    @overload\n    def __getitem__(self, key: tuple[str, Type[_RT_group]]) -> _RT_group: ...\n    @with_file_open(FileMode.READ)\n    def __getitem__(self, key):\n        \"\"\"Used to access datasets (:class:`~bamboost.common.hdf_pointer.Dataset`)\n        or groups inside this group (:class:`~bamboost.common.hdf_pointer.MutableGroup`)\n        \"\"\"\n        if key in self.attrs:\n            return self.attrs[key]\n\n        return super().__getitem__(key)",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ],
                    "bamboost.core.hdf5.ref.Group": [
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__init__"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._obj"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.Group._group_map"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__setitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__delitem__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._ipython_key_completions_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.__iter__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._assert_file_map_is_valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.keys"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.groups"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.datasets"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.items"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group._repr_html_"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_self"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_group"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.require_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_numerical_dataset"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.Group.add_dataset"
                      }
                    ]
                  }
                },
                "Dataset": {
                  "name": "Dataset",
                  "path": "bamboost.core.hdf5.ref.Dataset",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "file",
                      "annotation": "HDF5File",
                      "description": null,
                      "value": null
                    }
                  ],
                  "attributes": [
                    {
                      "name": "_obj",
                      "annotation": "h5py.Dataset",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "shape",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dtype",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "docstring": [],
                  "functions": {
                    "__getitem__": {
                      "name": "__getitem__",
                      "path": "bamboost.core.hdf5.ref.Dataset.__getitem__",
                      "signature": "(self, key) -> Any",
                      "description": null,
                      "parameters": [
                        {
                          "name": "self",
                          "annotation": null,
                          "description": null,
                          "value": null
                        },
                        {
                          "name": "key",
                          "annotation": "tuple | slice",
                          "description": null,
                          "value": null
                        }
                      ],
                      "returns": {
                        "name": "",
                        "annotation": "typing.Any",
                        "description": null
                      },
                      "docstring": [],
                      "source": "@with_file_open(FileMode.READ)\ndef __getitem__(self, key: tuple | slice) -> Any:\n    return h5py.Dataset.__getitem__(self._obj, key)"
                    }
                  },
                  "source": "class Dataset(H5Reference[_MT]):\n    @property\n    def _obj(self) -> h5py.Dataset:\n        obj = super()._obj\n        if not isinstance(obj, h5py.Dataset):\n            raise ValueError(f\"Object {self._path} is not a dataset\")\n        return obj\n\n    @with_file_open(FileMode.READ)\n    def __getitem__(self, key: tuple | slice) -> Any:\n        return h5py.Dataset.__getitem__(self._obj, key)\n\n    @property\n    @with_file_open(FileMode.READ)\n    def shape(self):\n        return self._obj.shape\n\n    @property\n    @with_file_open(FileMode.READ)\n    def dtype(self):\n        return self._obj.dtype",
                  "inherited_members": {
                    "bamboost.core.hdf5.ref.H5Reference": [
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._valid"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__init__"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._file"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference._path"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.__repr__"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.open"
                      },
                      {
                        "kind": "function",
                        "path": "bamboost.core.hdf5.ref.H5Reference.new"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.attrs"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.parent"
                      },
                      {
                        "kind": "attribute",
                        "path": "bamboost.core.hdf5.ref.H5Reference.mutable"
                      }
                    ]
                  }
                }
              },
              "functions": {}
            }
          },
          "classes": {},
          "functions": {}
        }
      },
      "classes": {},
      "functions": {}
    },
    "cli": {
      "name": "cli",
      "path": "bamboost.cli",
      "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/cli/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [],
      "modules": {
        "_simple_index": {
          "name": "_simple_index",
          "path": "bamboost.cli._simple_index",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/cli/_simple_index.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "FastIndexQuery": {
              "name": "FastIndexQuery",
              "path": "bamboost.cli._simple_index.FastIndexQuery",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "db_path",
                  "annotation": "StrPath",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "db_path",
                  "annotation": null,
                  "description": null,
                  "value": "db_path"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli._simple_index.FastIndexQuery.__init__",
                  "signature": "(self, db_path)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "db_path",
                      "annotation": "StrPath",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, db_path: StrPath):\n    self.db_path = db_path"
                },
                "connection": {
                  "name": "connection",
                  "path": "bamboost.cli._simple_index.FastIndexQuery.connection",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@contextmanager\ndef connection(self):\n    try:\n        self._conn = sqlite3.connect(self.db_path)\n        self._cursor = self._conn.cursor()\n        yield self._cursor\n    finally:\n        self._conn.close()"
                },
                "query": {
                  "name": "query",
                  "path": "bamboost.cli._simple_index.FastIndexQuery.query",
                  "signature": "(self, query) -> list[tuple]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "query",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "list[tuple]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def query(self, query: str) -> list[tuple]:\n    with self.connection() as cursor:\n        cursor.execute(query)\n        return cursor.fetchall()"
                }
              },
              "source": "class FastIndexQuery:\n    def __init__(self, db_path: StrPath):\n        self.db_path = db_path\n\n    @contextmanager\n    def connection(self):\n        try:\n            self._conn = sqlite3.connect(self.db_path)\n            self._cursor = self._conn.cursor()\n            yield self._cursor\n        finally:\n            self._conn.close()\n\n    def query(self, query: str) -> list[tuple]:\n        with self.connection() as cursor:\n            cursor.execute(query)\n            return cursor.fetchall()",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "manager": {
          "name": "manager",
          "path": "bamboost.cli.manager",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/cli/manager.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "Submit": {
              "name": "Submit",
              "path": "bamboost.cli.manager.Submit",
              "description": "Submit a simulation",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "execute": {
                  "name": "execute",
                  "path": "bamboost.cli.manager.Submit.execute",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute(self):\n    pass"
                },
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli.manager.Submit.__init__",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": ""
                }
              },
              "source": "@dataclass\nclass Submit:\n    \"\"\"Submit a simulation\"\"\"\n\n    def execute(self):\n        pass",
              "inherited_members": {}
            },
            "BamboostCli": {
              "name": "BamboostCli",
              "path": "bamboost.cli.manager.BamboostCli",
              "description": "The command line interface of bamboost.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "subcommand",
                  "annotation": "Union",
                  "description": null,
                  "value": null
                },
                {
                  "name": "remote",
                  "annotation": "Optional",
                  "description": null,
                  "value": "field(alias='-r', help='The remote ssh host to interact with.', default=None)"
                }
              ],
              "attributes": [
                {
                  "name": "subcommand",
                  "annotation": "Union",
                  "description": null,
                  "value": null
                },
                {
                  "name": "remote",
                  "annotation": "Optional",
                  "description": null,
                  "value": "field(alias='-r', help='The remote ssh host to interact with.', default=None)"
                }
              ],
              "docstring": [],
              "functions": {
                "execute": {
                  "name": "execute",
                  "path": "bamboost.cli.manager.BamboostCli.execute",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute(self):\n    self.subcommand._parser = self._parser\n    self.subcommand.execute()"
                },
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli.manager.BamboostCli.__init__",
                  "signature": "(self, subcommand, remote=field(alias='-r', help='The remote ssh host to interact with.', default=None)) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "subcommand",
                      "annotation": "Union",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "remote",
                      "annotation": "Optional",
                      "description": null,
                      "value": "field(alias='-r', help='The remote ssh host to interact with.', default=None)"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": ""
                }
              },
              "source": "@dataclass\nclass BamboostCli:\n    \"\"\"The command line interface of bamboost.\"\"\"\n\n    subcommand: Union[Collection, Submit, Index]\n    remote: Optional[str] = field(\n        alias=\"-r\", help=\"The remote ssh host to interact with.\", default=None\n    )\n\n    def execute(self):\n        self.subcommand._parser = self._parser\n        self.subcommand.execute()",
              "inherited_members": {}
            }
          },
          "functions": {
            "main": {
              "name": "main",
              "path": "bamboost.cli.manager.main",
              "signature": "()",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def main():\n    parser = ArgumentParser(formatter_class=Formatter)\n    parser.add_arguments(BamboostCli, \"bamboost\")\n\n    args = parser.parse_args()\n    cli: BamboostCli = args.bamboost\n    cli._parser = parser\n    cli.execute()"
            }
          }
        },
        "job": {
          "name": "job",
          "path": "bamboost.cli.job",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/cli/job.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "BamboostInputFile": {
              "name": "BamboostInputFile",
              "path": "bamboost.cli.job.BamboostInputFile",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "mod",
                  "annotation": "ModuleType",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "REQUIRED_ATTRIBUTES",
                  "annotation": null,
                  "description": null,
                  "value": "['parameters', 'commands']"
                },
                {
                  "name": "OPTIONAL_ATTRIBUTES",
                  "annotation": null,
                  "description": null,
                  "value": "['files', 'links', 'sbatch_kwargs']"
                },
                {
                  "name": "parameters",
                  "annotation": "dict",
                  "description": null,
                  "value": null
                },
                {
                  "name": "commands",
                  "annotation": "list",
                  "description": null,
                  "value": null
                },
                {
                  "name": "sbatch_kwargs",
                  "annotation": "dict",
                  "description": null,
                  "value": "{}"
                },
                {
                  "name": "files",
                  "annotation": "Iterable",
                  "description": null,
                  "value": "[]"
                },
                {
                  "name": "links",
                  "annotation": "dict",
                  "description": null,
                  "value": "{}"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli.job.BamboostInputFile.__init__",
                  "signature": "(self, mod) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "mod",
                      "annotation": "ModuleType",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, mod: ModuleType) -> None:\n    # Initialize default optional attributes\n    self.files = []\n    self.links = {}\n    self.sbatch_kwargs = {}\n\n    for attr in self.REQUIRED_ATTRIBUTES:\n        if not hasattr(mod, attr):\n            raise ValueError(f\"Missing required input: {attr}\")\n        setattr(self, attr, getattr(mod, attr))\n\n    for attr in self.OPTIONAL_ATTRIBUTES:\n        if hasattr(mod, attr):\n            setattr(self, attr, getattr(mod, attr))"
                }
              },
              "source": "class BamboostInputFile:\n    REQUIRED_ATTRIBUTES = [\n        \"parameters\",\n        \"commands\",\n    ]\n    OPTIONAL_ATTRIBUTES = [\n        \"files\",\n        \"links\",\n        \"sbatch_kwargs\",\n    ]\n\n    parameters: dict\n    commands: list[str]\n    sbatch_kwargs: dict\n    files: Iterable[str]\n    links: dict[str, str]\n\n    def __init__(self, mod: ModuleType) -> None:\n        # Initialize default optional attributes\n        self.files = []\n        self.links = {}\n        self.sbatch_kwargs = {}\n\n        for attr in self.REQUIRED_ATTRIBUTES:\n            if not hasattr(mod, attr):\n                raise ValueError(f\"Missing required input: {attr}\")\n            setattr(self, attr, getattr(mod, attr))\n\n        for attr in self.OPTIONAL_ATTRIBUTES:\n            if hasattr(mod, attr):\n                setattr(self, attr, getattr(mod, attr))",
              "inherited_members": {}
            }
          },
          "functions": {
            "job": {
              "name": "job",
              "path": "bamboost.cli.job.job",
              "signature": "()",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def job():\n    parser = argparse.ArgumentParser(description=\"Create and submit jobs\")\n    parser.add_argument(\"db_path\", type=str, help=\"Path to the database\")\n    parser.add_argument(\"input_file\", type=str, help=\"Path to the input file\")\n    parser.add_argument(\"--name\", \"-n\", type=str, help=\"Name of the job\")\n    parser.add_argument(\"--prefix\", \"-np\", type=str, help=\"Prefix for the job name\")\n    parser.add_argument(\"--note\", \"-m\", type=str, help=\"Note for the job\")\n    parser.add_argument(\n        \"--submit\", \"-s\", action=\"store_true\", help=\"Directly submit the job\"\n    )\n    parser.add_argument(\"--euler\", \"-e\", action=\"store_true\", help=\"Job for Euler\")\n\n    args = parser.parse_args()\n\n    sim = create_job(\n        args.db_path,\n        args.input_file,\n        args.name,\n        args.note,\n        args.euler,\n        prefix=args.prefix,\n    )\n\n    if args.submit:\n        sim.submit()\n        print(f\"Submitted simulation {sim.uid} [db: {sim.database_id}]\", flush=True)"
            },
            "create_job": {
              "name": "create_job",
              "path": "bamboost.cli.job.create_job",
              "signature": "(db_path, input_file, name=None, note=None, euler=False, prefix=None)",
              "description": null,
              "parameters": [
                {
                  "name": "db_path",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "input_file",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "name",
                  "annotation": "str",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "note",
                  "annotation": "str",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "euler",
                  "annotation": "bool",
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "prefix",
                  "annotation": "str",
                  "description": null,
                  "value": "None"
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def create_job(\n    db_path: str,\n    input_file: str,\n    name: str = None,\n    note: str = None,\n    euler: bool = False,\n    prefix: str = None,\n):\n    from bamboost import config\n\n    config.options.mpi = False\n    from bamboost.core.manager import Collection\n\n    bb_input = _import_input_file(input_file)\n\n    db = Collection(db_path)\n\n    # create simulation\n    sim = db.create_simulation(\n        name,\n        bb_input.parameters,\n        skip_duplicate_check=True if name else False,\n        note=note,\n        files=bb_input.files,\n        links=bb_input.links,\n        prefix=prefix,\n    )\n\n    # create submission script\n    sim.create_run_script(\n        bb_input.commands,\n        euler=euler,\n        sbatch_kwargs=bb_input.sbatch_kwargs,\n    )\n\n    return sim"
            },
            "_import_input_file": {
              "name": "_import_input_file",
              "path": "bamboost.cli.job._import_input_file",
              "signature": "(input_file)",
              "description": null,
              "parameters": [
                {
                  "name": "input_file",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def _import_input_file(input_file: str):\n    # Add the directory of the input file to sys.path\n    input_dir = os.path.dirname(os.path.abspath(input_file))\n    if input_dir not in sys.path:\n        sys.path.insert(0, input_dir)\n\n    module_name = \"bb_input\"\n    spec = importlib.util.spec_from_file_location(module_name, input_file)\n    module = importlib.util.module_from_spec(spec)\n    sys.modules[module_name] = module\n    spec.loader.exec_module(module)\n\n    return BamboostInputFile(module)"
            }
          }
        },
        "prompt_test": {
          "name": "prompt_test",
          "path": "bamboost.cli.prompt_test",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/cli/prompt_test.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "command_completer",
              "annotation": null,
              "description": null,
              "value": "NestedCompleter.from_nested_dict({'index': {'show': None, 'clean': None, 'scan': None}})"
            },
            {
              "name": "prompt_style",
              "annotation": null,
              "description": null,
              "value": "Style.from_dict({'prompt': 'ansiblue'})"
            }
          ],
          "modules": {},
          "classes": {},
          "functions": {
            "main": {
              "name": "main",
              "path": "bamboost.cli.prompt_test.main",
              "signature": "()",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def main():\n    session = PromptSession(\"bamboost > \", completer=command_completer, style=prompt_style)\n\n    while True:\n        try:\n            text = session.prompt()\n        except KeyboardInterrupt:\n            continue  # Control-C pressed. Try again.\n        except EOFError:\n            break  # Control-D pressed.\n\n    print(\"GoodBye!\")"
            }
          }
        },
        "_collection": {
          "name": "_collection",
          "path": "bamboost.cli._collection",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/cli/_collection.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "Collection": {
              "name": "Collection",
              "path": "bamboost.cli._collection.Collection",
              "description": "Scan for collections.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": null,
                  "value": "field(positional=True, default=False, help='The UID of the collection to display.')"
                },
                {
                  "name": "interactive",
                  "annotation": "bool",
                  "description": null,
                  "value": "field(alias='i', default=False, help='Interactively select a collection.', metadata={'action': 'store_true'})"
                }
              ],
              "attributes": [
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": null,
                  "value": "field(positional=True, default=False, help='The UID of the collection to display.')"
                },
                {
                  "name": "interactive",
                  "annotation": "bool",
                  "description": null,
                  "value": "field(alias='i', default=False, help='Interactively select a collection.', metadata={'action': 'store_true'})"
                }
              ],
              "docstring": [],
              "functions": {
                "execute": {
                  "name": "execute",
                  "path": "bamboost.cli._collection.Collection.execute",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute(self):\n    from rich.console import Console\n\n    console = Console()\n\n    if self.interactive:\n        self.uid = _get_id_interactively(inline_padding=0)\n    else:\n        if self.uid == False:\n            console.print(\n                \"[bold red]Please provide a collection UID or choose the interactive mode.\"\n            )\n            raise SystemExit(1)\n\n    with console.status(\n        f\"[bold blue]Displaying collection '{self.uid}'...\", spinner=\"dots\"\n    ) as status:\n        import rich.box\n        from rich.panel import Panel\n        from rich.table import Table\n\n        from bamboost.index import DEFAULT_INDEX\n\n        coll = DEFAULT_INDEX.collection(self.uid)\n\n        if not coll:\n            console.print(f\"[bold red]Collection with UID '{self.uid}' not found.\")\n            raise SystemExit(1)\n\n        from bamboost.core import Collection as _Collection\n\n        df = _Collection(uid=coll.uid).df\n\n        def render_datetime(dt: datetime) -> str:\n            return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n        for col in df.select_dtypes(include=[\"datetime\"]).columns:\n            df[col] = df[col].apply(render_datetime)\n        df = df.astype(str)\n\n        console.print(f\"[b]>[/b] Collection [bold]{coll.uid}\")\n        console.print(df)"
                },
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli._collection.Collection.__init__",
                  "signature": "(self, uid=field(positional=True, default=False, help='The UID of the collection to display.'), interactive=field(alias='i', default=False, help='Interactively select a collection.', metadata={'action': 'store_true'})) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": null,
                      "value": "field(positional=True, default=False, help='The UID of the collection to display.')"
                    },
                    {
                      "name": "interactive",
                      "annotation": "bool",
                      "description": null,
                      "value": "field(alias='i', default=False, help='Interactively select a collection.', metadata={'action': 'store_true'})"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": ""
                }
              },
              "source": "@dataclass\nclass Collection:\n    \"\"\"Scan for collections.\"\"\"\n\n    uid: str = field(\n        positional=True,\n        default=False,\n        help=\"The UID of the collection to display.\",\n    )\n    interactive: bool = field(\n        alias=\"i\",\n        default=False,\n        help=\"Interactively select a collection.\",\n        metadata={\"action\": \"store_true\"},\n    )\n\n    def execute(self):\n        from rich.console import Console\n\n        console = Console()\n\n        if self.interactive:\n            self.uid = _get_id_interactively(inline_padding=0)\n        else:\n            if self.uid == False:\n                console.print(\n                    \"[bold red]Please provide a collection UID or choose the interactive mode.\"\n                )\n                raise SystemExit(1)\n\n        with console.status(\n            f\"[bold blue]Displaying collection '{self.uid}'...\", spinner=\"dots\"\n        ) as status:\n            import rich.box\n            from rich.panel import Panel\n            from rich.table import Table\n\n            from bamboost.index import DEFAULT_INDEX\n\n            coll = DEFAULT_INDEX.collection(self.uid)\n\n            if not coll:\n                console.print(f\"[bold red]Collection with UID '{self.uid}' not found.\")\n                raise SystemExit(1)\n\n            from bamboost.core import Collection as _Collection\n\n            df = _Collection(uid=coll.uid).df\n\n            def render_datetime(dt: datetime) -> str:\n                return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n            for col in df.select_dtypes(include=[\"datetime\"]).columns:\n                df[col] = df[col].apply(render_datetime)\n            df = df.astype(str)\n\n            console.print(f\"[b]>[/b] Collection [bold]{coll.uid}\")\n            console.print(df)",
              "inherited_members": {}
            }
          },
          "functions": {
            "_get_id_interactively": {
              "name": "_get_id_interactively",
              "path": "bamboost.cli._collection._get_id_interactively",
              "signature": "(inline_padding=0) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "inline_padding",
                  "annotation": "int",
                  "description": null,
                  "value": "0"
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def _get_id_interactively(inline_padding: int = 0) -> str:\n    from textual.app import App, ComposeResult\n    from textual.widgets import DataTable\n\n    class SelectionApp(App):\n        CSS_PATH = \"table.tcss\"\n        ENABLE_COMMAND_PALETTE = False\n        INLINE_PADDING = inline_padding\n\n        class Selection(DataTable):\n            BINDINGS = [\n                (\"j\", \"cursor_down\", \"Down\"),\n                (\"k\", \"cursor_up\", \"Up\"),\n                (\"q\", \"exit\", \"Exit\"),\n            ]\n            BORDER_TITLE = \"Select a collection\"\n\n        def compose(self) -> ComposeResult:\n            table = SelectionApp.Selection(\n                cursor_type=\"row\", id=\"selection-table\", show_header=False\n            )\n            yield table\n\n        def on_mount(self) -> None:\n            table = self.query_one(DataTable)\n            table.add_column(\"\", key=\"index\")\n            table.add_column(\"UID\", key=\"uid\")\n            table.add_column(\"Path\", key=\"path\")\n\n            from bamboost.index import DEFAULT_INDEX\n\n            for i, coll in enumerate(DEFAULT_INDEX.all_collections):\n                table.add_row(i, coll.uid, coll.path)\n            table.focus()\n\n        async def on_data_table_row_selected(\n            self, event: DataTable.RowSelected\n        ) -> None:\n            table = event.control\n            selected_row = table.get_row(event.row_key)\n            selected_id = selected_row[1]\n            self.exit(selected_id)\n\n    selected_id = SelectionApp(watch_css=True, ansi_color=True).run(inline=True)\n    if selected_id is None:\n        raise SystemExit(0)\n    return selected_id"
            }
          }
        },
        "_formatter": {
          "name": "_formatter",
          "path": "bamboost.cli._formatter",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/cli/_formatter.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "TEMPORARY_TOKEN",
              "annotation": null,
              "description": null,
              "value": "'<__TEMP__>'"
            }
          ],
          "modules": {},
          "classes": {
            "Formatter": {
              "name": "Formatter",
              "path": "bamboost.cli._formatter.Formatter",
              "description": "Little shorthand for using some useful HelpFormatters from argparse.\n\nThis class inherits from argparse's `ArgumentDefaultHelpFormatter`,\n`MetavarTypeHelpFormatter` and `RawDescriptionHelpFormatter` classes.\n\nThis produces the following resulting actions:\n- adds a \"(default: xyz)\" for each argument with a default\n- uses the name of the argument type as the metavar. For example, gives\n  \"-n int\" instead of \"-n N\" in the usage and description of the arguments.\n- Conserves the formatting of the class and argument docstrings, if given.",
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "_get_default_metavar_for_optional": {
                  "name": "_get_default_metavar_for_optional",
                  "path": "bamboost.cli._formatter.Formatter._get_default_metavar_for_optional",
                  "signature": "(self, action)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "action",
                      "annotation": "argparse.Action",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_default_metavar_for_optional(self, action: argparse.Action):\n    try:\n        return super()._get_default_metavar_for_optional(action)\n    except BaseException:\n        metavar = self._get_metavar_for_action(action)\n        return metavar"
                },
                "_get_default_metavar_for_positional": {
                  "name": "_get_default_metavar_for_positional",
                  "path": "bamboost.cli._formatter.Formatter._get_default_metavar_for_positional",
                  "signature": "(self, action)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "action",
                      "annotation": "argparse.Action",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_default_metavar_for_positional(self, action: argparse.Action):\n    try:\n        return super()._get_default_metavar_for_positional(action)\n    except BaseException:\n        metavar = self._get_metavar_for_action(action)\n        return metavar"
                },
                "_get_metavar_for_action": {
                  "name": "_get_metavar_for_action",
                  "path": "bamboost.cli._formatter.Formatter._get_metavar_for_action",
                  "signature": "(self, action) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "action",
                      "annotation": "argparse.Action",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_metavar_for_action(self, action: argparse.Action) -> str:\n    return self._get_metavar_for_type(action.type)  # type: ignore"
                },
                "_get_metavar_for_type": {
                  "name": "_get_metavar_for_type",
                  "path": "bamboost.cli._formatter.Formatter._get_metavar_for_type",
                  "signature": "(self, t) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "t",
                      "annotation": "Type",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_metavar_for_type(self, t: Type) -> str:\n    return get_metavar(t) or str(t)"
                },
                "_get_help_string": {
                  "name": "_get_help_string",
                  "path": "bamboost.cli._formatter.Formatter._get_help_string",
                  "signature": "(self, action) -> Optional[str]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "action",
                      "annotation": "Action",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Optional[str]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _get_help_string(self, action: Action) -> Optional[str]:\n    help = super()._get_help_string(action=action)\n    if help is not None:\n        help = help.replace(TEMPORARY_TOKEN, \"\")\n    return help"
                }
              },
              "source": "class Formatter(\n    rich_argparse.RawDescriptionRichHelpFormatter,\n    # rich_argparse.MetavarTypeRichHelpFormatter,\n    rich_argparse.ArgumentDefaultsRichHelpFormatter,\n):\n    \"\"\"Little shorthand for using some useful HelpFormatters from argparse.\n\n    This class inherits from argparse's `ArgumentDefaultHelpFormatter`,\n    `MetavarTypeHelpFormatter` and `RawDescriptionHelpFormatter` classes.\n\n    This produces the following resulting actions:\n    - adds a \"(default: xyz)\" for each argument with a default\n    - uses the name of the argument type as the metavar. For example, gives\n      \"-n int\" instead of \"-n N\" in the usage and description of the arguments.\n    - Conserves the formatting of the class and argument docstrings, if given.\n    \"\"\"\n\n    def _get_default_metavar_for_optional(self, action: argparse.Action):\n        try:\n            return super()._get_default_metavar_for_optional(action)\n        except BaseException:\n            metavar = self._get_metavar_for_action(action)\n            return metavar\n\n    def _get_default_metavar_for_positional(self, action: argparse.Action):\n        try:\n            return super()._get_default_metavar_for_positional(action)\n        except BaseException:\n            metavar = self._get_metavar_for_action(action)\n            return metavar\n\n    def _get_metavar_for_action(self, action: argparse.Action) -> str:\n        return self._get_metavar_for_type(action.type)  # type: ignore\n\n    def _get_metavar_for_type(self, t: Type) -> str:\n        return get_metavar(t) or str(t)\n\n    def _get_help_string(self, action: Action) -> Optional[str]:\n        help = super()._get_help_string(action=action)\n        if help is not None:\n            help = help.replace(TEMPORARY_TOKEN, \"\")\n        return help",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "main": {
          "name": "main",
          "path": "bamboost.cli.main",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/cli/main.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "Argument": {
              "name": "Argument",
              "path": "bamboost.cli.main.Argument",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "()"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "{}"
                }
              ],
              "attributes": [
                {
                  "name": "args",
                  "annotation": null,
                  "description": null,
                  "value": "args"
                },
                {
                  "name": "kwargs",
                  "annotation": null,
                  "description": null,
                  "value": "kwargs"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli.main.Argument.__init__",
                  "signature": "(self, *args, **kwargs)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "args",
                      "annotation": null,
                      "description": null,
                      "value": "()"
                    },
                    {
                      "name": "kwargs",
                      "annotation": null,
                      "description": null,
                      "value": "{}"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, *args, **kwargs):\n    self.args = args\n    self.kwargs = kwargs"
                },
                "__call__": {
                  "name": "__call__",
                  "path": "bamboost.cli.main.Argument.__call__",
                  "signature": "(self, parser)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parser",
                      "annotation": "argparse.ArgumentParser",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __call__(self, parser: argparse.ArgumentParser):\n    parser.add_argument(*self.args, **self.kwargs)"
                }
              },
              "source": "class Argument:\n    def __init__(self, *args, **kwargs):\n        self.args = args\n        self.kwargs = kwargs\n\n    def __call__(self, parser: argparse.ArgumentParser):\n        parser.add_argument(*self.args, **self.kwargs)",
              "inherited_members": {}
            },
            "Cli": {
              "name": "Cli",
              "path": "bamboost.cli.main.Cli",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "parser",
                  "annotation": "Optional",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "parser",
                  "annotation": "argparse.ArgumentParser",
                  "description": null,
                  "value": "parser or argparse.ArgumentParser(description=self.__doc__)"
                },
                {
                  "name": "subcli",
                  "annotation": "List",
                  "description": null,
                  "value": null
                },
                {
                  "name": "aliases",
                  "annotation": "List",
                  "description": null,
                  "value": null
                },
                {
                  "name": "execute",
                  "annotation": "Callable",
                  "description": null,
                  "value": null
                },
                {
                  "name": "__subclis",
                  "annotation": "dict",
                  "description": null,
                  "value": "{}"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli.main.Cli.__init__",
                  "signature": "(self, parser=None)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parser",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self, parser: Optional[argparse.ArgumentParser] = None):\n    self.parser = parser or argparse.ArgumentParser(description=self.__doc__)\n    self.__subclis: dict[str, Cli] = {}\n\n    # add the options\n    for attr, value in self.__class__.__dict__.items():\n        if isinstance(value, Argument):\n            value(self.parser)\n\n    # add subparsers\n    if hasattr(self, \"subcli\"):\n        subparsers = self.parser.add_subparsers(dest=\"subcli\")\n        for cli in self.subcli:\n            subparser = subparsers.add_parser(\n                cli.__name__.lower(),\n                help=cli.__doc__,\n                description=cli.__doc__,\n                aliases=cli.aliases,\n            )\n            # init the subparser\n            self.__subclis[cli.__name__.lower()] = cli(subparser)"
                },
                "parse": {
                  "name": "parse",
                  "path": "bamboost.cli.main.Cli.parse",
                  "signature": "(self) -> Cli",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.cli.main.Cli",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def parse(self) -> Cli:\n    args = self.parser.parse_args()\n\n    def get_final_subcli(cli: Cli, args) -> Cli:\n        if hasattr(cli, \"subcli\") and args.subcli:\n            for i in cli.subcli:\n                if args.subcli == i.__name__.lower():\n                    subcli_selected = cli.__subclis[args.subcli]\n                    for attr, value in args.__dict__.items():\n                        if attr == 'subcli':\n                            continue\n                        setattr(subcli_selected, attr, value)\n                    return get_final_subcli(subcli_selected, args)\n        return cli\n\n    return get_final_subcli(self, args)"
                }
              },
              "source": "class Cli:\n    parser: argparse.ArgumentParser\n    subcli: List[Type[Cli]]\n    aliases: List[str]\n    execute: Callable[[], None]\n\n    def __init__(self, parser: Optional[argparse.ArgumentParser] = None):\n        self.parser = parser or argparse.ArgumentParser(description=self.__doc__)\n        self.__subclis: dict[str, Cli] = {}\n\n        # add the options\n        for attr, value in self.__class__.__dict__.items():\n            if isinstance(value, Argument):\n                value(self.parser)\n\n        # add subparsers\n        if hasattr(self, \"subcli\"):\n            subparsers = self.parser.add_subparsers(dest=\"subcli\")\n            for cli in self.subcli:\n                subparser = subparsers.add_parser(\n                    cli.__name__.lower(),\n                    help=cli.__doc__,\n                    description=cli.__doc__,\n                    aliases=cli.aliases,\n                )\n                # init the subparser\n                self.__subclis[cli.__name__.lower()] = cli(subparser)\n\n    def parse(self) -> Cli:\n        args = self.parser.parse_args()\n\n        def get_final_subcli(cli: Cli, args) -> Cli:\n            if hasattr(cli, \"subcli\") and args.subcli:\n                for i in cli.subcli:\n                    if args.subcli == i.__name__.lower():\n                        subcli_selected = cli.__subclis[args.subcli]\n                        for attr, value in args.__dict__.items():\n                            if attr == 'subcli':\n                                continue\n                            setattr(subcli_selected, attr, value)\n                        return get_final_subcli(subcli_selected, args)\n            return cli\n\n        return get_final_subcli(self, args)",
              "inherited_members": {}
            },
            "CliParsed": {
              "name": "CliParsed",
              "path": "bamboost.cli.main.CliParsed",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "subcli",
                  "annotation": "Type",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class CliParsed:\n    subcli: Type[Cli]",
              "inherited_members": {}
            },
            "Submit": {
              "name": "Submit",
              "path": "bamboost.cli.main.Submit",
              "description": "Run jobs or submit jobs on a cluster using slurm.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "parser",
                  "annotation": "Optional",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "aliases",
                  "annotation": null,
                  "description": null,
                  "value": "[]"
                },
                {
                  "name": "path",
                  "annotation": null,
                  "description": null,
                  "value": "Argument('path', nargs='?', type=str, help='Path to the directory containing the simulation.')"
                },
                {
                  "name": "id",
                  "annotation": null,
                  "description": null,
                  "value": "Argument('--id', default=None, type=str, help='The id of the simulation.')"
                },
                {
                  "name": "db",
                  "annotation": null,
                  "description": null,
                  "value": "Argument('--db', default=None, type=str, help='The ID of the collection containing the simulation.')"
                },
                {
                  "name": "all",
                  "annotation": null,
                  "description": null,
                  "value": "Argument('--all', action='store_true', help='Submit all unsubmitted jobs in the Collection.')"
                }
              ],
              "docstring": [],
              "functions": {
                "execute": {
                  "name": "execute",
                  "path": "bamboost.cli.main.Submit.execute",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute(self):\n    print(\"Submit\")"
                }
              },
              "source": "class Submit(Cli):\n    \"\"\"Run jobs or submit jobs on a cluster using slurm.\"\"\"\n\n    aliases = []\n    # fmt: off\n    path = Argument(\"path\", nargs=\"?\", type=str, help=\"Path to the directory containing the simulation.\")\n    id = Argument(\"--id\", default=None, type=str, help=\"The id of the simulation.\")\n    db = Argument(\"--db\", default=None, type=str, help=\"The ID of the collection containing the simulation.\")\n    all = Argument(\"--all\", action=\"store_true\", help=\"Submit all unsubmitted jobs in the Collection.\")\n\n    # fmt: on\n    def execute(self):\n        print(\"Submit\")",
              "inherited_members": {
                "bamboost.cli.main.Cli": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.parser"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.subcli"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.cli.main.Cli.__init__"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.__subclis"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.cli.main.Cli.parse"
                  }
                ]
              }
            },
            "Collection": {
              "name": "Collection",
              "path": "bamboost.cli.main.Collection",
              "description": "Collection management commands.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "parser",
                  "annotation": "Optional",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "aliases",
                  "annotation": null,
                  "description": null,
                  "value": "['coll']"
                }
              ],
              "docstring": [],
              "functions": {
                "execute": {
                  "name": "execute",
                  "path": "bamboost.cli.main.Collection.execute",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute(self):\n    print(\"Db\")"
                }
              },
              "source": "class Collection(Cli):\n    \"\"\"Collection management commands.\"\"\"\n\n    aliases = [\"coll\"]\n\n    def execute(self):\n        print(\"Db\")",
              "inherited_members": {
                "bamboost.cli.main.Cli": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.parser"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.subcli"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.cli.main.Cli.__init__"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.__subclis"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.cli.main.Cli.parse"
                  }
                ]
              }
            },
            "MainCli": {
              "name": "MainCli",
              "path": "bamboost.cli.main.MainCli",
              "description": "The command line interface for bamboost.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "parser",
                  "annotation": "Optional",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "subcli",
                  "annotation": null,
                  "description": [
                    {
                      "kind": "text",
                      "value": "The subcommands of the main CLI."
                    }
                  ],
                  "value": "[Submit, Collection]"
                },
                {
                  "name": "remote",
                  "annotation": null,
                  "description": null,
                  "value": "Argument('-r', '--remote', help='Remote ssh database to fetch data from.', type=str)"
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class MainCli(Cli):\n    \"\"\"The command line interface for bamboost.\"\"\"\n\n    subcli = [Submit, Collection]\n    \"\"\"The subcommands of the main CLI.\"\"\"\n\n    remote = Argument(\n        \"-r\", \"--remote\", help=\"Remote ssh database to fetch data from.\", type=str\n    )",
              "inherited_members": {
                "bamboost.cli.main.Cli": [
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.parser"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.aliases"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.execute"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.cli.main.Cli.__init__"
                  },
                  {
                    "kind": "attribute",
                    "path": "bamboost.cli.main.Cli.__subclis"
                  },
                  {
                    "kind": "function",
                    "path": "bamboost.cli.main.Cli.parse"
                  }
                ]
              }
            }
          },
          "functions": {
            "main": {
              "name": "main",
              "path": "bamboost.cli.main.main",
              "signature": "()",
              "description": null,
              "parameters": [],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def main():\n    cli = MainCli()\n    a = cli.parse()\n    print(a)\n    print(a.__dict__)"
            }
          }
        },
        "_index": {
          "name": "_index",
          "path": "bamboost.cli._index",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/cli/_index.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "indexAPI",
              "annotation": null,
              "description": [
                {
                  "kind": "text",
                  "value": "A fast API relying not using sqlalchemy for simple queries."
                }
              ],
              "value": "FastIndexQuery(config.index.databaseFile)"
            },
            {
              "name": "console",
              "annotation": null,
              "description": null,
              "value": "Console()"
            }
          ],
          "modules": {},
          "classes": {
            "Show": {
              "name": "Show",
              "path": "bamboost.cli._index.Show",
              "description": "Show the index.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "execute": {
                  "name": "execute",
                  "path": "bamboost.cli._index.Show.execute",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute(self):\n    import rich\n    from rich.table import Column, Table\n\n    tab = Table(\n        \"\",\n        \"UID\",\n        Column(\"Path\", style=\"blue\"),\n        title_justify=\"left\",\n        highlight=True,\n        pad_edge=False,\n        box=None,\n    )\n\n    for i, coll in enumerate(indexAPI.query(\"SELECT * FROM collections\")):\n        tab.add_row(str(i), *coll)\n\n    rich.print(tab)"
                },
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli._index.Show.__init__",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": ""
                }
              },
              "source": "@dataclass\nclass Show:\n    \"\"\"Show the index.\"\"\"\n\n    def execute(self):\n        import rich\n        from rich.table import Column, Table\n\n        tab = Table(\n            \"\",\n            \"UID\",\n            Column(\"Path\", style=\"blue\"),\n            title_justify=\"left\",\n            highlight=True,\n            pad_edge=False,\n            box=None,\n        )\n\n        for i, coll in enumerate(indexAPI.query(\"SELECT * FROM collections\")):\n            tab.add_row(str(i), *coll)\n\n        rich.print(tab)",
              "inherited_members": {}
            },
            "Clean": {
              "name": "Clean",
              "path": "bamboost.cli._index.Clean",
              "description": "Clean the index.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "execute": {
                  "name": "execute",
                  "path": "bamboost.cli._index.Clean.execute",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute(self):\n    with console.status(\"[bold blue]Cleaning index...\", spinner=\"dots\") as status:\n        try:\n            from bamboost.index import DEFAULT_INDEX\n\n            DEFAULT_INDEX.check_integrity()\n            console.print(\"[green]:heavy_check_mark: Index cleaned.\")\n        except Exception as e:\n            console.print(f\"[bold red]Task failed: {e}\")"
                },
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli._index.Clean.__init__",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": ""
                }
              },
              "source": "@dataclass\nclass Clean:\n    \"\"\"Clean the index.\"\"\"\n\n    def execute(self):\n        with console.status(\"[bold blue]Cleaning index...\", spinner=\"dots\") as status:\n            try:\n                from bamboost.index import DEFAULT_INDEX\n\n                DEFAULT_INDEX.check_integrity()\n                console.print(\"[green]:heavy_check_mark: Index cleaned.\")\n            except Exception as e:\n                console.print(f\"[bold red]Task failed: {e}\")",
              "inherited_members": {}
            },
            "Scan": {
              "name": "Scan",
              "path": "bamboost.cli._index.Scan",
              "description": "Scan the search paths for collections.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [],
              "docstring": [],
              "functions": {
                "execute": {
                  "name": "execute",
                  "path": "bamboost.cli._index.Scan.execute",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute(self):\n    with console.status(\n        \"[bold blue]Scanning search paths...\", spinner=\"dots\"\n    ) as status:\n        try:\n            from rich.table import Column, Table\n\n            from bamboost.index import DEFAULT_INDEX\n\n            found_colls = DEFAULT_INDEX.scan_for_collections()\n            console.print(\"[green]:heavy_check_mark: Index scanned.\")\n            tab = Table(\n                \"uid\",\n                Column(\"path\", style=\"blue\"),\n                title=\"Found the following collections:\",\n                box=None,\n                show_header=False,\n                pad_edge=False,\n                title_justify=\"left\",\n            )\n            for coll in found_colls:\n                tab.add_row(\n                    coll[0], f\"[link={coll[1].as_uri()}]{coll[1].as_posix()}[/link]\"\n                )\n            console.print(tab)\n        except Exception as e:\n            console.print(f\"[bold red]Task failed: {e}\")"
                },
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli._index.Scan.__init__",
                  "signature": "(self) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": ""
                }
              },
              "source": "@dataclass\nclass Scan:\n    \"\"\"Scan the search paths for collections.\"\"\"\n\n    def execute(self):\n        with console.status(\n            \"[bold blue]Scanning search paths...\", spinner=\"dots\"\n        ) as status:\n            try:\n                from rich.table import Column, Table\n\n                from bamboost.index import DEFAULT_INDEX\n\n                found_colls = DEFAULT_INDEX.scan_for_collections()\n                console.print(\"[green]:heavy_check_mark: Index scanned.\")\n                tab = Table(\n                    \"uid\",\n                    Column(\"path\", style=\"blue\"),\n                    title=\"Found the following collections:\",\n                    box=None,\n                    show_header=False,\n                    pad_edge=False,\n                    title_justify=\"left\",\n                )\n                for coll in found_colls:\n                    tab.add_row(\n                        coll[0], f\"[link={coll[1].as_uri()}]{coll[1].as_posix()}[/link]\"\n                    )\n                console.print(tab)\n            except Exception as e:\n                console.print(f\"[bold red]Task failed: {e}\")",
              "inherited_members": {}
            },
            "Index": {
              "name": "Index",
              "path": "bamboost.cli._index.Index",
              "description": "API for displaying and managing the collection index.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "command",
                  "annotation": "Union",
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "command",
                  "annotation": "Union",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "chose-one-of-the-following-commands",
                    "description": "- show: Display the index.\n- clean: Clean the index from invalid collections.\n- scan: Scan the search paths for collections."
                  },
                  "title": "Chose one of the following commands"
                }
              ],
              "functions": {
                "execute": {
                  "name": "execute",
                  "path": "bamboost.cli._index.Index.execute",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def execute(self):\n    self.command.execute()"
                },
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.cli._index.Index.__init__",
                  "signature": "(self, command) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "command",
                      "annotation": "Union",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": ""
                }
              },
              "source": "@dataclass\nclass Index:\n    \"\"\"API for displaying and managing the collection index.\n\n    Chose one of the following commands:\n        - show: Display the index.\n        - clean: Clean the index from invalid collections.\n        - scan: Scan the search paths for collections.\n    \"\"\"\n\n    command: Union[Show, Clean, Scan]\n\n    def execute(self):\n        self.command.execute()",
              "inherited_members": {}
            }
          },
          "functions": {}
        }
      },
      "classes": {
        "CliHandler": {
          "name": "CliHandler",
          "path": "bamboost.cli.CliHandler",
          "description": null,
          "parameters": [],
          "attributes": [],
          "docstring": [],
          "functions": {
            "emit": {
              "name": "emit",
              "path": "bamboost.cli.CliHandler.emit",
              "signature": "(self, record)",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "record",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": null,
                "description": null
              },
              "docstring": [],
              "source": "def emit(self, record):\n    print(record.getMessage())"
            }
          },
          "source": "class CliHandler(logging.Handler):\n    def emit(self, record):\n        print(record.getMessage())",
          "inherited_members": {}
        }
      },
      "functions": {}
    },
    "mpi": {
      "name": "mpi",
      "path": "bamboost.mpi",
      "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/mpi/__init__.py",
      "description": null,
      "docstring": [],
      "attributes": [
        {
          "name": "Comm",
          "annotation": "TypeAlias",
          "description": null,
          "value": "Union"
        },
        {
          "name": "log",
          "annotation": null,
          "description": null,
          "value": "BAMBOOST_LOGGER.getChild(__name__.split('.')[-1])"
        },
        {
          "name": "MPI_ON",
          "annotation": null,
          "description": null,
          "value": "_detect_if_mpi_needed()"
        },
        {
          "name": "MPI",
          "annotation": null,
          "description": null,
          "value": "_get_mpi_module()"
        }
      ],
      "modules": {
        "mock": {
          "name": "mock",
          "path": "bamboost.mpi.mock",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/mpi/mock.py",
          "description": "Mock module for `mpi4py.MPI` to be used when MPI is not available or usage\nnot desired. Not importing MPI increases launch speed significantly, which\nis important for CLI applications.",
          "docstring": [],
          "attributes": [
            {
              "name": "COMM_WORLD",
              "description": [
                {
                  "kind": "text",
                  "value": "Mock object for `mpi4py.MPI.COMM_WORLD`"
                }
              ],
              "annotation": "Comm",
              "value": "Comm()"
            },
            {
              "name": "COMM_SELF",
              "description": [
                {
                  "kind": "text",
                  "value": "Mock object for `mpi4py.MPI.COMM_SELF`"
                }
              ],
              "annotation": "Comm",
              "value": "COMM_WORLD"
            },
            {
              "name": "COMM_NULL",
              "description": [
                {
                  "kind": "text",
                  "value": "Mock object for `mpi4py.MPI.COMM_NULL`"
                }
              ],
              "annotation": "Comm",
              "value": "COMM_WORLD"
            }
          ],
          "modules": {},
          "classes": {
            "Comm": {
              "name": "Comm",
              "path": "bamboost.mpi.mock.Comm",
              "description": null,
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                }
              ],
              "attributes": [
                {
                  "name": "size",
                  "annotation": null,
                  "description": null,
                  "value": "1"
                },
                {
                  "name": "rank",
                  "annotation": null,
                  "description": null,
                  "value": "0"
                },
                {
                  "name": "comm",
                  "annotation": null,
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "is_mpi",
                  "annotation": null,
                  "description": null,
                  "value": "False"
                },
                {
                  "name": "is_master",
                  "annotation": null,
                  "description": null,
                  "value": "True"
                }
              ],
              "docstring": [],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.mpi.mock.Comm.__init__",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(self):\n    self.size = 1\n    self.rank = 0\n    self.comm = None\n    self.is_mpi = False\n    self.is_master = True"
                },
                "barrier": {
                  "name": "barrier",
                  "path": "bamboost.mpi.mock.Comm.barrier",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def barrier(self):\n    pass"
                },
                "finalize": {
                  "name": "finalize",
                  "path": "bamboost.mpi.mock.Comm.finalize",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def finalize(self):\n    pass"
                },
                "bcast": {
                  "name": "bcast",
                  "path": "bamboost.mpi.mock.Comm.bcast",
                  "signature": "(self, data, root=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def bcast(self, data, root=0):\n    return data"
                },
                "scatter": {
                  "name": "scatter",
                  "path": "bamboost.mpi.mock.Comm.scatter",
                  "signature": "(self, data, root=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def scatter(self, data, root=0):\n    return data"
                },
                "gather": {
                  "name": "gather",
                  "path": "bamboost.mpi.mock.Comm.gather",
                  "signature": "(self, data, root=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def gather(self, data, root=0):\n    return data"
                },
                "allgather": {
                  "name": "allgather",
                  "path": "bamboost.mpi.mock.Comm.allgather",
                  "signature": "(self, data)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def allgather(self, data):\n    return [data]"
                },
                "allreduce": {
                  "name": "allreduce",
                  "path": "bamboost.mpi.mock.Comm.allreduce",
                  "signature": "(self, data, op)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "op",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def allreduce(self, data, op):\n    return data"
                },
                "reduce": {
                  "name": "reduce",
                  "path": "bamboost.mpi.mock.Comm.reduce",
                  "signature": "(self, data, op, root=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "op",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "root",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def reduce(self, data, op, root=0):\n    return data"
                },
                "send": {
                  "name": "send",
                  "path": "bamboost.mpi.mock.Comm.send",
                  "signature": "(self, data, dest, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dest",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def send(self, data, dest, tag=0):\n    pass"
                },
                "recv": {
                  "name": "recv",
                  "path": "bamboost.mpi.mock.Comm.recv",
                  "signature": "(self, source, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "source",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def recv(self, source, tag=0):\n    return None"
                },
                "recv_any_source": {
                  "name": "recv_any_source",
                  "path": "bamboost.mpi.mock.Comm.recv_any_source",
                  "signature": "(self, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def recv_any_source(self, tag=0):\n    return None"
                },
                "sendrecv": {
                  "name": "sendrecv",
                  "path": "bamboost.mpi.mock.Comm.sendrecv",
                  "signature": "(self, send_data, dest, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "send_data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dest",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def sendrecv(self, send_data, dest, tag=0):\n    return None"
                },
                "sendrecv_replace": {
                  "name": "sendrecv_replace",
                  "path": "bamboost.mpi.mock.Comm.sendrecv_replace",
                  "signature": "(self, data, dest, tag=0)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "dest",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "tag",
                      "annotation": null,
                      "description": null,
                      "value": "0"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def sendrecv_replace(self, data, dest, tag=0):\n    return data"
                },
                "get_processor_name": {
                  "name": "get_processor_name",
                  "path": "bamboost.mpi.mock.Comm.get_processor_name",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_processor_name(self):\n    return \"localhost\""
                },
                "get_version": {
                  "name": "get_version",
                  "path": "bamboost.mpi.mock.Comm.get_version",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_version(self):\n    return \"0.0.0\""
                },
                "get_library_version": {
                  "name": "get_library_version",
                  "path": "bamboost.mpi.mock.Comm.get_library_version",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_library_version(self):\n    return \"0.0.0\""
                },
                "get_error_string": {
                  "name": "get_error_string",
                  "path": "bamboost.mpi.mock.Comm.get_error_string",
                  "signature": "(self, errorcode)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "errorcode",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_error_string(self, errorcode):\n    return \"No error\""
                },
                "get_exception_class": {
                  "name": "get_exception_class",
                  "path": "bamboost.mpi.mock.Comm.get_exception_class",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_exception_class(self):\n    return Exception"
                },
                "get_exception_string": {
                  "name": "get_exception_string",
                  "path": "bamboost.mpi.mock.Comm.get_exception_string",
                  "signature": "(self, errorcode)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "errorcode",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_exception_string(self, errorcode):\n    return \"No error\""
                },
                "get_count": {
                  "name": "get_count",
                  "path": "bamboost.mpi.mock.Comm.get_count",
                  "signature": "(self, status, datatype)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "datatype",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_count(self, status, datatype):\n    return 0"
                },
                "get_status": {
                  "name": "get_status",
                  "path": "bamboost.mpi.mock.Comm.get_status",
                  "signature": "(self, request)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "request",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_status(self, request):\n    return None"
                },
                "get_source": {
                  "name": "get_source",
                  "path": "bamboost.mpi.mock.Comm.get_source",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_source(self, status):\n    return 0"
                },
                "get_tag": {
                  "name": "get_tag",
                  "path": "bamboost.mpi.mock.Comm.get_tag",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_tag(self, status):\n    return 0"
                },
                "get_elements": {
                  "name": "get_elements",
                  "path": "bamboost.mpi.mock.Comm.get_elements",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_elements(self, status):\n    return 0"
                },
                "get_bytes": {
                  "name": "get_bytes",
                  "path": "bamboost.mpi.mock.Comm.get_bytes",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_bytes(self, status):\n    return 0"
                },
                "get_cancelled": {
                  "name": "get_cancelled",
                  "path": "bamboost.mpi.mock.Comm.get_cancelled",
                  "signature": "(self, status)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "status",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_cancelled(self, status):\n    return False"
                },
                "get_topo": {
                  "name": "get_topo",
                  "path": "bamboost.mpi.mock.Comm.get_topo",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_topo(self):\n    return None"
                },
                "get_cart": {
                  "name": "get_cart",
                  "path": "bamboost.mpi.mock.Comm.get_cart",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_cart(self):\n    return None"
                },
                "get_dims": {
                  "name": "get_dims",
                  "path": "bamboost.mpi.mock.Comm.get_dims",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_dims(self):\n    return None"
                },
                "get_coords": {
                  "name": "get_coords",
                  "path": "bamboost.mpi.mock.Comm.get_coords",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_coords(self):\n    return None"
                },
                "get_rank": {
                  "name": "get_rank",
                  "path": "bamboost.mpi.mock.Comm.get_rank",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_rank(self):\n    return 0"
                },
                "get_size": {
                  "name": "get_size",
                  "path": "bamboost.mpi.mock.Comm.get_size",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_size(self):\n    return 1"
                },
                "Get_size": {
                  "name": "Get_size",
                  "path": "bamboost.mpi.mock.Comm.Get_size",
                  "signature": "(self)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def Get_size(self):\n    return 1"
                }
              },
              "source": "class Comm:\n    def __init__(self):\n        self.size = 1\n        self.rank = 0\n        self.comm = None\n        self.is_mpi = False\n        self.is_master = True\n\n    def barrier(self):\n        pass\n\n    def finalize(self):\n        pass\n\n    def bcast(self, data, root=0):\n        return data\n\n    def scatter(self, data, root=0):\n        return data\n\n    def gather(self, data, root=0):\n        return data\n\n    def allgather(self, data):\n        return [data]\n\n    def allreduce(self, data, op):\n        return data\n\n    def reduce(self, data, op, root=0):\n        return data\n\n    def send(self, data, dest, tag=0):\n        pass\n\n    def recv(self, source, tag=0):\n        return None\n\n    def recv_any_source(self, tag=0):\n        return None\n\n    def sendrecv(self, send_data, dest, tag=0):\n        return None\n\n    def sendrecv_replace(self, data, dest, tag=0):\n        return data\n\n    def get_processor_name(self):\n        return \"localhost\"\n\n    def get_version(self):\n        return \"0.0.0\"\n\n    def get_library_version(self):\n        return \"0.0.0\"\n\n    def get_error_string(self, errorcode):\n        return \"No error\"\n\n    def get_exception_class(self):\n        return Exception\n\n    def get_exception_string(self, errorcode):\n        return \"No error\"\n\n    def get_count(self, status, datatype):\n        return 0\n\n    def get_status(self, request):\n        return None\n\n    def get_source(self, status):\n        return 0\n\n    def get_tag(self, status):\n        return 0\n\n    def get_elements(self, status):\n        return 0\n\n    def get_bytes(self, status):\n        return 0\n\n    def get_cancelled(self, status):\n        return False\n\n    def get_topo(self):\n        return None\n\n    def get_cart(self):\n        return None\n\n    def get_dims(self):\n        return None\n\n    def get_coords(self):\n        return None\n\n    def get_rank(self):\n        return 0\n\n    def get_size(self):\n        return 1\n\n    def Get_size(self):\n        return 1",
              "inherited_members": {}
            }
          },
          "functions": {}
        },
        "utilities": {
          "name": "utilities",
          "path": "bamboost.mpi.utilities",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/mpi/utilities.py",
          "description": null,
          "docstring": [],
          "attributes": [],
          "modules": {},
          "classes": {
            "HasComm": {
              "name": "HasComm",
              "path": "bamboost.mpi.utilities.HasComm",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "_comm",
                  "annotation": "Comm",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {},
              "source": "class HasComm(Protocol):\n    _comm: \"Comm\"",
              "inherited_members": {}
            },
            "RootProcessMeta": {
              "name": "RootProcessMeta",
              "path": "bamboost.mpi.utilities.RootProcessMeta",
              "description": "A metaclass that makes classes MPI-safe by ensuring methods are only\nexecuted on the root process.\n\nThis metaclass modifies class methods to either use broadcast communication\n(if decorated with @bcast) or to only execute on the root process (rank 0).",
              "parameters": [],
              "attributes": [
                {
                  "name": "__exclude__",
                  "annotation": null,
                  "description": null,
                  "value": "{'__init__', '__new__'}"
                }
              ],
              "docstring": [],
              "functions": {
                "__new__": {
                  "name": "__new__",
                  "path": "bamboost.mpi.utilities.RootProcessMeta.__new__",
                  "signature": "(mcs, name, bases, attrs)",
                  "description": "Create a new class with MPI-safe methods.",
                  "parameters": [
                    {
                      "name": "mcs",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The name of the class being created."
                        }
                      ]
                    },
                    {
                      "name": "bases",
                      "annotation": "tuple",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The base classes of the class being created."
                        }
                      ]
                    },
                    {
                      "name": "attrs",
                      "annotation": "dict",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The attributes of the class being created."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "type",
                    "annotation": null,
                    "description": "The new class with MPI-safe methods."
                  },
                  "docstring": [],
                  "source": "def __new__(mcs, name: str, bases: tuple, attrs: dict):\n    \"\"\"Create a new class with MPI-safe methods.\n\n    Args:\n        name: The name of the class being created.\n        bases: The base classes of the class being created.\n        attrs: The attributes of the class being created.\n\n    Returns:\n        type: The new class with MPI-safe methods.\n    \"\"\"\n    for attr_name, attr_value in attrs.items():\n        if (\n            callable(attr_value)\n            # and not attr_name.startswith(\"__\")\n            and attr_name not in mcs.__exclude__\n        ):\n            if hasattr(\n                attr_value, \"_mpi_bcast_\"\n            ):  # check for @cast_result decorator\n                continue\n            elif hasattr(\n                attr_value, \"_mpi_on_all_\"\n            ):  # check for @exclude decorator\n                continue\n            else:\n                attrs[attr_name] = mcs._root_only_default(attr_value)\n    return super().__new__(mcs, name, bases, attrs)"
                },
                "_root_only_default": {
                  "name": "_root_only_default",
                  "path": "bamboost.mpi.utilities.RootProcessMeta._root_only_default",
                  "signature": "(func)",
                  "description": "Decorator that ensures a method is only executed on the root process\n(rank 0).",
                  "parameters": [
                    {
                      "name": "func",
                      "annotation": "callable",
                      "description": [
                        {
                          "kind": "text",
                          "value": "The method to be decorated."
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "callable",
                    "annotation": null,
                    "description": "The wrapped method that only executes on the root process."
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef _root_only_default(func):\n    \"\"\"Decorator that ensures a method is only executed on the root process\n    (rank 0).\n\n    Args:\n        func (callable): The method to be decorated.\n\n    Returns:\n        callable: The wrapped method that only executes on the root process.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(self: HasComm, *args, **kwargs):\n        if self._comm.rank == 0:\n            return func(self, *args, **kwargs)\n\n    return wrapper"
                },
                "bcast_result": {
                  "name": "bcast_result",
                  "path": "bamboost.mpi.utilities.RootProcessMeta.bcast_result",
                  "signature": "(func)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "func",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef bcast_result(func):\n    @wraps(func)\n    def wrapper(self: HasComm, *args, **kwargs):\n        result = None\n        if self._comm.rank == 0:\n            result = func(self, *args, **kwargs)\n        return self._comm.bcast(result, root=0)\n\n    wrapper._mpi_bcast_ = True  # type: ignore\n    return wrapper"
                },
                "exclude": {
                  "name": "exclude",
                  "path": "bamboost.mpi.utilities.RootProcessMeta.exclude",
                  "signature": "(func)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "func",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef exclude(func):\n    func._mpi_on_all_ = True\n    return func"
                }
              },
              "source": "class RootProcessMeta(type):\n    \"\"\"A metaclass that makes classes MPI-safe by ensuring methods are only\n    executed on the root process.\n\n    This metaclass modifies class methods to either use broadcast communication\n    (if decorated with @bcast) or to only execute on the root process (rank 0).\n    \"\"\"\n\n    __exclude__ = {\"__init__\", \"__new__\"}\n\n    def __new__(mcs, name: str, bases: tuple, attrs: dict):\n        \"\"\"Create a new class with MPI-safe methods.\n\n        Args:\n            name: The name of the class being created.\n            bases: The base classes of the class being created.\n            attrs: The attributes of the class being created.\n\n        Returns:\n            type: The new class with MPI-safe methods.\n        \"\"\"\n        for attr_name, attr_value in attrs.items():\n            if (\n                callable(attr_value)\n                # and not attr_name.startswith(\"__\")\n                and attr_name not in mcs.__exclude__\n            ):\n                if hasattr(\n                    attr_value, \"_mpi_bcast_\"\n                ):  # check for @cast_result decorator\n                    continue\n                elif hasattr(\n                    attr_value, \"_mpi_on_all_\"\n                ):  # check for @exclude decorator\n                    continue\n                else:\n                    attrs[attr_name] = mcs._root_only_default(attr_value)\n        return super().__new__(mcs, name, bases, attrs)\n\n    @staticmethod\n    def _root_only_default(func):\n        \"\"\"Decorator that ensures a method is only executed on the root process\n        (rank 0).\n\n        Args:\n            func (callable): The method to be decorated.\n\n        Returns:\n            callable: The wrapped method that only executes on the root process.\n        \"\"\"\n\n        @wraps(func)\n        def wrapper(self: HasComm, *args, **kwargs):\n            if self._comm.rank == 0:\n                return func(self, *args, **kwargs)\n\n        return wrapper\n\n    @staticmethod\n    def bcast_result(func):\n        @wraps(func)\n        def wrapper(self: HasComm, *args, **kwargs):\n            result = None\n            if self._comm.rank == 0:\n                result = func(self, *args, **kwargs)\n            return self._comm.bcast(result, root=0)\n\n        wrapper._mpi_bcast_ = True  # type: ignore\n        return wrapper\n\n    @staticmethod\n    def exclude(func):\n        func._mpi_on_all_ = True\n        return func",
              "inherited_members": {}
            }
          },
          "functions": {
            "on_rank": {
              "name": "on_rank",
              "path": "bamboost.mpi.utilities.on_rank",
              "signature": "(func, comm, rank) -> Callable[_P, _T]",
              "description": "Decorator to run a function on a specific rank and broadcast the result.",
              "parameters": [
                {
                  "name": "func",
                  "annotation": "Callable",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function to decorate."
                    }
                  ]
                },
                {
                  "name": "comm",
                  "annotation": "Comm",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The MPI communicator."
                    }
                  ]
                },
                {
                  "name": "rank",
                  "annotation": "int",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The rank to run the function on."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Callable[bamboost._typing._P, bamboost._typing._T]",
                "description": null
              },
              "docstring": [],
              "source": "def on_rank(func: Callable[_P, _T], comm: \"Comm\", rank: int) -> Callable[_P, _T]:\n    \"\"\"Decorator to run a function on a specific rank and broadcast the result.\n\n    Args:\n        func: The function to decorate.\n        comm: The MPI communicator.\n        rank: The rank to run the function on.\n    \"\"\"\n\n    @wraps(func)\n    def inner(*args, **kwargs) -> _T:\n        result = None\n        if comm.rank == rank:\n            result = func(*args, **kwargs)\n        return cast(_T, comm.bcast(result, root=rank))\n\n    return inner"
            },
            "on_root": {
              "name": "on_root",
              "path": "bamboost.mpi.utilities.on_root",
              "signature": "(func, comm) -> Callable[_P, _T]",
              "description": "Decorator to run a function on the root rank and broadcast the result.",
              "parameters": [
                {
                  "name": "func",
                  "annotation": "Callable",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function to decorate."
                    }
                  ]
                },
                {
                  "name": "comm",
                  "annotation": "Comm",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The MPI communicator."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Callable[bamboost._typing._P, bamboost._typing._T]",
                "description": null
              },
              "docstring": [],
              "source": "def on_root(func: Callable[_P, _T], comm: \"Comm\") -> Callable[_P, _T]:\n    \"\"\"Decorator to run a function on the root rank and broadcast the result.\n\n    Args:\n        func: The function to decorate.\n        comm: The MPI communicator.\n    \"\"\"\n    return on_rank(func, comm, 0)"
            }
          }
        }
      },
      "classes": {},
      "functions": {
        "_detect_if_mpi_needed": {
          "name": "_detect_if_mpi_needed",
          "path": "bamboost.mpi._detect_if_mpi_needed",
          "signature": "() -> bool",
          "description": null,
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": "bool",
            "description": null
          },
          "docstring": [],
          "source": "def _detect_if_mpi_needed() -> bool:\n    if not config.options.mpi:  # user has disabled MPI via config\n        return False\n    if os.environ.get(\"BAMBOOST_MPI\", None) == \"0\":  # user has disabled MPI via env\n        return False\n\n    # Check if any of the common MPI environment variables are set\n    # fmt: off\n    mpi_env_vars = [\n        \"OMPI_COMM_WORLD_SIZE\", \"OMPI_COMM_WORLD_RANK\",        # Open MPI\n        \"PMI_SIZE\", \"PMI_RANK\",                                # MPICH and Intel MPI\n        \"MV2_COMM_WORLD_SIZE\", \"MV2_COMM_WORLD_RANK\",          # MVAPICH\n        \"I_MPI_RANK\", \"I_MPI_SIZE\",                            # Intel MPI\n        \"SLURM_PROCID\", \"SLURM_NTASKS\",                        # SLURM\n        \"MPI_LOCALNRANKS\", \"MPI_LOCALRANKID\"                   # General/Other\n    ]\n    # fmt: on\n    if any(var in os.environ for var in mpi_env_vars):\n        return True\n\n    log.info(\"This script does not seem to be run with MPI. Using the mock MPI module.\")\n    return False"
        },
        "_get_mpi_module": {
          "name": "_get_mpi_module",
          "path": "bamboost.mpi._get_mpi_module",
          "signature": "()",
          "description": null,
          "parameters": [],
          "returns": {
            "name": "",
            "annotation": null,
            "description": null
          },
          "docstring": [],
          "source": "def _get_mpi_module():\n    if not MPI_ON:\n        import bamboost.mpi.mock as MockMPI\n\n        return MockMPI\n\n    try:\n        import mpi4py.MPI as MPI\n\n        return MPI\n    except ImportError:\n        import bamboost.mpi.mock as MockMPI\n\n        log.info(\"`mpi4py` unavailable [using the mock MPI module]\")\n        return MockMPI"
        }
      }
    },
    "index": {
      "name": "index",
      "path": "bamboost.index",
      "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/index/__init__.py",
      "description": "Module for indexing BAMBOOST collections.\n\nUses a caching mechanism using SQLAlchemy and an SQLite database to store\ninformation about collections and simulations.",
      "docstring": [
        {
          "kind": "admonition",
          "value": {
            "annotation": "usage",
            "description": "Create an instance of the `Index` class and use its methods to interact\nwith the index.\n\n>>> from bamboost.index import Index\n>>> index = Index()\n\nScan for collections in known paths:\n\n>>> index.scan_for_collections()\n\nResolve the path of a collection:\n\n>>> index.resolve_path(<collection-uid>)\n\nGet a simulation from its collection and simulation name:\n\n>>> index.get_simulation(<collection-uid>, <simulation-name>)"
          },
          "title": "Usage"
        },
        {
          "kind": "classes",
          "value": [
            {
              "name": "Index",
              "annotation": null,
              "description": "API for indexing BAMBOOST collections and simulations."
            }
          ]
        }
      ],
      "attributes": [
        {
          "name": "DEFAULT_INDEX",
          "annotation": null,
          "description": null,
          "value": "Index()"
        }
      ],
      "modules": {
        "base": {
          "name": "base",
          "path": "bamboost.index.base",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/index/base.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "log",
              "annotation": null,
              "description": null,
              "value": "BAMBOOST_LOGGER.getChild('Database')"
            },
            {
              "name": "IDENTIFIER_PREFIX",
              "annotation": null,
              "description": null,
              "value": "'.bamboost-collection'"
            },
            {
              "name": "IDENTIFIER_SEPARATOR",
              "annotation": null,
              "description": null,
              "value": "'-'"
            }
          ],
          "modules": {},
          "classes": {
            "CollectionUID": {
              "name": "CollectionUID",
              "path": "bamboost.index.base.CollectionUID",
              "description": "UID of a collection.",
              "parameters": [],
              "attributes": [],
              "docstring": [],
              "functions": {
                "__new__": {
                  "name": "__new__",
                  "path": "bamboost.index.base.CollectionUID.__new__",
                  "signature": "(cls, uid=None, length=10)",
                  "description": null,
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "length",
                      "annotation": "int",
                      "description": null,
                      "value": "10"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": null,
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __new__(cls, uid: Optional[str] = None, length: int = 10):\n    uid = uid or cls.generate_uid(length)\n    return super().__new__(cls, uid.upper())"
                },
                "generate_uid": {
                  "name": "generate_uid",
                  "path": "bamboost.index.base.CollectionUID.generate_uid",
                  "signature": "(length) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "length",
                      "annotation": "int",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@staticmethod\ndef generate_uid(length: int) -> str:\n    return uuid.uuid4().hex[:length].upper()"
                }
              },
              "source": "class CollectionUID(str):\n    \"\"\"UID of a collection.\"\"\"\n\n    def __new__(cls, uid: Optional[str] = None, length: int = 10):\n        uid = uid or cls.generate_uid(length)\n        return super().__new__(cls, uid.upper())\n\n    @staticmethod\n    def generate_uid(length: int) -> str:\n        return uuid.uuid4().hex[:length].upper()",
              "inherited_members": {}
            },
            "Index": {
              "name": "Index",
              "path": "bamboost.index.base.Index",
              "description": "API for indexing BAMBOOST collections and simulations.",
              "parameters": [
                {
                  "name": "self",
                  "annotation": null,
                  "description": null,
                  "value": null
                },
                {
                  "name": "sql_file",
                  "annotation": "Optional",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "comm",
                  "annotation": "Optional",
                  "description": null,
                  "value": "None"
                },
                {
                  "name": "search_paths",
                  "annotation": "Optional",
                  "description": null,
                  "value": "None"
                }
              ],
              "attributes": [
                {
                  "name": "_comm",
                  "annotation": "Comm",
                  "description": null,
                  "value": "comm or MPI.COMM_WORLD"
                },
                {
                  "name": "_engine",
                  "annotation": "Engine",
                  "description": null,
                  "value": null
                },
                {
                  "name": "_sm",
                  "annotation": "Callable",
                  "description": null,
                  "value": null
                },
                {
                  "name": "_s",
                  "annotation": "Session",
                  "description": null,
                  "value": null
                },
                {
                  "name": "search_paths",
                  "annotation": "PathSet",
                  "description": null,
                  "value": "PathSet(search_paths or config.index.searchPaths)"
                },
                {
                  "name": "all_collections",
                  "annotation": "Sequence",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Return all collections in the index. Eagerly loads the simulations\nand its parameters."
                    }
                  ],
                  "value": null
                },
                {
                  "name": "all_simulations",
                  "annotation": "Sequence",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Return all simulations in the index. Eagerly loads the parameters."
                    }
                  ],
                  "value": null
                },
                {
                  "name": "all_parameters",
                  "annotation": "Sequence",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Return all parameters in the index."
                    }
                  ],
                  "value": null
                }
              ],
              "docstring": [
                {
                  "kind": "admonition",
                  "value": {
                    "annotation": "usage",
                    "description": "Create an instance of the `Index` class and use its methods to interact\nwith the index.\n>>> from bamboost.index import Index\n>>> index = Index()\n\nScan for collections in known paths:\n>>> index.scan_for_collections()\n\nResolve the path of a collection:\n>>> index.resolve_path(<collection-uid>)\n\nGet a simulation from its collection and simulation name:\n>>> index.get_simulation(<collection-uid>, <simulation-name>)"
                  },
                  "title": "Usage"
                }
              ],
              "functions": {
                "__init__": {
                  "name": "__init__",
                  "path": "bamboost.index.base.Index.__init__",
                  "signature": "(self, sql_file=None, comm=None, *, search_paths=None) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "sql_file",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "comm",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "search_paths",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __init__(\n    self,\n    sql_file: Optional[StrPath] = None,\n    comm: Optional[Comm] = None,\n    *,\n    search_paths: Optional[Set[StrPath]] = None,\n) -> None:\n    self._comm = comm or MPI.COMM_WORLD\n    self.search_paths = PathSet(search_paths or config.index.searchPaths)\n    self._initialize_root_process(sql_file or config.index.databaseFile)"
                },
                "_initialize_root_process": {
                  "name": "_initialize_root_process",
                  "path": "bamboost.index.base.Index._initialize_root_process",
                  "signature": "(self, sql_file) -> None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "sql_file",
                      "annotation": "StrPath",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _initialize_root_process(self, sql_file: StrPath) -> None:\n    self._engine = create_engine(\n        f\"sqlite:///{sql_file}\",\n        json_serializer=json_serializer,\n        json_deserializer=json_deserializer,\n    )\n    create_all(self._engine)\n    self._sm = sessionmaker(\n        bind=self._engine, autobegin=False, expire_on_commit=False\n    )\n    self._s = self._sm()"
                },
                "comm_self": {
                  "name": "comm_self",
                  "path": "bamboost.index.base.Index.comm_self",
                  "signature": "(self) -> Generator[None, None, None]",
                  "description": "Context manager which changes the communicator to MPI.COMM_SELF.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Generator[None, None, None]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@contextmanager\ndef comm_self(self) -> Generator[None, None, None]:\n    \"\"\"Context manager which changes the communicator to MPI.COMM_SELF.\"\"\"\n    current_comm = self._comm\n    try:\n        self._comm = MPI.COMM_SELF\n        yield\n    finally:\n        self._comm = current_comm"
                },
                "sql_transaction": {
                  "name": "sql_transaction",
                  "path": "bamboost.index.base.Index.sql_transaction",
                  "signature": "(self) -> Generator[Session, None, None]",
                  "description": "Context manager for a SQL transaction.\n\nIf no transaction is active, a new transaction is started. If a\ntransaction is active, the current session is used.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Generator[sqlalchemy.orm.Session, None, None]",
                    "description": null
                  },
                  "docstring": [
                    {
                      "kind": "admonition",
                      "value": {
                        "annotation": "usage",
                        "description": ">>> with index.sql_transaction() as s:\n...     s.execute(...)"
                      },
                      "title": "Usage"
                    }
                  ],
                  "source": "@RootProcessMeta.exclude\n@contextmanager\ndef sql_transaction(self) -> Generator[Session, None, None]:\n    \"\"\"Context manager for a SQL transaction.\n\n    If no transaction is active, a new transaction is started. If a\n    transaction is active, the current session is used.\n\n    Usage:\n        >>> with index.sql_transaction() as s:\n        ...     s.execute(...)\n    \"\"\"\n    # if not root rank, return dummy context manager\n    if not self._comm.rank == 0:\n        yield None  # type: ignore\n        return\n    if self._s.in_transaction():\n        yield self._s\n        return\n    try:\n        self._s.begin()\n        yield self._s\n        self._s.commit()\n    except SQLAlchemyError as e:\n        # self._s.rollback()  # Is this necessary?\n        log.warning(f\"Caching transaction failed: {e}\")\n    finally:\n        self._s.close()  # Not decided yet if we should close the session"
                },
                "scan_for_collections": {
                  "name": "scan_for_collections",
                  "path": "bamboost.index.base.Index.scan_for_collections",
                  "signature": "(self, *, search_paths=None) -> list[tuple[str, Path]]",
                  "description": "Scan known paths for collections and update the index.\n\nIterates through the search paths and searches files with the\nidentifier file structure. If a collection is found, it is added to the\ncache.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "search_paths",
                      "annotation": "List",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Paths to scan for collections.\nDefaults to config.index.searchPaths."
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "list[tuple[str, pathlib.Path]]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef scan_for_collections(\n    self,\n    *,\n    search_paths: Optional[PathSet] = None,\n) -> list[tuple[str, Path]]:\n    \"\"\"Scan known paths for collections and update the index.\n\n    Iterates through the search paths and searches files with the\n    identifier file structure. If a collection is found, it is added to the\n    cache.\n\n    Args:\n        search_paths (List[Path], optional): Paths to scan for collections.\n            Defaults to config.index.searchPaths.\n    \"\"\"\n    search_paths = PathSet(search_paths) or self.search_paths\n    all_found_collections = []\n\n    for path in search_paths:\n        found_collections: tuple[tuple[str, Path], ...] = (\n            _scan_directory_for_collections(path)\n        )\n        if not found_collections:\n            continue\n        collections_data = [\n            {\"uid\": uid, \"path\": str(path)} for uid, path in found_collections\n        ]\n        self._s.execute(CollectionORM.upsert(collections_data))\n        log.debug(f\"Inserting found collections:\\n{collections_data}\")\n        all_found_collections.extend(found_collections)\n\n    return all_found_collections"
                },
                "check_integrity": {
                  "name": "check_integrity",
                  "path": "bamboost.index.base.Index.check_integrity",
                  "signature": "(self) -> None",
                  "description": "Check the integrity of the cache.\n\nThis method checks if the paths stored in the cache are valid. If a\npath is not valid, it is removed from the cache.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef check_integrity(self) -> None:\n    \"\"\"Check the integrity of the cache.\n\n    This method checks if the paths stored in the cache are valid. If a\n    path is not valid, it is removed from the cache.\n    \"\"\"\n    for collection in self._s.execute(select(CollectionORM)).scalars().all():\n        if not _validate_path(Path(collection.path), collection.uid):\n            log.info(\n                f\"Invalid collection path in cache: {collection.uid, collection.path} -> removing.\"\n            )\n            self._s.delete(collection)"
                },
                "resolve_path": {
                  "name": "resolve_path",
                  "path": "bamboost.index.base.Index.resolve_path",
                  "signature": "(self, uid, *, search_paths=None) -> Path",
                  "description": "Resolve and return the path of a collection from its UID. Raises a\n`FileNotFoundError` if the collection is not found in the search paths.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "search_paths",
                      "annotation": "Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Paths to search for the collection"
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "pathlib.Path",
                    "description": null
                  },
                  "docstring": [
                    {
                      "kind": "raises",
                      "value": [
                        {
                          "annotation": "FileNotFoundError",
                          "description": "If the collection is not found in the search paths"
                        }
                      ]
                    }
                  ],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef resolve_path(\n    self,\n    uid: str,\n    *,\n    search_paths: Optional[Set[StrPath]] = None,\n) -> Path:\n    \"\"\"Resolve and return the path of a collection from its UID. Raises a\n    `FileNotFoundError` if the collection is not found in the search paths.\n\n    Args:\n        uid: UID of the collection\n        search_paths: Paths to search for the collection\n\n    Raises:\n        FileNotFoundError: If the collection is not found in the search paths\n    \"\"\"\n    stored_path = self._get_collection_path(uid)\n\n    if stored_path and _validate_path(stored_path, uid):\n        return stored_path\n\n    log.debug(f\"No or invalid path found in cache for collection <{uid}>.\")\n\n    # Try to find the collection in the search paths\n    for root_dir in PathSet(search_paths) or self.search_paths:\n        log.debug(f\"Searching for collection <{uid}> in <{root_dir}>\")\n        paths_found = _find_collection(uid, Path(root_dir))\n\n        if len(paths_found) > 0:  # If at least one file is found\n            if len(paths_found) > 1:\n                log.warning(\n                    f\"Multiple collections found for {uid}. Using the first one.\"\n                    f\"\\n{paths_found}\"\n                )\n\n            # Store the collection in the cache\n            self.upsert_collection(uid, paths_found[0])\n            return paths_found[0]\n\n    raise FileNotFoundError(f\"Database with {uid} was not found.\")"
                },
                "resolve_uid": {
                  "name": "resolve_uid",
                  "path": "bamboost.index.base.Index.resolve_uid",
                  "signature": "(self, path) -> CollectionUID",
                  "description": "Resolve the UID of a collection from a path.\n\nReturns the UID of the collection or a new UID if it can't be\ndetermined.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "path",
                      "annotation": "StrPath",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path of the collection"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.index.base.CollectionUID",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef resolve_uid(self, path: StrPath) -> CollectionUID:\n    \"\"\"Resolve the UID of a collection from a path.\n\n    Returns the UID of the collection or a new UID if it can't be\n    determined.\n\n    Args:\n        path: Path of the collection\n    \"\"\"\n    path = Path(path)\n    cached_uid: str | None = self._s.execute(\n        select(CollectionORM.uid).where(CollectionORM.path == path.as_posix())\n    ).scalar()\n    if cached_uid and _validate_path(path, cached_uid):\n        return CollectionUID(cached_uid)\n\n    log.debug(f\"No or invalid uid found in cache for collection <{path}>.\")\n\n    identified_uid = _find_uid_from_path(path)\n    uid = CollectionUID(\n        identified_uid\n    )  # Note: this generates a new UID if none is found\n    self._s.execute(\n        CollectionORM.upsert({\"uid\": uid, \"path\": path.absolute().as_posix()})\n    )\n    return uid"
                },
                "sync_collection": {
                  "name": "sync_collection",
                  "path": "bamboost.index.base.Index.sync_collection",
                  "signature": "(self, uid, path=None) -> None",
                  "description": "Sync the table with the file system.\n\nIterates through the simulations in the collection and updates the\nmetadata and parameters if the HDF5 file has been modified.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "path",
                      "annotation": "Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path of the collection"
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef sync_collection(self, uid: str, path: Optional[StrPath] = None) -> None:\n    \"\"\"Sync the table with the file system.\n\n    Iterates through the simulations in the collection and updates the\n    metadata and parameters if the HDF5 file has been modified.\n\n    Args:\n        uid: UID of the collection\n        path (Optional): Path of the collection\n    \"\"\"\n    path = Path(path or self.resolve_path(uid)).absolute()\n    # Get all simulation names in the file system\n    all_simulations_fs = set(\n        (\n            i.name\n            for i in path.iterdir()\n            if i.is_dir() and i.joinpath(constants.HDF_DATA_FILE_NAME).is_file()\n        )\n    )\n\n    collection = self._s.get(CollectionORM, uid)\n\n    if collection:\n        for simulation in collection.simulations:\n            if simulation.name not in all_simulations_fs:\n                self._s.delete(simulation)\n                continue\n\n            # if the HDF5 file has not been modified since the last sync,\n            # remove the simulation from the active update set\n            h5_file = path.joinpath(simulation.name, constants.HDF_DATA_FILE_NAME)\n            if (  # type: ignore\n                datetime.fromtimestamp(h5_file.stat().st_mtime)\n                <= simulation.modified_at\n            ):\n                all_simulations_fs.remove(simulation.name)\n\n    for name in all_simulations_fs:\n        log.debug(f\"Syncing simulation {name} in collection {uid}.\")\n        self.upsert_simulation(\n            collection_uid=uid, simulation_name=name, collection_path=path\n        )"
                },
                "collection": {
                  "name": "collection",
                  "path": "bamboost.index.base.Index.collection",
                  "signature": "(self, uid) -> CollectionORM | None",
                  "description": "Return a collection from the index.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.index.sqlmodel.CollectionORM | None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef collection(self, uid: str) -> CollectionORM | None:\n    \"\"\"Return a collection from the index.\n\n    Args:\n        uid: UID of the collection\n    \"\"\"\n    log.debug(\"Fetching collection from cache.\")\n    return (\n        self._s.execute(\n            select(CollectionORM)\n            .where(CollectionORM.uid == uid)\n            .options(\n                joinedload(CollectionORM.simulations).subqueryload(\n                    SimulationORM.parameters\n                )\n            )\n        )\n        .unique()\n        .scalar()\n    )"
                },
                "simulation": {
                  "name": "simulation",
                  "path": "bamboost.index.base.Index.simulation",
                  "signature": "(self, collection_uid, name) -> SimulationORM | None",
                  "description": "Return a simulation from the index.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name of the simulation"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.index.sqlmodel.SimulationORM | None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef simulation(self, collection_uid: str, name: str) -> SimulationORM | None:\n    \"\"\"Return a simulation from the index.\n\n    Args:\n        collection_uid: UID of the collection\n        name: Name of the simulation\n    \"\"\"\n    return (\n        self._s.execute(\n            select(SimulationORM)\n            .where(\n                SimulationORM.collection_uid == collection_uid,\n                SimulationORM.name == name,\n            )\n            .options(joinedload(SimulationORM.parameters))\n        )\n        .unique()\n        .scalar()\n    )"
                },
                "_drop_collection": {
                  "name": "_drop_collection",
                  "path": "bamboost.index.base.Index._drop_collection",
                  "signature": "(self, uid) -> None",
                  "description": "Drop a collection from the cache.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef _drop_collection(self, uid: str) -> None:\n    \"\"\"Drop a collection from the cache.\n\n    Args:\n        uid: UID of the collection\n    \"\"\"\n    self._s.execute(delete(CollectionORM).where(CollectionORM.uid == uid))"
                },
                "_drop_simulation": {
                  "name": "_drop_simulation",
                  "path": "bamboost.index.base.Index._drop_simulation",
                  "signature": "(self, collection_uid, simulation_name) -> None",
                  "description": "Drop a simulation from the cache.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name of the simulation"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef _drop_simulation(self, collection_uid: str, simulation_name: str) -> None:\n    \"\"\"Drop a simulation from the cache.\n\n    Args:\n        collection_uid: UID of the collection\n        simulation_name: Name of the simulation\n    \"\"\"\n    stmt = delete(SimulationORM).where(\n        SimulationORM.collection_uid == collection_uid,\n        SimulationORM.name == simulation_name,\n    )\n    self._s.execute(stmt)"
                },
                "upsert_collection": {
                  "name": "upsert_collection",
                  "path": "bamboost.index.base.Index.upsert_collection",
                  "signature": "(self, uid, path) -> None",
                  "description": "Cache a collection in the index.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "path",
                      "annotation": "Path",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path of the collection"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef upsert_collection(self, uid: str, path: Path) -> None:\n    \"\"\"Cache a collection in the index.\n\n    Args:\n        uid: UID of the collection\n        path: Path of the collection\n    \"\"\"\n    self._s.execute(CollectionORM.upsert({\"uid\": uid, \"path\": path.as_posix()}))"
                },
                "upsert_simulation": {
                  "name": "upsert_simulation",
                  "path": "bamboost.index.base.Index.upsert_simulation",
                  "signature": "(self, collection_uid, simulation_name, parameters=None, metadata=None, *, collection_path=None) -> None",
                  "description": "Cache a simulation from a collection.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "UID of the collection"
                        }
                      ]
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Name of the simulation"
                        }
                      ]
                    },
                    {
                      "name": "parameters",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "metadata",
                      "annotation": "Optional",
                      "description": null,
                      "value": "None"
                    },
                    {
                      "name": "collection_path",
                      "annotation": "Optional",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Path of the collection"
                        }
                      ],
                      "value": "None"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef upsert_simulation(\n    self,\n    collection_uid: str,\n    simulation_name: str,\n    parameters: Optional[SimulationParameterT] = None,\n    metadata: Optional[SimulationMetadataT] = None,\n    *,\n    collection_path: Optional[StrPath] = None,\n) -> None:\n    \"\"\"Cache a simulation from a collection.\n\n    Args:\n        collection_uid: UID of the collection\n        simulation_name: Name of the simulation\n        collection_path (Optional): Path of the collection\n    \"\"\"\n    collection_path = Path(collection_path or self.resolve_path(collection_uid))\n\n    if metadata is None and parameters is None:\n        from bamboost.core.simulation.base import Simulation\n\n        # if neither metadata nor parameters are provided, read them from the HDF5 file\n        # temp change the communicator to MPI.COMM_SELF -> because here is only\n        # executed on rank 0\n        with self.comm_self():\n            sim = Simulation(\n                simulation_name,\n                collection_path,\n                comm=MPI.COMM_SELF,\n                index=self,\n                collection_uid=collection_uid,\n            )\n        with sim._file.open(\"r\"):\n            metadata, parameters = sim.metadata._dict, sim.parameters._dict\n\n    # Upsert the simulation table\n    sim_id = self._s.execute(\n        SimulationORM.upsert(\n            {\n                \"collection_uid\": collection_uid,\n                \"name\": simulation_name,\n                \"modified_at\": datetime.now(),\n                **(metadata or {}),\n            }\n        )\n    ).scalar_one()\n\n    # Upsert the parameters table\n    if parameters:\n        self._s.execute(\n            ParameterORM.upsert(\n                [\n                    {\"simulation_id\": sim_id, \"key\": k, \"value\": v}\n                    for k, v in parameters.items()\n                ]\n            )\n        )"
                },
                "update_simulation_metadata": {
                  "name": "update_simulation_metadata",
                  "path": "bamboost.index.base.Index.update_simulation_metadata",
                  "signature": "(self, collection_uid, simulation_name, data) -> None",
                  "description": "Update the metadata of a simulation by passing it as a dict.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "SimulationMetadataT",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Dictionary with new data"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef update_simulation_metadata(\n    self, collection_uid: str, simulation_name: str, data: SimulationMetadataT\n) -> None:\n    \"\"\"Update the metadata of a simulation by passing it as a dict.\n\n    Args:\n        data: Dictionary with new data\n    \"\"\"\n    self._s.execute(\n        SimulationORM.upsert(\n            {\"collection_uid\": collection_uid, \"name\": simulation_name, **data}\n        )\n    )"
                },
                "update_simulation_parameters": {
                  "name": "update_simulation_parameters",
                  "path": "bamboost.index.base.Index.update_simulation_parameters",
                  "signature": "(self, collection_uid, simulation_name, parameters) -> None",
                  "description": "Update the parameters of a simulation by passing it as a dict.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "parameters",
                      "annotation": "SimulationParameterT",
                      "description": [
                        {
                          "kind": "text",
                          "value": "Dictionary with new parameters"
                        }
                      ]
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@_sql_transaction\ndef update_simulation_parameters(\n    self,\n    collection_uid: str,\n    simulation_name: str,\n    parameters: SimulationParameterT,\n) -> None:\n    \"\"\"Update the parameters of a simulation by passing it as a dict.\n\n    Args:\n        parameters: Dictionary with new parameters\n    \"\"\"\n    sim_id = self._s.execute(\n        select(SimulationORM.id).where(\n            SimulationORM.collection_uid == collection_uid,\n            SimulationORM.name == simulation_name,\n        )\n    ).scalar_one()\n\n    self._s.execute(\n        ParameterORM.upsert(\n            [\n                {\"simulation_id\": sim_id, \"key\": k, \"value\": v}\n                for k, v in parameters.items()\n            ]\n        )\n    )"
                },
                "_get_collection_path": {
                  "name": "_get_collection_path",
                  "path": "bamboost.index.base.Index._get_collection_path",
                  "signature": "(self, uid) -> Optional[Path]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "uid",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Optional[pathlib.Path]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef _get_collection_path(\n    self,\n    uid: str,\n) -> Optional[Path]:\n    res = self._s.execute(\n        select(CollectionORM.path).where(CollectionORM.uid == uid)\n    ).scalar()\n    return Path(res) if res else None"
                },
                "_get_collections": {
                  "name": "_get_collections",
                  "path": "bamboost.index.base.Index._get_collections",
                  "signature": "(self) -> Sequence[CollectionORM]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Sequence[bamboost.index.sqlmodel.CollectionORM]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef _get_collections(self) -> Sequence[CollectionORM]:\n    return self._s.execute(select(CollectionORM)).scalars().all()"
                },
                "_get_simulation": {
                  "name": "_get_simulation",
                  "path": "bamboost.index.base.Index._get_simulation",
                  "signature": "(self, collection_uid, simulation_name) -> SimulationORM | None",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "collection_uid",
                      "annotation": "CollectionUID | str",
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "simulation_name",
                      "annotation": "str",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "bamboost.index.sqlmodel.SimulationORM | None",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@RootProcessMeta.bcast_result\n@_sql_transaction\ndef _get_simulation(\n    self, collection_uid: CollectionUID | str, simulation_name: str\n) -> SimulationORM | None:\n    return self._s.execute(\n        select(SimulationORM)\n        .where(\n            SimulationORM.collection_uid == collection_uid,\n            SimulationORM.name == simulation_name,\n        )\n        .options(joinedload(SimulationORM.parameters))\n    ).scalar()"
                }
              },
              "source": "class Index(metaclass=RootProcessMeta):\n    \"\"\"API for indexing BAMBOOST collections and simulations.\n\n    Usage:\n        Create an instance of the `Index` class and use its methods to interact\n        with the index.\n        >>> from bamboost.index import Index\n        >>> index = Index()\n\n        Scan for collections in known paths:\n        >>> index.scan_for_collections()\n\n        Resolve the path of a collection:\n        >>> index.resolve_path(<collection-uid>)\n\n        Get a simulation from its collection and simulation name:\n        >>> index.get_simulation(<collection-uid>, <simulation-name>)\n\n    Args:\n        cache: CacheAPI instance to use for the index. If not provided, a new\n            instance is created with the default cache file.\n    \"\"\"\n\n    _comm: Comm\n    _engine: Engine\n    _sm: Callable[..., Session]\n    _s: Session\n    search_paths: PathSet\n\n    def __init__(\n        self,\n        sql_file: Optional[StrPath] = None,\n        comm: Optional[Comm] = None,\n        *,\n        search_paths: Optional[Set[StrPath]] = None,\n    ) -> None:\n        self._comm = comm or MPI.COMM_WORLD\n        self.search_paths = PathSet(search_paths or config.index.searchPaths)\n        self._initialize_root_process(sql_file or config.index.databaseFile)\n\n    def _initialize_root_process(self, sql_file: StrPath) -> None:\n        self._engine = create_engine(\n            f\"sqlite:///{sql_file}\",\n            json_serializer=json_serializer,\n            json_deserializer=json_deserializer,\n        )\n        create_all(self._engine)\n        self._sm = sessionmaker(\n            bind=self._engine, autobegin=False, expire_on_commit=False\n        )\n        self._s = self._sm()\n\n    @contextmanager\n    def comm_self(self) -> Generator[None, None, None]:\n        \"\"\"Context manager which changes the communicator to MPI.COMM_SELF.\"\"\"\n        current_comm = self._comm\n        try:\n            self._comm = MPI.COMM_SELF\n            yield\n        finally:\n            self._comm = current_comm\n\n    @RootProcessMeta.exclude\n    @contextmanager\n    def sql_transaction(self) -> Generator[Session, None, None]:\n        \"\"\"Context manager for a SQL transaction.\n\n        If no transaction is active, a new transaction is started. If a\n        transaction is active, the current session is used.\n\n        Usage:\n            >>> with index.sql_transaction() as s:\n            ...     s.execute(...)\n        \"\"\"\n        # if not root rank, return dummy context manager\n        if not self._comm.rank == 0:\n            yield None  # type: ignore\n            return\n        if self._s.in_transaction():\n            yield self._s\n            return\n        try:\n            self._s.begin()\n            yield self._s\n            self._s.commit()\n        except SQLAlchemyError as e:\n            # self._s.rollback()  # Is this necessary?\n            log.warning(f\"Caching transaction failed: {e}\")\n        finally:\n            self._s.close()  # Not decided yet if we should close the session\n\n    @_sql_transaction\n    def scan_for_collections(\n        self,\n        *,\n        search_paths: Optional[PathSet] = None,\n    ) -> list[tuple[str, Path]]:\n        \"\"\"Scan known paths for collections and update the index.\n\n        Iterates through the search paths and searches files with the\n        identifier file structure. If a collection is found, it is added to the\n        cache.\n\n        Args:\n            search_paths (List[Path], optional): Paths to scan for collections.\n                Defaults to config.index.searchPaths.\n        \"\"\"\n        search_paths = PathSet(search_paths) or self.search_paths\n        all_found_collections = []\n\n        for path in search_paths:\n            found_collections: tuple[tuple[str, Path], ...] = (\n                _scan_directory_for_collections(path)\n            )\n            if not found_collections:\n                continue\n            collections_data = [\n                {\"uid\": uid, \"path\": str(path)} for uid, path in found_collections\n            ]\n            self._s.execute(CollectionORM.upsert(collections_data))\n            log.debug(f\"Inserting found collections:\\n{collections_data}\")\n            all_found_collections.extend(found_collections)\n\n        return all_found_collections\n\n    @_sql_transaction\n    def check_integrity(self) -> None:\n        \"\"\"Check the integrity of the cache.\n\n        This method checks if the paths stored in the cache are valid. If a\n        path is not valid, it is removed from the cache.\n        \"\"\"\n        for collection in self._s.execute(select(CollectionORM)).scalars().all():\n            if not _validate_path(Path(collection.path), collection.uid):\n                log.info(\n                    f\"Invalid collection path in cache: {collection.uid, collection.path} -> removing.\"\n                )\n                self._s.delete(collection)\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def resolve_path(\n        self,\n        uid: str,\n        *,\n        search_paths: Optional[Set[StrPath]] = None,\n    ) -> Path:\n        \"\"\"Resolve and return the path of a collection from its UID. Raises a\n        `FileNotFoundError` if the collection is not found in the search paths.\n\n        Args:\n            uid: UID of the collection\n            search_paths: Paths to search for the collection\n\n        Raises:\n            FileNotFoundError: If the collection is not found in the search paths\n        \"\"\"\n        stored_path = self._get_collection_path(uid)\n\n        if stored_path and _validate_path(stored_path, uid):\n            return stored_path\n\n        log.debug(f\"No or invalid path found in cache for collection <{uid}>.\")\n\n        # Try to find the collection in the search paths\n        for root_dir in PathSet(search_paths) or self.search_paths:\n            log.debug(f\"Searching for collection <{uid}> in <{root_dir}>\")\n            paths_found = _find_collection(uid, Path(root_dir))\n\n            if len(paths_found) > 0:  # If at least one file is found\n                if len(paths_found) > 1:\n                    log.warning(\n                        f\"Multiple collections found for {uid}. Using the first one.\"\n                        f\"\\n{paths_found}\"\n                    )\n\n                # Store the collection in the cache\n                self.upsert_collection(uid, paths_found[0])\n                return paths_found[0]\n\n        raise FileNotFoundError(f\"Database with {uid} was not found.\")\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def resolve_uid(self, path: StrPath) -> CollectionUID:\n        \"\"\"Resolve the UID of a collection from a path.\n\n        Returns the UID of the collection or a new UID if it can't be\n        determined.\n\n        Args:\n            path: Path of the collection\n        \"\"\"\n        path = Path(path)\n        cached_uid: str | None = self._s.execute(\n            select(CollectionORM.uid).where(CollectionORM.path == path.as_posix())\n        ).scalar()\n        if cached_uid and _validate_path(path, cached_uid):\n            return CollectionUID(cached_uid)\n\n        log.debug(f\"No or invalid uid found in cache for collection <{path}>.\")\n\n        identified_uid = _find_uid_from_path(path)\n        uid = CollectionUID(\n            identified_uid\n        )  # Note: this generates a new UID if none is found\n        self._s.execute(\n            CollectionORM.upsert({\"uid\": uid, \"path\": path.absolute().as_posix()})\n        )\n        return uid\n\n    @_sql_transaction\n    def sync_collection(self, uid: str, path: Optional[StrPath] = None) -> None:\n        \"\"\"Sync the table with the file system.\n\n        Iterates through the simulations in the collection and updates the\n        metadata and parameters if the HDF5 file has been modified.\n\n        Args:\n            uid: UID of the collection\n            path (Optional): Path of the collection\n        \"\"\"\n        path = Path(path or self.resolve_path(uid)).absolute()\n        # Get all simulation names in the file system\n        all_simulations_fs = set(\n            (\n                i.name\n                for i in path.iterdir()\n                if i.is_dir() and i.joinpath(constants.HDF_DATA_FILE_NAME).is_file()\n            )\n        )\n\n        collection = self._s.get(CollectionORM, uid)\n\n        if collection:\n            for simulation in collection.simulations:\n                if simulation.name not in all_simulations_fs:\n                    self._s.delete(simulation)\n                    continue\n\n                # if the HDF5 file has not been modified since the last sync,\n                # remove the simulation from the active update set\n                h5_file = path.joinpath(simulation.name, constants.HDF_DATA_FILE_NAME)\n                if (  # type: ignore\n                    datetime.fromtimestamp(h5_file.stat().st_mtime)\n                    <= simulation.modified_at\n                ):\n                    all_simulations_fs.remove(simulation.name)\n\n        for name in all_simulations_fs:\n            log.debug(f\"Syncing simulation {name} in collection {uid}.\")\n            self.upsert_simulation(\n                collection_uid=uid, simulation_name=name, collection_path=path\n            )\n\n    @property\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def all_collections(self) -> Sequence[CollectionORM]:\n        \"\"\"Return all collections in the index. Eagerly loads the simulations\n        and its parameters.\n        \"\"\"\n        return (\n            self._s.execute(\n                select(CollectionORM).options(\n                    joinedload(CollectionORM.simulations).subqueryload(\n                        SimulationORM.parameters\n                    )\n                )\n            )\n            .unique()\n            .scalars()\n            .all()\n        )\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def collection(self, uid: str) -> CollectionORM | None:\n        \"\"\"Return a collection from the index.\n\n        Args:\n            uid: UID of the collection\n        \"\"\"\n        log.debug(\"Fetching collection from cache.\")\n        return (\n            self._s.execute(\n                select(CollectionORM)\n                .where(CollectionORM.uid == uid)\n                .options(\n                    joinedload(CollectionORM.simulations).subqueryload(\n                        SimulationORM.parameters\n                    )\n                )\n            )\n            .unique()\n            .scalar()\n        )\n\n    @property\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def all_simulations(self) -> Sequence[SimulationORM]:\n        \"\"\"Return all simulations in the index. Eagerly loads the parameters.\"\"\"\n        return (\n            self._s.execute(\n                select(SimulationORM).options(joinedload(SimulationORM.parameters))\n            )\n            .unique()\n            .scalars()\n            .all()\n        )\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def simulation(self, collection_uid: str, name: str) -> SimulationORM | None:\n        \"\"\"Return a simulation from the index.\n\n        Args:\n            collection_uid: UID of the collection\n            name: Name of the simulation\n        \"\"\"\n        return (\n            self._s.execute(\n                select(SimulationORM)\n                .where(\n                    SimulationORM.collection_uid == collection_uid,\n                    SimulationORM.name == name,\n                )\n                .options(joinedload(SimulationORM.parameters))\n            )\n            .unique()\n            .scalar()\n        )\n\n    @property\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def all_parameters(self) -> Sequence[ParameterORM]:\n        \"\"\"Return all parameters in the index.\"\"\"\n        return self._s.execute(select(ParameterORM)).scalars().all()\n\n    @_sql_transaction\n    def _drop_collection(self, uid: str) -> None:\n        \"\"\"Drop a collection from the cache.\n\n        Args:\n            uid: UID of the collection\n        \"\"\"\n        self._s.execute(delete(CollectionORM).where(CollectionORM.uid == uid))\n\n    @_sql_transaction\n    def _drop_simulation(self, collection_uid: str, simulation_name: str) -> None:\n        \"\"\"Drop a simulation from the cache.\n\n        Args:\n            collection_uid: UID of the collection\n            simulation_name: Name of the simulation\n        \"\"\"\n        stmt = delete(SimulationORM).where(\n            SimulationORM.collection_uid == collection_uid,\n            SimulationORM.name == simulation_name,\n        )\n        self._s.execute(stmt)\n\n    @_sql_transaction\n    def upsert_collection(self, uid: str, path: Path) -> None:\n        \"\"\"Cache a collection in the index.\n\n        Args:\n            uid: UID of the collection\n            path: Path of the collection\n        \"\"\"\n        self._s.execute(CollectionORM.upsert({\"uid\": uid, \"path\": path.as_posix()}))\n\n    @_sql_transaction\n    def upsert_simulation(\n        self,\n        collection_uid: str,\n        simulation_name: str,\n        parameters: Optional[SimulationParameterT] = None,\n        metadata: Optional[SimulationMetadataT] = None,\n        *,\n        collection_path: Optional[StrPath] = None,\n    ) -> None:\n        \"\"\"Cache a simulation from a collection.\n\n        Args:\n            collection_uid: UID of the collection\n            simulation_name: Name of the simulation\n            collection_path (Optional): Path of the collection\n        \"\"\"\n        collection_path = Path(collection_path or self.resolve_path(collection_uid))\n\n        if metadata is None and parameters is None:\n            from bamboost.core.simulation.base import Simulation\n\n            # if neither metadata nor parameters are provided, read them from the HDF5 file\n            # temp change the communicator to MPI.COMM_SELF -> because here is only\n            # executed on rank 0\n            with self.comm_self():\n                sim = Simulation(\n                    simulation_name,\n                    collection_path,\n                    comm=MPI.COMM_SELF,\n                    index=self,\n                    collection_uid=collection_uid,\n                )\n            with sim._file.open(\"r\"):\n                metadata, parameters = sim.metadata._dict, sim.parameters._dict\n\n        # Upsert the simulation table\n        sim_id = self._s.execute(\n            SimulationORM.upsert(\n                {\n                    \"collection_uid\": collection_uid,\n                    \"name\": simulation_name,\n                    \"modified_at\": datetime.now(),\n                    **(metadata or {}),\n                }\n            )\n        ).scalar_one()\n\n        # Upsert the parameters table\n        if parameters:\n            self._s.execute(\n                ParameterORM.upsert(\n                    [\n                        {\"simulation_id\": sim_id, \"key\": k, \"value\": v}\n                        for k, v in parameters.items()\n                    ]\n                )\n            )\n\n    @_sql_transaction\n    def update_simulation_metadata(\n        self, collection_uid: str, simulation_name: str, data: SimulationMetadataT\n    ) -> None:\n        \"\"\"Update the metadata of a simulation by passing it as a dict.\n\n        Args:\n            data: Dictionary with new data\n        \"\"\"\n        self._s.execute(\n            SimulationORM.upsert(\n                {\"collection_uid\": collection_uid, \"name\": simulation_name, **data}\n            )\n        )\n\n    @_sql_transaction\n    def update_simulation_parameters(\n        self,\n        collection_uid: str,\n        simulation_name: str,\n        parameters: SimulationParameterT,\n    ) -> None:\n        \"\"\"Update the parameters of a simulation by passing it as a dict.\n\n        Args:\n            parameters: Dictionary with new parameters\n        \"\"\"\n        sim_id = self._s.execute(\n            select(SimulationORM.id).where(\n                SimulationORM.collection_uid == collection_uid,\n                SimulationORM.name == simulation_name,\n            )\n        ).scalar_one()\n\n        self._s.execute(\n            ParameterORM.upsert(\n                [\n                    {\"simulation_id\": sim_id, \"key\": k, \"value\": v}\n                    for k, v in parameters.items()\n                ]\n            )\n        )\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def _get_collection_path(\n        self,\n        uid: str,\n    ) -> Optional[Path]:\n        res = self._s.execute(\n            select(CollectionORM.path).where(CollectionORM.uid == uid)\n        ).scalar()\n        return Path(res) if res else None\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def _get_collections(self) -> Sequence[CollectionORM]:\n        return self._s.execute(select(CollectionORM)).scalars().all()\n\n    @RootProcessMeta.bcast_result\n    @_sql_transaction\n    def _get_simulation(\n        self, collection_uid: CollectionUID | str, simulation_name: str\n    ) -> SimulationORM | None:\n        return self._s.execute(\n            select(SimulationORM)\n            .where(\n                SimulationORM.collection_uid == collection_uid,\n                SimulationORM.name == simulation_name,\n            )\n            .options(joinedload(SimulationORM.parameters))\n        ).scalar()",
              "inherited_members": {}
            }
          },
          "functions": {
            "_sql_transaction": {
              "name": "_sql_transaction",
              "path": "bamboost.index.base._sql_transaction",
              "signature": "(func) -> Callable[Concatenate[Index, _P], _T]",
              "description": "Decorator to add a session to the function signature.",
              "parameters": [
                {
                  "name": "func",
                  "annotation": "Callable",
                  "description": [
                    {
                      "kind": "text",
                      "value": "The function to decorate."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Callable[typing_extensions.Concatenate[bamboost.index.base.Index, bamboost._typing._P], bamboost._typing._T]",
                "description": null
              },
              "docstring": [],
              "source": "def _sql_transaction(\n    func: Callable[Concatenate[Index, _P], _T],\n) -> Callable[Concatenate[Index, _P], _T]:\n    \"\"\"Decorator to add a session to the function signature.\n\n    Args:\n        func: The function to decorate.\n    \"\"\"\n\n    @wraps(func)\n    def inner(self: Index, *args: _P.args, **kwargs: _P.kwargs) -> Any:\n        with self.sql_transaction():\n            return func(self, *args, **kwargs)\n\n    return inner"
            },
            "simulation_metadata_from_h5": {
              "name": "simulation_metadata_from_h5",
              "path": "bamboost.index.base.simulation_metadata_from_h5",
              "signature": "(file) -> Tuple[SimulationMetadataT, SimulationParameterT]",
              "description": "Extract metadata and parameters from a BAMBOOST simulation HDF5 file.\n\nReads the metadata and parameters from the HDF5 file and returns them as a\ntuple.",
              "parameters": [
                {
                  "name": "file",
                  "annotation": "Path",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Path to the HDF5 file."
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Tuple[bamboost._typing.SimulationMetadataT, bamboost._typing.SimulationParameterT]",
                "description": null
              },
              "docstring": [],
              "source": "def simulation_metadata_from_h5(\n    file: Path,\n) -> Tuple[SimulationMetadataT, SimulationParameterT]:\n    \"\"\"Extract metadata and parameters from a BAMBOOST simulation HDF5 file.\n\n    Reads the metadata and parameters from the HDF5 file and returns them as a\n    tuple.\n\n    Args:\n        file: Path to the HDF5 file.\n    \"\"\"\n    if not file.is_file():\n        raise FileNotFoundError(f\"File not found: {file}\")\n\n    from bamboost.core.hdf5.file import HDF5File\n\n    with HDF5File(file).open(\"r\") as f:\n        meta: SimulationMetadataT = {\n            \"created_at\": datetime.fromisoformat(f.attrs.get(\"created_at\", 0))\n            if f.attrs.get(\"created_at\")\n            else datetime.now(),\n            \"modified_at\": datetime.fromtimestamp(file.stat().st_mtime),\n            \"description\": f.attrs.get(\"notes\", \"\"),\n            \"status\": f.attrs.get(\"status\", \"\"),\n        }\n        params: SimulationParameterT = dict(f[\"parameters\"].attrs)\n\n        return meta, params"
            },
            "create_identifier_file": {
              "name": "create_identifier_file",
              "path": "bamboost.index.base.create_identifier_file",
              "signature": "(path, uid) -> None",
              "description": "Create an identifier file in the collection directory.",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "StrPath",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Path to the collection directory"
                    }
                  ]
                },
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "UID of the collection"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "None",
                "description": null
              },
              "docstring": [],
              "source": "def create_identifier_file(path: StrPath, uid: str) -> None:\n    \"\"\"Create an identifier file in the collection directory.\n\n    Args:\n        path: Path to the collection directory\n        uid: UID of the collection\n    \"\"\"\n    path = Path(path)\n    with open(path.joinpath(get_identifier_filename(uid)), \"w\") as f:\n        f.write(\"Date of creation: \" + str(datetime.now()))"
            },
            "get_identifier_filename": {
              "name": "get_identifier_filename",
              "path": "bamboost.index.base.get_identifier_filename",
              "signature": "(uid) -> str",
              "description": null,
              "parameters": [
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "str",
                "description": null
              },
              "docstring": [],
              "source": "def get_identifier_filename(uid: str) -> str:\n    return IDENTIFIER_PREFIX + IDENTIFIER_SEPARATOR + uid"
            },
            "_validate_path": {
              "name": "_validate_path",
              "path": "bamboost.index.base._validate_path",
              "signature": "(path, uid) -> bool",
              "description": null,
              "parameters": [
                {
                  "name": "path",
                  "annotation": "Path",
                  "description": null,
                  "value": null
                },
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "bool",
                "description": null
              },
              "docstring": [],
              "source": "def _validate_path(path: Path, uid: str) -> bool:\n    return path.is_dir() and path.joinpath(get_identifier_filename(uid)).is_file()"
            },
            "_find_uid_from_path": {
              "name": "_find_uid_from_path",
              "path": "bamboost.index.base._find_uid_from_path",
              "signature": "(path) -> Optional[str]",
              "description": null,
              "parameters": [
                {
                  "name": "path",
                  "annotation": "Path",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "typing.Optional[str]",
                "description": null
              },
              "docstring": [],
              "source": "def _find_uid_from_path(path: Path) -> Optional[str]:\n    try:\n        return path.glob(f\"{IDENTIFIER_PREFIX}*\").__next__().name.split(\"-\")[1]\n    except StopIteration:\n        return None"
            },
            "_find_collection": {
              "name": "_find_collection",
              "path": "bamboost.index.base._find_collection",
              "signature": "(uid, root_dir) -> tuple[Path, ...]",
              "description": "Find the collection with UID under given root_dir.",
              "parameters": [
                {
                  "name": "uid",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "UID to search for"
                    }
                  ]
                },
                {
                  "name": "root_dir",
                  "annotation": "Path",
                  "description": [
                    {
                      "kind": "text",
                      "value": "root directory for search"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "tuple[pathlib.Path, ...]",
                "description": null
              },
              "docstring": [],
              "source": "def _find_collection(uid: str, root_dir: Path) -> tuple[Path, ...]:\n    \"\"\"Find the collection with UID under given root_dir.\n\n    Args:\n        uid: UID to search for\n        root_dir: root directory for search\n    \"\"\"\n    try:\n        return tuple(\n            Path(i).parent.absolute()\n            for i in _find_posix(get_identifier_filename(uid), root_dir.as_posix())\n        )\n    except subprocess.CalledProcessError:\n        raise NotImplementedError(\n            \"Only POSIX systems are supported for now. Install `find`.\"\n        )"
            },
            "_find_posix": {
              "name": "_find_posix",
              "path": "bamboost.index.base._find_posix",
              "signature": "(iname, root_dir) -> tuple[str, ...]",
              "description": "Find function using system `find` on linux.",
              "parameters": [
                {
                  "name": "iname",
                  "annotation": "str",
                  "description": null,
                  "value": null
                },
                {
                  "name": "root_dir",
                  "annotation": "str",
                  "description": null,
                  "value": null
                }
              ],
              "returns": {
                "name": "",
                "annotation": "tuple[str, ...]",
                "description": null
              },
              "docstring": [],
              "source": "def _find_posix(iname: str, root_dir: str) -> tuple[str, ...]:\n    \"\"\"Find function using system `find` on linux.\"\"\"\n    # assert that \"find\" is available\n    assert (\n        subprocess.run([\"which\", \"find\"], capture_output=True).returncode == 0\n    ), \"command `find` not available\"\n\n    completed_process = subprocess.run(\n        [\n            \"find\",\n            root_dir,\n            \"-iname\",\n            iname,\n            \"-not\",\n            \"-path\",\n            r\"*/\\.git/*\",\n        ],\n        capture_output=True,\n    )\n    identifier_files_found = tuple(\n        completed_process.stdout.decode(\"utf-8\").splitlines()\n    )\n    return identifier_files_found"
            },
            "_scan_directory_for_collections": {
              "name": "_scan_directory_for_collections",
              "path": "bamboost.index.base._scan_directory_for_collections",
              "signature": "(root_dir) -> tuple[tuple[str, Path], ...]",
              "description": "Scan the directory for collections.",
              "parameters": [
                {
                  "name": "root_dir",
                  "annotation": "Path",
                  "description": [
                    {
                      "kind": "text",
                      "value": "Directory to scan for collections"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "",
                "annotation": "tuple",
                "description": "Tuple of tuples with the UID and path of the collection"
              },
              "docstring": [],
              "source": "def _scan_directory_for_collections(root_dir: Path) -> tuple[tuple[str, Path], ...]:\n    \"\"\"Scan the directory for collections.\n\n    Args:\n        root_dir: Directory to scan for collections\n\n    Returns:\n        Tuple of tuples with the UID and path of the collection\n    \"\"\"\n\n    log.debug(f\"Scanning {root_dir}\")\n\n    if not root_dir.exists():\n        log.warning(f\"Path does not exist: {root_dir}\")\n        return ()\n\n    found_indicator_files = _find_posix(\n        f\"{IDENTIFIER_PREFIX}{IDENTIFIER_SEPARATOR}*\", root_dir.as_posix()\n    )\n\n    if not found_indicator_files:\n        log.info(f\"No collections found in {root_dir}\")\n        return ()\n\n    return tuple(\n        (i.rsplit(IDENTIFIER_SEPARATOR, 1)[-1], Path(i).parent)\n        for i in found_indicator_files\n    )"
            }
          }
        },
        "sqlmodel": {
          "name": "sqlmodel",
          "path": "bamboost.index.sqlmodel",
          "filepath": "/home/florez/work/code/bamboost-docs/.venv/lib/python3.13/site-packages/bamboost/index/sqlmodel.py",
          "description": null,
          "docstring": [],
          "attributes": [
            {
              "name": "log",
              "annotation": null,
              "description": null,
              "value": "BAMBOOST_LOGGER.getChild(__name__)"
            },
            {
              "name": "_Base",
              "annotation": null,
              "description": null,
              "value": "declarative_base()"
            },
            {
              "name": "create_all",
              "annotation": null,
              "description": null,
              "value": "_Base.metadata.create_all"
            },
            {
              "name": "_APIMethod",
              "annotation": null,
              "description": null,
              "value": "TypeVar('_APIMethod', bound=Callable[..., Any])"
            }
          ],
          "modules": {},
          "classes": {
            "CollectionORM": {
              "name": "CollectionORM",
              "path": "bamboost.index.sqlmodel.CollectionORM",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "__tablename__",
                  "annotation": null,
                  "description": null,
                  "value": "TABLENAME_COLLECTIONS"
                },
                {
                  "name": "uid",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(primary_key=True)"
                },
                {
                  "name": "path",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(String)"
                },
                {
                  "name": "simulations",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "relationship('SimulationORM', back_populates='collection', cascade='all, delete-orphan')"
                },
                {
                  "name": "parameters",
                  "annotation": "List",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index.sqlmodel.CollectionORM.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return f\"Collection {self.uid} {self.path}\""
                },
                "_repr_html_": {
                  "name": "_repr_html_",
                  "path": "bamboost.index.sqlmodel.CollectionORM._repr_html_",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def _repr_html_(self) -> str:\n    return f\"Collection <b>{self.uid}</b><br/>Location: <a href={self.path}><i>{self.path}</i></a>\""
                },
                "upsert": {
                  "name": "upsert",
                  "path": "bamboost.index.sqlmodel.CollectionORM.upsert",
                  "signature": "(cls, data) -> Insert",
                  "description": null,
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "Sequence[Dict[str, str]] | Dict[str, str]",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "sqlalchemy.Insert",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@classmethod\ndef upsert(cls, data: Sequence[Dict[str, str]] | Dict[str, str]) -> Insert:\n    stmt = insert(cls).values(data)\n    return stmt.on_conflict_do_update([\"uid\"], set_=dict(stmt.excluded))"
                },
                "get_parameter_keys": {
                  "name": "get_parameter_keys",
                  "path": "bamboost.index.sqlmodel.CollectionORM.get_parameter_keys",
                  "signature": "(self) -> tuple[list[str], list[int]]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "tuple[list[str], list[int]]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def get_parameter_keys(self) -> tuple[list[str], list[int]]:\n    unique_params = list(set(p.key for p in self.parameters))\n    counts = [sum(p.key == k for p in self.parameters) for k in unique_params]\n    return unique_params, counts"
                }
              },
              "source": "class CollectionORM(_Base):\n    __tablename__ = TABLENAME_COLLECTIONS\n\n    uid: Mapped[str] = mapped_column(primary_key=True)\n    path: Mapped[str] = mapped_column(String)\n\n    # Relationships\n    simulations: Mapped[List[SimulationORM]] = relationship(\n        \"SimulationORM\", back_populates=\"collection\", cascade=\"all, delete-orphan\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"Collection {self.uid} {self.path}\"\n\n    def _repr_html_(self) -> str:\n        return f\"Collection <b>{self.uid}</b><br/>Location: <a href={self.path}><i>{self.path}</i></a>\"\n\n    @classmethod\n    def upsert(cls, data: Sequence[Dict[str, str]] | Dict[str, str]) -> Insert:\n        stmt = insert(cls).values(data)\n        return stmt.on_conflict_do_update([\"uid\"], set_=dict(stmt.excluded))\n\n    @property\n    def parameters(self) -> List[ParameterORM]:\n        return [p for s in self.simulations for p in s.parameters]\n\n    def get_parameter_keys(self) -> tuple[list[str], list[int]]:\n        unique_params = list(set(p.key for p in self.parameters))\n        counts = [sum(p.key == k for p in self.parameters) for k in unique_params]\n        return unique_params, counts",
              "inherited_members": {}
            },
            "SimulationORM": {
              "name": "SimulationORM",
              "path": "bamboost.index.sqlmodel.SimulationORM",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "__tablename__",
                  "annotation": null,
                  "description": null,
                  "value": "TABLENAME_SIMULATIONS"
                },
                {
                  "name": "__table_args__",
                  "annotation": null,
                  "description": null,
                  "value": "(UniqueConstraint('collection_uid', 'name', name='uix_collection_name'),)"
                },
                {
                  "name": "id",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(primary_key=True, autoincrement=True, unique=True)"
                },
                {
                  "name": "collection_uid",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(ForeignKey(CollectionORM.uid))"
                },
                {
                  "name": "name",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(String, nullable=False)"
                },
                {
                  "name": "created_at",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(DateTime, nullable=False, default=datetime.now)"
                },
                {
                  "name": "modified_at",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(DateTime, nullable=False, default=datetime.now)"
                },
                {
                  "name": "description",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(String)"
                },
                {
                  "name": "status",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(String, nullable=False, default='pending')"
                },
                {
                  "name": "submitted",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(Boolean, nullable=False, default=False)"
                },
                {
                  "name": "collection",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "relationship('CollectionORM', back_populates='simulations')"
                },
                {
                  "name": "parameters",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "relationship('ParameterORM', back_populates='simulation', cascade='all, delete-orphan')"
                },
                {
                  "name": "parameter_dict",
                  "annotation": "Dict",
                  "description": null,
                  "value": null
                }
              ],
              "docstring": [],
              "functions": {
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index.sqlmodel.SimulationORM.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return f\"Simulation {self.collection_uid}+{self.name} [id: {self.id}]\""
                },
                "upsert": {
                  "name": "upsert",
                  "path": "bamboost.index.sqlmodel.SimulationORM.upsert",
                  "signature": "(cls, data) -> ReturningInsert[Tuple[int]]",
                  "description": null,
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "Sequence[_dataT] | _dataT",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "sqlalchemy.sql.dml.ReturningInsert[typing.Tuple[int]]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@classmethod\ndef upsert(cls, data: Sequence[_dataT] | _dataT) -> ReturningInsert[Tuple[int]]:\n    stmt = insert(cls).values(data)\n    # Get keys to update. Do not touch keys that are not in the data.\n    # Assumes: for the sequence case, all dictionaries have the same keys\n    keys_to_update = data.keys() if isinstance(data, dict) else data[0].keys()\n    stmt = stmt.on_conflict_do_update(\n        [\"collection_uid\", \"name\"],\n        set_={k: v for k, v in stmt.excluded.items() if k in keys_to_update},\n    )\n    stmt = stmt.returning(cls.id)\n    return stmt"
                },
                "as_dict": {
                  "name": "as_dict",
                  "path": "bamboost.index.sqlmodel.SimulationORM.as_dict",
                  "signature": "(self, standalone=True) -> Dict[str, Any]",
                  "description": "Return the simulation as a dictionary.",
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "standalone",
                      "annotation": "bool",
                      "description": [
                        {
                          "kind": "text",
                          "value": "If False, \"id\", \"collection_uid\", and\n\"modified_at\" are excluded. Defaults to True."
                        }
                      ],
                      "value": "True"
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "typing.Dict[str, typing.Any]",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def as_dict(self, standalone: bool = True) -> Dict[str, Any]:\n    \"\"\"Return the simulation as a dictionary.\n\n    Args:\n        standalone (bool, optional): If False, \"id\", \"collection_uid\", and\n            \"modified_at\" are excluded. Defaults to True.\n    \"\"\"\n    excluded_columns = (\n        {\n            \"id\",\n            \"collection_uid\",\n            \"modified_at\",\n        }\n        if not standalone\n        else set()\n    )\n    column_names = [\n        c.name for c in self.__table__.columns if c.name not in excluded_columns\n    ]\n\n    return {k: getattr(self, k) for k in column_names} | self.parameter_dict"
                }
              },
              "source": "class SimulationORM(_Base):\n    __tablename__ = TABLENAME_SIMULATIONS\n    __table_args__ = (\n        UniqueConstraint(\"collection_uid\", \"name\", name=\"uix_collection_name\"),\n    )\n\n    class _dataT(TypedDict):\n        collection_uid: str\n        name: str\n        created_at: NotRequired[datetime]\n        modified_at: NotRequired[datetime]\n        description: NotRequired[str]\n        status: NotRequired[str]\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, unique=True)\n    collection_uid: Mapped[str] = mapped_column(ForeignKey(CollectionORM.uid))\n    name: Mapped[str] = mapped_column(String, nullable=False)\n\n    # Metadata\n    created_at: Mapped[DateTime] = mapped_column(\n        DateTime, nullable=False, default=datetime.now\n    )\n    modified_at: Mapped[DateTime] = mapped_column(\n        DateTime, nullable=False, default=datetime.now\n    )\n    description: Mapped[Optional[str]] = mapped_column(String)\n    status: Mapped[str] = mapped_column(String, nullable=False, default=\"pending\")\n    submitted: Mapped[bool] = mapped_column(Boolean, nullable=False, default=False)\n\n    # Relationships\n    collection: Mapped[CollectionORM] = relationship(\n        \"CollectionORM\", back_populates=\"simulations\"\n    )\n    parameters: Mapped[List[ParameterORM]] = relationship(\n        \"ParameterORM\", back_populates=\"simulation\", cascade=\"all, delete-orphan\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"Simulation {self.collection_uid}+{self.name} [id: {self.id}]\"\n\n    @classmethod\n    def upsert(cls, data: Sequence[_dataT] | _dataT) -> ReturningInsert[Tuple[int]]:\n        stmt = insert(cls).values(data)\n        # Get keys to update. Do not touch keys that are not in the data.\n        # Assumes: for the sequence case, all dictionaries have the same keys\n        keys_to_update = data.keys() if isinstance(data, dict) else data[0].keys()\n        stmt = stmt.on_conflict_do_update(\n            [\"collection_uid\", \"name\"],\n            set_={k: v for k, v in stmt.excluded.items() if k in keys_to_update},\n        )\n        stmt = stmt.returning(cls.id)\n        return stmt\n\n    def as_dict(self, standalone: bool = True) -> Dict[str, Any]:\n        \"\"\"Return the simulation as a dictionary.\n\n        Args:\n            standalone (bool, optional): If False, \"id\", \"collection_uid\", and\n                \"modified_at\" are excluded. Defaults to True.\n        \"\"\"\n        excluded_columns = (\n            {\n                \"id\",\n                \"collection_uid\",\n                \"modified_at\",\n            }\n            if not standalone\n            else set()\n        )\n        column_names = [\n            c.name for c in self.__table__.columns if c.name not in excluded_columns\n        ]\n\n        return {k: getattr(self, k) for k in column_names} | self.parameter_dict\n\n    @property\n    def parameter_dict(self) -> Dict[str, Any]:\n        return {p.key: p.value for p in self.parameters}",
              "inherited_members": {}
            },
            "ParameterORM": {
              "name": "ParameterORM",
              "path": "bamboost.index.sqlmodel.ParameterORM",
              "description": null,
              "parameters": [],
              "attributes": [
                {
                  "name": "__tablename__",
                  "annotation": null,
                  "description": null,
                  "value": "TABLENAME_PARAMETERS"
                },
                {
                  "name": "__table_args__",
                  "annotation": null,
                  "description": null,
                  "value": "(UniqueConstraint('simulation_id', 'key', name='uix_simulation_key'),)"
                },
                {
                  "name": "id",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(primary_key=True, autoincrement=True)"
                },
                {
                  "name": "simulation_id",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(ForeignKey(SimulationORM.id), nullable=False)"
                },
                {
                  "name": "key",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(String, nullable=False)"
                },
                {
                  "name": "value",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "mapped_column(JSON, nullable=False)"
                },
                {
                  "name": "simulation",
                  "annotation": "Mapped",
                  "description": null,
                  "value": "relationship('SimulationORM', back_populates='parameters')"
                }
              ],
              "docstring": [],
              "functions": {
                "__repr__": {
                  "name": "__repr__",
                  "path": "bamboost.index.sqlmodel.ParameterORM.__repr__",
                  "signature": "(self) -> str",
                  "description": null,
                  "parameters": [
                    {
                      "name": "self",
                      "annotation": null,
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "str",
                    "description": null
                  },
                  "docstring": [],
                  "source": "def __repr__(self) -> str:\n    return f\"Parameter {self.key} = {self.value} [id: {self.id}]\""
                },
                "upsert": {
                  "name": "upsert",
                  "path": "bamboost.index.sqlmodel.ParameterORM.upsert",
                  "signature": "(cls, data) -> Insert",
                  "description": null,
                  "parameters": [
                    {
                      "name": "cls",
                      "annotation": null,
                      "description": null,
                      "value": null
                    },
                    {
                      "name": "data",
                      "annotation": "Sequence[_dataT] | _dataT",
                      "description": null,
                      "value": null
                    }
                  ],
                  "returns": {
                    "name": "",
                    "annotation": "sqlalchemy.Insert",
                    "description": null
                  },
                  "docstring": [],
                  "source": "@classmethod\ndef upsert(cls, data: Sequence[_dataT] | _dataT) -> Insert:\n    stmt = insert(cls).values(data)\n    return stmt.on_conflict_do_update(\n        [\"simulation_id\", \"key\"], set_=dict(value=stmt.excluded.value)\n    )"
                }
              },
              "source": "class ParameterORM(_Base):\n    __tablename__ = TABLENAME_PARAMETERS\n    __table_args__ = (\n        UniqueConstraint(\"simulation_id\", \"key\", name=\"uix_simulation_key\"),\n    )\n\n    class _dataT(TypedDict):\n        simulation_id: int\n        key: str\n        value: Any\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)\n    simulation_id: Mapped[int] = mapped_column(\n        ForeignKey(SimulationORM.id), nullable=False\n    )\n    key: Mapped[str] = mapped_column(String, nullable=False)\n    value: Mapped[JSON] = mapped_column(JSON, nullable=False)\n\n    # Relationships\n    simulation: Mapped[SimulationORM] = relationship(\n        \"SimulationORM\", back_populates=\"parameters\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"Parameter {self.key} = {self.value} [id: {self.id}]\"\n\n    @classmethod\n    def upsert(cls, data: Sequence[_dataT] | _dataT) -> Insert:\n        stmt = insert(cls).values(data)\n        return stmt.on_conflict_do_update(\n            [\"simulation_id\", \"key\"], set_=dict(value=stmt.excluded.value)\n        )",
              "inherited_members": {}
            }
          },
          "functions": {
            "json_serializer": {
              "name": "json_serializer",
              "path": "bamboost.index.sqlmodel.json_serializer",
              "signature": "(value) -> str",
              "description": "Convert a value to a JSON string.",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "description": [
                    {
                      "kind": "text",
                      "value": "value to convert"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "str",
                "annotation": "str",
                "description": "JSON string"
              },
              "docstring": [],
              "source": "def json_serializer(value: Any) -> str:\n    \"\"\"Convert a value to a JSON string.\n\n    Args:\n        value: value to convert\n\n    Returns:\n        str: JSON string\n    \"\"\"\n    import numpy as np\n\n    if isinstance(value, np.ndarray):\n        return json.dumps(value.tolist())\n\n    # Convert numpy scalar types to their item\n    if hasattr(value, \"item\"):\n        return json.dumps(value.item())\n\n    return json.dumps(value)"
            },
            "json_deserializer": {
              "name": "json_deserializer",
              "path": "bamboost.index.sqlmodel.json_deserializer",
              "signature": "(value) -> Any",
              "description": "Convert a JSON string to a value.",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "str",
                  "description": [
                    {
                      "kind": "text",
                      "value": "JSON string to convert"
                    }
                  ]
                }
              ],
              "returns": {
                "name": "Any",
                "annotation": "typing.Any",
                "description": "Converted value"
              },
              "docstring": [],
              "source": "def json_deserializer(value: str) -> Any:\n    \"\"\"Convert a JSON string to a value.\n\n    Args:\n        value: JSON string to convert\n\n    Returns:\n        Any: Converted value\n    \"\"\"\n    return json.loads(value)"
            }
          }
        }
      },
      "classes": {},
      "functions": {}
    }
  },
  "classes": {},
  "functions": {
    "_add_stream_handler": {
      "name": "_add_stream_handler",
      "path": "bamboost._add_stream_handler",
      "signature": "(logger) -> None",
      "description": null,
      "parameters": [
        {
          "name": "logger",
          "annotation": "logging.Logger",
          "description": null,
          "value": null
        }
      ],
      "returns": {
        "name": "",
        "annotation": "None",
        "description": null
      },
      "docstring": [],
      "source": "def _add_stream_handler(logger: logging.Logger) -> None:\n    from bamboost.mpi import MPI, MPI_ON\n\n    class _LogFormatterWithRank(logging.Formatter):\n        def format(self, record):\n            record.rank = MPI.COMM_WORLD.rank\n            return super().format(record)\n\n    if MPI_ON:\n        formatter = _LogFormatterWithRank(\n            \"[%(asctime)s] %(name)s: %(levelname)s [%(rank)d] - %(message)s\",\n            style=\"%\",\n            datefmt=\"%Y-%m-%d %H:%M:%S\",\n        )\n    else:\n        formatter = logging.Formatter(\n            \"[%(asctime)s] %(name)s: %(levelname)s - %(message)s\",\n            datefmt=\"%Y-%m-%d %H:%M:%S\",\n        )\n    STREAM_HANDLER.setFormatter(formatter)\n    logger.addHandler(STREAM_HANDLER)"
    },
    "set_log_level": {
      "name": "set_log_level",
      "path": "bamboost.set_log_level",
      "signature": "(level) -> None",
      "description": null,
      "parameters": [
        {
          "name": "level",
          "annotation": "Literal",
          "description": null,
          "value": null
        }
      ],
      "returns": {
        "name": "",
        "annotation": "None",
        "description": null
      },
      "docstring": [],
      "source": "def set_log_level(\n    level: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n) -> None:\n    BAMBOOST_LOGGER.setLevel(level)"
    }
  },
  "version": "unknown"
}