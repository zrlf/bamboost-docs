{
  "name": "bamboost",
  "docstring": "",
  "classes": {},
  "functions": {
    "add_stream_handler": {
      "docstring": "",
      "signature": "(logger: logging.Logger) -> None",
      "returns": {
        "annotation": "None",
        "description": null
      },
      "arguments": {
        "logger": {
          "default": null,
          "annotation": "<class 'logging.Logger'>",
          "description": null
        }
      },
      "source": {
        "code": "def add_stream_handler(logger: logging.Logger) -> None:\n    stream_handler = logging.StreamHandler()\n    formatter = logging.Formatter(\n        \"[%(asctime)s] %(name)s: %(levelname)s - %(message)s\",\n        style=\"%\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n    stream_handler.setFormatter(formatter)\n    logger.addHandler(stream_handler)\n",
        "lines": [
          10,
          18
        ]
      },
      "props": {
        "isClassMethod": false
      },
      "examples": []
    },
    "set_log_level": {
      "docstring": "",
      "signature": "(level: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']) -> None",
      "returns": {
        "annotation": "None",
        "description": null
      },
      "arguments": {
        "level": {
          "default": null,
          "annotation": "typing.Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']",
          "description": null
        }
      },
      "source": {
        "code": "def set_log_level(\n    level: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n) -> None:\n    BAMBOOST_LOGGER.setLevel(level)\n",
        "lines": [
          25,
          28
        ]
      },
      "props": {
        "isClassMethod": false
      },
      "examples": []
    }
  },
  "submodules": {
    "accessors": {
      "name": "bamboost.accessors",
      "docstring": "",
      "classes": {},
      "functions": {},
      "submodules": {
        "meshes": {
          "name": "bamboost.accessors.meshes",
          "docstring": "",
          "classes": {
            "MeshGroup": {
              "name": "MeshGroup",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "__getitem__": {
                  "docstring": "",
                  "signature": "(self, key) -> bamboost.accessors.meshes.Mesh",
                  "returns": {
                    "annotation": "<class 'bamboost.accessors.meshes.Mesh'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def __getitem__(self, key) -> Mesh:\n        return Mesh(self._file, f\"{self.path_to_data}/{key}\")\n",
                    "lines": [
                      36,
                      38
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {},
              "inherits_from": {
                "Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ]
                  ]
                },
                "BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str = '/Mesh/0',\n    _default_mesh: str = 'mesh',\n    **kwargs\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                    "description": "file this belongs to"
                  },
                  "path_to_data": {
                    "default": "/Mesh/0",
                    "annotation": "<class 'str'>",
                    "description": "infile path to object"
                  },
                  "_default_mesh": {
                    "default": "mesh",
                    "annotation": "<class 'str'>",
                    "description": null
                  },
                  "kwargs": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __init__(\n        self,\n        file_handler: FileHandler,\n        path_to_data: str = \"/Mesh/0\",\n        _default_mesh: str = \"mesh\",\n        **kwargs,\n    ) -> None:\n        super().__init__(file_handler, path_to_data, **kwargs)\n        self._default_mesh = _default_mesh\n",
                  "lines": [
                    26,
                    34
                  ]
                }
              }
            },
            "Mesh": {
              "name": "Mesh",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "get_tuple": {
                  "docstring": "",
                  "signature": "(self) -> Tuple[numpy.ndarray, numpy.ndarray]",
                  "returns": {
                    "annotation": "typing.Tuple[numpy.ndarray, numpy.ndarray]",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def get_tuple(self) -> Tuple[np.ndarray, np.ndarray]:\n        return (self.coordinates, self.connectivity)\n",
                    "lines": [
                      58,
                      60
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {
                "coordinates": {
                  "annotation": "",
                  "description": null
                },
                "connectivity": {
                  "annotation": "",
                  "description": null
                }
              },
              "inherits_from": {
                "Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ]
                  ]
                },
                "BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                    "description": "file this belongs to"
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": "infile path to object"
                  }
                },
                "source": {
                  "code": "    def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n        super().__init__(file_handler, path_to_data)\n",
                  "lines": [
                    42,
                    43
                  ]
                }
              }
            }
          },
          "functions": {},
          "submodules": {}
        },
        "fielddata": {
          "name": "bamboost.accessors.fielddata",
          "docstring": "",
          "classes": {
            "DataGroup": {
              "name": "DataGroup",
              "short_description": "This pointer points to the data directory. Item accessor returns the",
              "docstring": "This pointer points to the data directory. Item accessor returns the\nindividual data fields. `meshes` is passed to here for access of linked\nmeshes.",
              "methods": {
                "__getitem__": {
                  "docstring": "",
                  "signature": "(self, key) -> bamboost.accessors.fielddata.FieldData",
                  "returns": {
                    "annotation": "<class 'bamboost.accessors.fielddata.FieldData'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def __getitem__(self, key) -> FieldData:\n        return FieldData(self._file, f\"{self.path_to_data}/{key}\", meshes=self.meshes)\n",
                    "lines": [
                      47,
                      48
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "__iter__": {
                  "docstring": "",
                  "signature": "(self) -> bamboost.accessors.fielddata.FieldData",
                  "returns": {
                    "annotation": "<class 'bamboost.accessors.fielddata.FieldData'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def __iter__(self) -> FieldData:\n        for key in self.keys():\n            yield self.__getitem__(key)\n",
                    "lines": [
                      50,
                      52
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {
                "meshes": {
                  "annotation": "",
                  "description": null
                },
                "info": {
                  "annotation": ": pandas.core.frame.DataFrame",
                  "description": "View the data stored. "
                }
              },
              "inherits_from": {
                "Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ]
                  ]
                },
                "BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    file_handler: bamboost.common.file_handler.FileHandler,\n    meshes: bamboost.accessors.meshes.MeshGroup,\n    path_to_data: str = '/data',\n    **kwargs\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                    "description": null
                  },
                  "meshes": {
                    "default": null,
                    "annotation": "<class 'bamboost.accessors.meshes.MeshGroup'>",
                    "description": null
                  },
                  "path_to_data": {
                    "default": "/data",
                    "annotation": "<class 'str'>",
                    "description": null
                  },
                  "kwargs": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __init__(\n        self,\n        file_handler: FileHandler,\n        meshes: MeshGroup,\n        path_to_data: str = \"/data\",\n        **kwargs,\n    ) -> None:\n        super().__init__(file_handler, path_to_data, **kwargs)\n        self.meshes = meshes\n",
                  "lines": [
                    37,
                    45
                  ]
                }
              }
            },
            "FieldData": {
              "name": "FieldData",
              "short_description": "This pointer points to a specific data field. `meshes` is passed to here",
              "docstring": "This pointer points to a specific data field. `meshes` is passed to here\nfor access of linked meshes.",
              "methods": {
                "__getitem__": {
                  "docstring": "",
                  "signature": "(self, key) -> numpy.ndarray",
                  "returns": {
                    "annotation": "<class 'numpy.ndarray'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def __getitem__(self, key) -> np.ndarray:\n        return self._get_full_data()[key]\n",
                    "lines": [
                      92,
                      94
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "__len__": {
                  "docstring": "",
                  "signature": "(self) -> int",
                  "returns": {
                    "annotation": "<class 'int'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def __len__(self) -> int:\n        non_field_keys = set({self._vds_key, self._times_key})\n        return len(self.keys() - non_field_keys)\n",
                    "lines": [
                      108,
                      111
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "at_step": {
                  "docstring": "Direct access to data at step. Does not require the virtual dataset.\n",
                  "signature": "(self, *steps: int) -> numpy.ndarray",
                  "returns": {
                    "annotation": "<class 'numpy.ndarray'>",
                    "description": ":class:`np.ndarray`"
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "steps": {
                      "default": null,
                      "annotation": "<class 'int'>",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open()\n    def at_step(self, *steps: int) -> np.ndarray:\n        \"\"\"Direct access to data at step. Does not require the virtual dataset.\n\n        Args:\n            step0, step1, ...: step to extract (can be multiple)\n        Returns:\n            :class:`np.ndarray`\n        \"\"\"\n        data = list()\n        for step in steps:\n            if step < 0:\n                step = len(self) + step\n            data.append(self.obj[str(step)][()])\n        if len(data) <= 1:\n            return data[0]\n        else:\n            return data\n",
                    "lines": [
                      123,
                      140
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "regenerate_virtual_datasets": {
                  "docstring": "Regenerate virtual dataset. Call this if the data has changed, thus the\nvirtual datasets need to be updated to cover the actual data.",
                  "signature": "(self) -> None",
                  "returns": {
                    "annotation": "None",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def regenerate_virtual_datasets(self) -> None:\n        \"\"\"Regenerate virtual dataset. Call this if the data has changed, thus the\n        virtual datasets need to be updated to cover the actual data.\n        \"\"\"\n        self._create_times()\n        self._create_vds()\n",
                    "lines": [
                      181,
                      186
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {
                "meshes": {
                  "annotation": "",
                  "description": null
                },
                "shape": {
                  "annotation": ": tuple",
                  "description": null
                },
                "dtype": {
                  "annotation": ": type",
                  "description": null
                },
                "times": {
                  "annotation": ": numpy.ndarray",
                  "description": "Return the array of timestamps. "
                },
                "mesh": {
                  "annotation": ": bamboost.accessors.meshes.Mesh",
                  "description": "Return the linked mesh. Currently returns the linked mesh of first step only. "
                },
                "coordinates": {
                  "annotation": ": numpy.ndarray",
                  "description": "Wrapper for mesh.coordinates"
                },
                "connectivity": {
                  "annotation": ": numpy.ndarray",
                  "description": "Wrapper for mesh.connectivity"
                },
                "msh": {
                  "annotation": ": Tuple[numpy.ndarray, numpy.ndarray]",
                  "description": "Wrapper to get mesh as tuple"
                }
              },
              "inherits_from": {
                "Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ]
                  ]
                },
                "BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str,\n    meshes: bamboost.accessors.meshes.MeshGroup\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                    "description": null
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": null
                  },
                  "meshes": {
                    "default": null,
                    "annotation": "<class 'bamboost.accessors.meshes.MeshGroup'>",
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __init__(\n        self, file_handler: FileHandler, path_to_data: str, meshes: MeshGroup\n    ) -> None:\n        super().__init__(file_handler, path_to_data)\n        self.meshes = meshes\n        self._name = path_to_data.split(\"/\")[-1]\n",
                  "lines": [
                    85,
                    90
                  ]
                }
              }
            }
          },
          "functions": {},
          "submodules": {}
        },
        "globals": {
          "name": "bamboost.accessors.globals",
          "docstring": "",
          "classes": {
            "GlobalGroup": {
              "name": "GlobalGroup",
              "short_description": "Enhanced Group for '/globals'.",
              "docstring": "Enhanced Group for '/globals'.\n",
              "methods": {},
              "variables": {
                "df": {
                  "annotation": ": pandas.core.frame.DataFrame",
                  "description": "Return a pandas DataFrame with all datasets."
                }
              },
              "inherits_from": {
                "Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ]
                  ]
                },
                "BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                    "description": "The file handler."
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": "The in-file path to the group."
                  }
                },
                "source": {
                  "code": "    def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n        super().__init__(file_handler, path_to_data)\n",
                  "lines": [
                    29,
                    30
                  ]
                }
              }
            }
          },
          "functions": {},
          "submodules": {}
        }
      }
    },
    "common": {
      "name": "bamboost.common",
      "docstring": "",
      "classes": {},
      "functions": {},
      "submodules": {
        "file_handler": {
          "name": "bamboost.common.file_handler",
          "docstring": "",
          "classes": {
            "FileHandler": {
              "name": "FileHandler",
              "short_description": "File handler for an hdf5 file with the purpose of handling opening and closing",
              "docstring": "File handler for an hdf5 file with the purpose of handling opening and closing\nof the file. We use the concept of composition to include an object of this type\nin classes which need access to an hdf5 file (such as the hdf5pointer and Simulation.)",
              "methods": {
                "__getitem__": {
                  "docstring": "",
                  "signature": "(self, key) -> Any",
                  "returns": {
                    "annotation": "typing.Any",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @capture_key_error\n    def __getitem__(self, key) -> Any:\n        return self.file_object[key]\n",
                    "lines": [
                      139,
                      141
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "open": {
                  "docstring": "",
                  "signature": "(self, mode: str = 'r', driver=None, comm=None)",
                  "returns": {
                    "annotation": "<class 'inspect._empty'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "mode": {
                      "default": "r",
                      "annotation": "<class 'str'>",
                      "description": null
                    },
                    "driver": {
                      "default": "None",
                      "annotation": null,
                      "description": null
                    },
                    "comm": {
                      "default": "None",
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def open(self, mode: str = \"r\", driver=None, comm=None):\n        if self._lock <= 0:\n            log.debug(f\"[{id(self)}] Open {self.file_name}\")\n            self.file_object = open_h5file(self.file_name, mode, driver, comm)\n\n        if FILE_MODE_HIRARCHY[self.file_object.mode] < FILE_MODE_HIRARCHY[mode]:\n            self.change_file_mode(mode, driver, comm)\n\n        log.debug(f\"[{id(self)}] Lock stack {self._lock}\")\n        self._lock += 1\n        return self.file_object\n",
                    "lines": [
                      161,
                      171
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "close": {
                  "docstring": "",
                  "signature": "(self)",
                  "returns": {
                    "annotation": "<class 'inspect._empty'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def close(self):\n        self._lock -= 1\n        if self._lock == 0:\n            log.debug(f\"[{id(self)}] Close {self.file_name}\")\n            self.file_object.close()\n        log.debug(f\"[{id(self)}] Lock stack {self._lock}\")\n",
                    "lines": [
                      173,
                      178
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "change_file_mode": {
                  "docstring": "",
                  "signature": "(self, mode: str, driver=None, comm=None)",
                  "returns": {
                    "annotation": "<class 'inspect._empty'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "mode": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": null
                    },
                    "driver": {
                      "default": "None",
                      "annotation": null,
                      "description": null
                    },
                    "comm": {
                      "default": "None",
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def change_file_mode(self, mode: str, driver=None, comm=None):\n        log.info(\n            f\"Forced closing and reopening to change file mode [{self.file_name}].\"\n        )\n        self.file_object.close()\n        self.file_object = open_h5file(self.file_name, mode, driver, comm)\n",
                    "lines": [
                      180,
                      185
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {
                "file_object": {
                  "annotation": ": h5py._hl.files.File",
                  "description": null
                },
                "file_name": {
                  "annotation": "",
                  "description": null
                },
                "simulation_uid": {
                  "annotation": "",
                  "description": null
                }
              },
              "inherits_from": {},
              "examples": [],
              "constructor": {
                "signature": "(\n    file_name: str,\n    _comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_name": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": "the path to the file"
                  },
                  "_comm": {
                    "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x743de48d8890>",
                    "annotation": "<class 'bamboost.common._mock_mpi.MockMPI.Comm'>",
                    "description": "MPI communicator"
                  }
                },
                "source": {
                  "code": "    def __init__(\n        self, file_name: str, _comm: mpi.MPI.Comm = mpi.MPI.COMM_WORLD\n    ) -> None:\n        self.file_object: h5py.File = None\n        self.file_name = file_name\n        self.simulation_uid = os.path.basename(file_name)\n        self._lock = 0\n        self._mode = \"r\"\n        self._driver = None\n        self._comm = _comm\n",
                  "lines": [
                    119,
                    128
                  ]
                }
              }
            }
          },
          "functions": {
            "open_h5file": {
              "docstring": "Open h5 file. Waiting if file is not available.\n",
              "signature": "(\n    file: str,\n    mode: Union[Literal['mpio'], Type[NoneType]],\n    driver: Union[bool, Type[NoneType]] = None,\n    comm=None\n)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "file": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "File to open"
                },
                "mode": {
                  "default": null,
                  "annotation": "typing.Union[typing.Literal['mpio'], typing.Type[NoneType]]",
                  "description": "'r', 'a', 'w', ..."
                },
                "driver": {
                  "default": "None",
                  "annotation": "typing.Union[bool, typing.Type[NoneType]]",
                  "description": "driver for h5.File"
                },
                "comm": {
                  "default": "None",
                  "annotation": null,
                  "description": "MPI communicator"
                }
              },
              "source": {
                "code": "def open_h5file(\n    file: str,\n    mode: Literal[\"mpio\"] | Type[None],\n    driver: bool | Type[None] = None,\n    comm=None,\n):\n    \"\"\"Open h5 file. Waiting if file is not available.\n\n    Args:\n        file (str): File to open\n        mode (str): 'r', 'a', 'w', ...\n        driver (str): driver for h5.File\n        comm: MPI communicator\n    \"\"\"\n    while True:\n        try:\n            if driver == \"mpio\" and MPI_ACTIVE and mpi.MPI_ON:\n                return h5py.File(file, mode, driver=driver, comm=comm)\n            else:\n                return h5py.File(file, mode)\n\n        except BlockingIOError:\n            log.warning(f\"file locked --> {file}\")\n            time.sleep(0.2)\n",
                "lines": [
                  44,
                  67
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "with_file_open": {
              "docstring": "Open the file (`self._file`) before function\nClose the file after the function call\n\nWorks on classes containing the member `_file` of type :class:`~bamboost.common.file_handler.FileHandler`",
              "signature": "(mode: str = 'r', driver=None, comm=None)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "mode": {
                  "default": "r",
                  "annotation": "<class 'str'>",
                  "description": null
                },
                "driver": {
                  "default": "None",
                  "annotation": null,
                  "description": null
                },
                "comm": {
                  "default": "None",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def with_file_open(mode: str = \"r\", driver=None, comm=None):\n    \"\"\"Open the file (`self._file`) before function\n    Close the file after the function call\n\n    Works on classes containing the member `_file` of type :class:`~bamboost.common.file_handler.FileHandler`\n    \"\"\"\n\n    def decorator(method):\n        @wraps(method)\n        def wrapper(self, *args, **kwargs):\n            with self._file(mode, driver, comm):\n                return method(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n",
                "lines": [
                  70,
                  85
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "capture_key_error": {
              "docstring": "",
              "signature": "(method)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "method": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def capture_key_error(method):\n    @wraps(method)\n    def inner(self, *args, **kwargs):\n        try:\n            return method(self, *args, **kwargs)\n        except KeyError as e:\n            e.add_note(f\"[file: {self.file_name}]\")\n            raise e\n\n    return inner\n",
                "lines": [
                  88,
                  97
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "submodules": {}
        },
        "job": {
          "name": "bamboost.common.job",
          "docstring": "",
          "classes": {
            "Job": {
              "name": "Job",
              "short_description": "",
              "docstring": "",
              "methods": {
                "create_sbatch_script": {
                  "docstring": "Write sbatch script for new simulation.\n\nThe following environment variables are written to the script:\n    - DATABASE_DIR: Path to the database directory.\n    - SIMULATION_DIR: Path to the simulation directory.\n    - SIMULATION_ID: Full id of the simulation.",
                  "signature": "(\n    self,\n    commands: list,\n    path: str,\n    uid: str = None,\n    db_id: str = None,\n    nnodes: int = 1,\n    ntasks: int = 4,\n    ncpus: int = 1,\n    time: str = '04:00:00',\n    mem_per_cpu: int = 2048,\n    tmp: int = None,\n    sbatch_kwargs: list = None\n) -> None",
                  "returns": {
                    "annotation": "None",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "commands": {
                      "default": null,
                      "annotation": "<class 'list'>",
                      "description": "List of commands to be executed."
                    },
                    "path": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": "Path to the database directory."
                    },
                    "uid": {
                      "default": "None",
                      "annotation": "<class 'str'>",
                      "description": "Unique identifier of the simulation."
                    },
                    "db_id": {
                      "default": "None",
                      "annotation": "<class 'str'>",
                      "description": "Database ID. Defaults to None."
                    },
                    "nnodes": {
                      "default": "1",
                      "annotation": "<class 'int'>",
                      "description": "Number of nodes. Defaults to 1."
                    },
                    "ntasks": {
                      "default": "4",
                      "annotation": "<class 'int'>",
                      "description": "Number of tasks. Defaults to 4."
                    },
                    "ncpus": {
                      "default": "1",
                      "annotation": "<class 'int'>",
                      "description": "Number of cpus. Defaults to 1."
                    },
                    "time": {
                      "default": "04:00:00",
                      "annotation": "<class 'str'>",
                      "description": "Time limit. Defaults to \"04:00:00\"."
                    },
                    "mem_per_cpu": {
                      "default": "2048",
                      "annotation": "<class 'int'>",
                      "description": "Memory per cpu. Defaults to 2048."
                    },
                    "tmp": {
                      "default": "None",
                      "annotation": "<class 'int'>",
                      "description": "Temporary space."
                    },
                    "sbatch_kwargs": {
                      "default": "None",
                      "annotation": "<class 'list'>",
                      "description": "Additional sbatch arguments. allow to provide additional sbatch arguments. in the format [\"--mail=BEGIN,END,FAIL\", ...]."
                    }
                  },
                  "source": {
                    "code": "    def create_sbatch_script(\n        self,\n        commands: list,\n        path: str,\n        uid: str = None,\n        db_id: str = None,\n        nnodes: int = 1,\n        ntasks: int = 4,\n        ncpus: int = 1,\n        time: str = \"04:00:00\",\n        mem_per_cpu: int = 2048,\n        tmp: int = None,\n        sbatch_kwargs: list = None,\n    ) -> None:\n        \"\"\"Write sbatch script for new simulation.\n\n        The following environment variables are written to the script:\n            - DATABASE_DIR: Path to the database directory.\n            - SIMULATION_DIR: Path to the simulation directory.\n            - SIMULATION_ID: Full id of the simulation.\n\n        Args:\n            commands (list): List of commands to be executed.\n            path (str): Path to the database directory.\n            uid (str): Unique identifier of the simulation.\n            db_id (str): Database ID. Defaults to None.\n            nnodes (int): Number of nodes. Defaults to 1.\n            ntasks (int): Number of tasks. Defaults to 4.\n            ncpus (int): Number of cpus. Defaults to 1.\n            time (str): Time limit. Defaults to \"04:00:00\".\n            mem_per_cpu (int): Memory per cpu. Defaults to 2048.\n            tmp (int): Temporary space.\n            sbatch_kwargs (list): Additional sbatch arguments. allow to provide\n                additional sbatch arguments. in the format [\"--mail=BEGIN,END,FAIL\", ...].\n        \"\"\"\n        nb_tasks_per_node = int(ntasks / nnodes)\n\n        # define how mpirun is called\n        mpicommand = \"\"\n        if ntasks > 1:\n            mpicommand = \"mpirun \"\n\n        script = \"#!/bin/bash\\n\\n\"\n\n        # sbatch commands\n        script += f\"#SBATCH --ntasks={ntasks}\\n\"\n        if ntasks > 1:\n            script += f\"#SBATCH --nodes={nnodes}\\n\"\n            script += f\"#SBATCH --cpus-per-task={ncpus}\\n\"\n            script += f\"#SBATCH --ntasks-per-node={nb_tasks_per_node}\\n\"\n        script += f\"#SBATCH --time={time}\\n\"\n        script += f\"#SBATCH --job-name={db_id}:{uid}\\n\"\n        script += f\"#SBATCH --mem-per-cpu={mem_per_cpu}\\n\"\n        if tmp:\n            script += f\"#SBATCH --tmp={tmp}\\n\"\n        script += f\"#SBATCH --output={os.path.join(path, uid)}/{uid}.out\\n\"\n\n        if sbatch_kwargs is not None:\n            for s in sbatch_kwargs:\n                script += f\"#SBATCH {s}\\n\"\n\n        # add paths as environment variables\n        script += self._set_environment_variables(db_id, uid)\n        # backwards compatibility: add SCRIPT_DIR as environment variable\n        script += \"SCRIPT_DIR=$SIMULATION_DIR\\n\\n\"\n\n        # user defined commands\n        script += \"\\n\"\n        for cmd in commands:\n            script += cmd.format(MPI=mpicommand) + \"\\n\"\n\n        # write to submission file\n        with open(\n            os.path.join(os.path.join(path, uid), f\"sbatch_{uid}.sh\"), \"w\"\n        ) as file:\n            file.write(script)\n",
                    "lines": [
                      32,
                      107
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "create_bash_script_local": {
                  "docstring": "Write bash script for local execution.\n\nThe following environment variables are written to the script:\n    - DATABASE_DIR: Path to the database directory.\n    - SIMULATION_DIR: Path to the simulation directory.\n    - SIMULATION_ID: Full id of the simulation.",
                  "signature": "(\n    self,\n    commands: list,\n    path: str,\n    uid: str,\n    db_id: str = None,\n    ntasks: int = 4\n) -> None",
                  "returns": {
                    "annotation": "None",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "commands": {
                      "default": null,
                      "annotation": "<class 'list'>",
                      "description": "List of commands to be executed."
                    },
                    "path": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": "Path to the database directory."
                    },
                    "uid": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": "Unique identifier of the simulation."
                    },
                    "db_id": {
                      "default": "None",
                      "annotation": "<class 'str'>",
                      "description": "Database ID. Defaults to None."
                    },
                    "ntasks": {
                      "default": "4",
                      "annotation": "<class 'int'>",
                      "description": "Number of tasks. Defaults to 4."
                    }
                  },
                  "source": {
                    "code": "    def create_bash_script_local(\n        self, commands: list, path: str, uid: str, db_id: str = None, ntasks: int = 4\n    ) -> None:\n        \"\"\"Write bash script for local execution.\n\n        The following environment variables are written to the script:\n            - DATABASE_DIR: Path to the database directory.\n            - SIMULATION_DIR: Path to the simulation directory.\n            - SIMULATION_ID: Full id of the simulation.\n\n        Args:\n            commands (list): List of commands to be executed.\n            path (str): Path to the database directory.\n            uid (str): Unique identifier of the simulation.\n            db_id (str): Database ID. Defaults to None.\n            ntasks (int): Number of tasks. Defaults to 4.\n        \"\"\"\n\n        # define how mpirun is called\n        mpicommand = \"\"\n        if ntasks > 1:\n            mpicommand = f\"mpirun -n {ntasks}\"\n\n        script = f\"#!/bin/bash\\n\\n\"\n\n        # add paths as environment variables\n        script += self._set_environment_variables(db_id, uid)\n\n        # user defined commands\n        for cmd in commands:\n            script += cmd.format(MPI=mpicommand) + \"\\n\"\n\n        with open(os.path.join(os.path.join(path, uid), f\"{uid}.sh\"), \"w\") as file:\n            file.write(script)\n",
                    "lines": [
                      109,
                      142
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {},
              "inherits_from": {},
              "examples": [],
              "constructor": {
                "signature": "()",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __init__(self):\n        pass\n",
                  "lines": [
                    19,
                    20
                  ]
                }
              }
            }
          },
          "functions": {},
          "submodules": {}
        },
        "utilities": {
          "name": "bamboost.common.utilities",
          "docstring": "Utility functions used by bamboost.",
          "classes": {},
          "functions": {
            "flatten_dict": {
              "docstring": "",
              "signature": "(dictionary, parent_key='', seperator='.')",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "dictionary": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "parent_key": {
                  "default": "",
                  "annotation": null,
                  "description": null
                },
                "seperator": {
                  "default": ".",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def flatten_dict(dictionary, parent_key=\"\", seperator=\".\"):\n    items = []\n    for key, value in dictionary.items():\n        new_key = parent_key + seperator + key if parent_key else key\n        if isinstance(value, MutableMapping):\n            items.extend(flatten_dict(value, new_key, seperator=seperator).items())\n        else:\n            items.append((new_key, value))\n    return dict(items)\n",
                "lines": [
                  35,
                  43
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "unflatten_dict": {
              "docstring": "",
              "signature": "(dictionary, seperator='.')",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "dictionary": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "seperator": {
                  "default": ".",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def unflatten_dict(dictionary, seperator=\".\"):\n    new_dict = dict()\n    for key, value in dictionary.items():\n        parts = key.split(seperator)\n        d = new_dict\n        for part in parts[:-1]:\n            if part not in d:\n                d[part] = dict()\n            d = d[part]\n        d[parts[-1]] = value\n    return new_dict\n",
                "lines": [
                  46,
                  56
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "tree": {
              "docstring": "Given a directory Path object print a visual tree structure",
              "signature": "(\n    dir_path: pathlib.Path,\n    level: int = -1,\n    limit_to_directories: bool = False,\n    length_limit: int = 1000\n)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "dir_path": {
                  "default": null,
                  "annotation": "<class 'pathlib.Path'>",
                  "description": null
                },
                "level": {
                  "default": "-1",
                  "annotation": "<class 'int'>",
                  "description": null
                },
                "limit_to_directories": {
                  "default": "False",
                  "annotation": "<class 'bool'>",
                  "description": null
                },
                "length_limit": {
                  "default": "1000",
                  "annotation": "<class 'int'>",
                  "description": null
                }
              },
              "source": {
                "code": "def tree(\n    dir_path: Path,\n    level: int = -1,\n    limit_to_directories: bool = False,\n    length_limit: int = 1000,\n):\n    \"\"\"Given a directory Path object print a visual tree structure\"\"\"\n    dir_path = Path(dir_path)  # accept string coerceable to Path\n    files = 0\n    directories = 0\n    folder_symbol = \"\\U00002B57 \"\n\n    def inner(dir_path: Path, prefix: str = \"\", level=-1):\n        nonlocal files, directories\n        if not level:\n            return  # 0, stop iterating\n        if limit_to_directories:\n            contents = [d for d in dir_path.iterdir() if d.is_dir()]\n        else:\n            contents = list(dir_path.iterdir())\n        pointers = [tee] * (len(contents) - 1) + [last]\n        for pointer, path in zip(pointers, contents):\n            if path.is_dir():\n                yield prefix + pointer + \"\\U000025CC \" + path.name\n                directories += 1\n                extension = branch if pointer == tee else space\n                yield from inner(path, prefix=prefix + extension, level=level - 1)\n            elif not limit_to_directories:\n                yield prefix + pointer + path.name\n                files += 1\n\n    tree_string = \"\"\n    tree_string += (folder_symbol + dir_path.name) + \"\\n\"\n    iterator = inner(dir_path, level=level)\n    for line in islice(iterator, length_limit):\n        tree_string += (line) + \"\\n\"\n    if next(iterator, None):\n        tree_string += (f\"... length_limit, {length_limit}, reached, counted:\") + \"\\n\"\n    tree_string += (\n        f\"\\n{directories} directories\" + (f\", {files} files\" if files else \"\")\n    ) + \"\\n\"\n    return tree_string\n",
                "lines": [
                  60,
                  101
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "h5_tree": {
              "docstring": "",
              "signature": "(val, pre='')",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "val": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "pre": {
                  "default": "",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "def h5_tree(val, pre=\"\"):\n    items = len(val)\n    for key, val in val.items():\n        items -= 1\n        if items == 0:\n            # the last item\n            if type(val) == h5py._hl.group.Group:\n                print(pre + \"\u2514\u2500\u2500 \" + key)\n                h5_tree(val, pre + \"    \")\n            else:\n                print(pre + \"\u2514\u2500\u2500 \" + key + \" (%d)\" % len(val))\n        else:\n            if type(val) == h5py._hl.group.Group:\n                print(pre + \"\u251c\u2500\u2500 \" + key)\n                h5_tree(val, pre + \"\u2502   \")\n            else:\n                print(pre + \"\u251c\u2500\u2500 \" + key + \" (%d)\" % len(val))\n",
                "lines": [
                  104,
                  120
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "show_differences": {
              "docstring": "This function takes a pandas DataFrame as input and returns a modified\nDataFrame that shows only the columns which have differences.\n\nThe function first creates a copy of the input DataFrame to work with. It\nthen iterates over each column in the DataFrame and tries to calculate the\nnumber of unique values in that column. If successful, it adds the column\nname and number of unique values to a list of good results. If there is an\nerror, it attempts to apply json.dumps to the column and then calculate the\nnumber of unique values again. If this is successful, it also adds the\ncolumn name and number of unique values to the list of good results. If\nthere is still an error, it adds the column name and the error to a list of\nerrors.\n\nAfter processing all columns, the function removes any columns that had\nerrors from the DataFrame. It then sets the index of the DataFrame to 'id'\nand filters out any columns that have only one unique value. The modified\nDataFrame is then returned.",
              "signature": "(df: pandas.core.frame.DataFrame) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "<class 'pandas.core.frame.DataFrame'>",
                "description": "pd.DataFrame"
              },
              "arguments": {
                "df": {
                  "default": null,
                  "annotation": "<class 'pandas.core.frame.DataFrame'>",
                  "description": "The input DataFrame to analyze"
                }
              },
              "source": {
                "code": "def show_differences(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"This function takes a pandas DataFrame as input and returns a modified\n    DataFrame that shows only the columns which have differences.\n\n    The function first creates a copy of the input DataFrame to work with. It\n    then iterates over each column in the DataFrame and tries to calculate the\n    number of unique values in that column. If successful, it adds the column\n    name and number of unique values to a list of good results. If there is an\n    error, it attempts to apply json.dumps to the column and then calculate the\n    number of unique values again. If this is successful, it also adds the\n    column name and number of unique values to the list of good results. If\n    there is still an error, it adds the column name and the error to a list of\n    errors.\n\n    After processing all columns, the function removes any columns that had\n    errors from the DataFrame. It then sets the index of the DataFrame to 'id'\n    and filters out any columns that have only one unique value. The modified\n    DataFrame is then returned.\n\n    Args:\n        df (pd.DataFrame): The input DataFrame to analyze\n\n    Returns:\n        pd.DataFrame\n    \"\"\"\n    import json\n\n    df_diff = df.copy()\n    cols_nunique_good = []\n    cols_nunique_error = []\n    for col in df_diff.columns:\n        try:\n            nunique = df_diff[col].nunique()\n            cols_nunique_good.append((col, nunique))\n        except Exception as e:\n            try:\n                df_diff[col] = df_diff[col].apply(json.dumps)\n                nunique = df_diff[col].nunique()\n                cols_nunique_good.append((col, nunique))\n            except TypeError as e:\n                cols_nunique_error.append((col, e))\n\n    df_diff = df_diff[\n        df_diff.columns[~df_diff.columns.isin([col for col, _, in cols_nunique_error])]\n    ]\n    try:\n        df_diff.set_index(\"id\", inplace=True)\n    except KeyError:\n        pass\n    df_diff = df_diff.loc[:, (df_diff.nunique() != 1)]\n    df_diff.dropna(axis=1, how=\"all\", inplace=True)\n    return df_diff\n",
                "lines": [
                  123,
                  174
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "to_camel_case": {
              "docstring": "",
              "signature": "(s: str) -> str",
              "returns": {
                "annotation": "<class 'str'>",
                "description": null
              },
              "arguments": {
                "s": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "def to_camel_case(s: str) -> str:\n    words = s.split()\n    camel_case = words[0].lower() + \"\".join([word.capitalize() for word in words[1:]])\n    return camel_case\n",
                "lines": [
                  177,
                  180
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "submodules": {}
        },
        "git_utility": {
          "name": "bamboost.common.git_utility",
          "docstring": "",
          "classes": {
            "GitStateGetter": {
              "name": "GitStateGetter",
              "short_description": "",
              "docstring": "",
              "methods": {
                "create_git_string": {
                  "docstring": "",
                  "signature": "(self) -> str",
                  "returns": {
                    "annotation": "<class 'str'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def create_git_string(self) -> str:\n        self.string = \"\"\n\n        self.string += \"\\n\"\n        self.string += \"----- REMOTE ------ \\n\"\n        self.string += self._git_command(\"git remote -v\")\n\n        self.string += \"\\n\"\n        self.string += \"----- BRANCH ------ \\n\"\n        self.string += self._git_command(\"git branch -v\")\n\n        self.string += \"\\n\"\n        self.string += \"----- LAST COMMIT ------ \\n\"\n        self.string += self._git_command(\"git rev-parse HEAD\")\n\n        self.string += \"\\n\"\n        self.string += \"----- STATUS ------ \\n\"\n        self.string += self._git_command(\"git status\")\n\n        self.string += \"\\n\"\n        self.string += \"----- DIFFERENCE ------ \\n\"\n        self.string += self._git_command(\"git diff HEAD\")\n\n        return self.string\n",
                    "lines": [
                      30,
                      53
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {},
              "inherits_from": {},
              "examples": [],
              "constructor": {
                "signature": "()",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __init__(self) -> None:\n        pass\n",
                  "lines": [
                    16,
                    17
                  ]
                }
              }
            }
          },
          "functions": {},
          "submodules": {}
        },
        "hdf_pointer": {
          "name": "bamboost.common.hdf_pointer",
          "docstring": "",
          "classes": {
            "BasePointer": {
              "name": "BasePointer",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "new_pointer": {
                  "docstring": "Returns a new pointer object.",
                  "signature": "(\n    cls,\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n) -> bamboost.common.hdf_pointer.BasePointer",
                  "returns": {
                    "annotation": "<class 'bamboost.common.hdf_pointer.BasePointer'>",
                    "description": null
                  },
                  "arguments": {
                    "cls": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "file_handler": {
                      "default": null,
                      "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                      "description": null
                    },
                    "path_to_data": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @classmethod\n    def new_pointer(cls, file_handler: FileHandler, path_to_data: str) -> BasePointer:\n        \"\"\"Returns a new pointer object.\"\"\"\n        with file_handler(\"r\") as f:\n            obj = f.file_object[path_to_data]\n            if isinstance(obj, h5py.Group):\n                if issubclass(cls, Group):\n                    return cls(file_handler, path_to_data)\n                else:\n                    return Group(file_handler, path_to_data)\n            elif isinstance(obj, h5py.Dataset):\n                return Dataset(file_handler, path_to_data)\n            else:\n                return BasePointer(file_handler, path_to_data)\n",
                    "lines": [
                      43,
                      56
                    ]
                  },
                  "props": {
                    "isClassMethod": true
                  },
                  "examples": []
                },
                "__getitem__": {
                  "docstring": "",
                  "signature": "(self, key)",
                  "returns": {
                    "annotation": "<class 'inspect._empty'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def __getitem__(self, key):\n        new_path = f\"{self.path_to_data}/{key}\"\n        return self.new_pointer(self._file, new_path)\n",
                    "lines": [
                      86,
                      89
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {
                "path_to_data": {
                  "annotation": "",
                  "description": null
                },
                "obj": {
                  "annotation": "",
                  "description": "The object this BasePointer points to. File needs to be open for access."
                },
                "attrs": {
                  "annotation": "",
                  "description": null
                }
              },
              "inherits_from": {},
              "examples": [],
              "constructor": {
                "signature": "(\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                    "description": "file this belongs to"
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": "infile path to object"
                  }
                },
                "source": {
                  "code": "    def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n        self._file = file_handler\n        self.path_to_data = path_to_data\n",
                  "lines": [
                    58,
                    60
                  ]
                }
              }
            },
            "Group": {
              "name": "Group",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "__iter__": {
                  "docstring": "",
                  "signature": "(self)",
                  "returns": {
                    "annotation": "<class 'inspect._empty'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def __iter__(self):\n        for key in self.keys():\n            yield self.__getitem__(key)\n",
                    "lines": [
                      104,
                      106
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "keys": {
                  "docstring": "",
                  "signature": "(self) -> set",
                  "returns": {
                    "annotation": "<class 'set'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def keys(self) -> set:\n        return set(self.obj.keys())\n",
                    "lines": [
                      108,
                      110
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "groups": {
                  "docstring": "",
                  "signature": "(self) -> set",
                  "returns": {
                    "annotation": "<class 'set'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def groups(self) -> set:\n        return {key for key in self.keys() if isinstance(self.obj[key], h5py.Group)}\n",
                    "lines": [
                      112,
                      114
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "datasets": {
                  "docstring": "",
                  "signature": "(self) -> set",
                  "returns": {
                    "annotation": "<class 'set'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def datasets(self) -> set:\n        return {key for key in self.keys() if isinstance(self.obj[key], h5py.Dataset)}\n",
                    "lines": [
                      116,
                      118
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {},
              "inherits_from": {
                "BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                    "description": "file this belongs to"
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": "infile path to object"
                  }
                },
                "source": {
                  "code": "    def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n        super().__init__(file_handler, path_to_data)\n",
                  "lines": [
                    98,
                    99
                  ]
                }
              }
            },
            "MutableGroup": {
              "name": "MutableGroup",
              "short_description": "Used for the `userdata` group.",
              "docstring": "Used for the `userdata` group.",
              "methods": {
                "__getitem__": {
                  "docstring": "Used to access datasets (:class:`~bamboost.common.hdf_pointer.Dataset`)\nor groups inside this group (:class:`~bamboost.common.hdf_pointer.MutableGroup`)",
                  "signature": "(self, key) -> Any",
                  "returns": {
                    "annotation": "typing.Any",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def __getitem__(self, key) -> Any:\n        \"\"\"Used to access datasets (:class:`~bamboost.common.hdf_pointer.Dataset`)\n        or groups inside this group (:class:`~bamboost.common.hdf_pointer.MutableGroup`)\n        \"\"\"\n        try:\n            return super().__getitem__(key)\n        except KeyError:\n            pass\n\n        try:\n            return self.obj.attrs[key]\n        except KeyError:\n            pass\n\n        return super().__getitem__(key)\n",
                    "lines": [
                      180,
                      195
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "__setitem__": {
                  "docstring": "Used to set an attribute.\nWill be written as an attribute to the group.",
                  "signature": "(self, key, newvalue)",
                  "returns": {
                    "annotation": "<class 'inspect._empty'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "key": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "newvalue": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def __setitem__(self, key, newvalue):\n        \"\"\"Used to set an attribute.\n        Will be written as an attribute to the group.\n        \"\"\"\n        if isinstance(newvalue, str) or not isinstance(newvalue, Iterable):\n            self.update_attrs({key: newvalue})\n        else:\n            self.add_dataset(key, np.array(newvalue))\n",
                    "lines": [
                      197,
                      204
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "update_attrs": {
                  "docstring": "Update the attributes of the group.\n",
                  "signature": "(self, attrs: dict) -> None",
                  "returns": {
                    "annotation": "None",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "attrs": {
                      "default": null,
                      "annotation": "<class 'dict'>",
                      "description": "the dictionary to write as attributes"
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"a\")\n    def update_attrs(self, attrs: dict) -> None:\n        \"\"\"Update the attributes of the group.\n\n        Args:\n            attrs: the dictionary to write as attributes\n        \"\"\"\n        self.obj.attrs.update(attrs)\n",
                    "lines": [
                      214,
                      221
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "add_dataset": {
                  "docstring": "Add a dataset to the group. Error is thrown if attempting to overwrite\nwith different shape than before. If same shape, data is overwritten\n(this is inherited from h5py -> require_dataset)",
                  "signature": "(\n    self,\n    name: str,\n    vector: numpy.ndarray,\n    attrs: dict = None,\n    dtype: str = None\n) -> None",
                  "returns": {
                    "annotation": "None",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "name": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": "Name for the dataset"
                    },
                    "vector": {
                      "default": null,
                      "annotation": "<class 'numpy.ndarray'>",
                      "description": "Data to write (max 2d)"
                    },
                    "attrs": {
                      "default": "None",
                      "annotation": "<class 'dict'>",
                      "description": "Optional. Attributes of dataset."
                    },
                    "dtype": {
                      "default": "None",
                      "annotation": "<class 'str'>",
                      "description": "Optional. dtype of dataset. If not specified, uses dtype of inpyt array"
                    }
                  },
                  "source": {
                    "code": "    def add_dataset(\n        self, name: str, vector: np.ndarray, attrs: dict = None, dtype: str = None\n    ) -> None:\n        \"\"\"Add a dataset to the group. Error is thrown if attempting to overwrite\n        with different shape than before. If same shape, data is overwritten\n        (this is inherited from h5py -> require_dataset)\n\n        Args:\n            name: Name for the dataset\n            vector: Data to write (max 2d)\n            attrs: Optional. Attributes of dataset.\n            dtype: Optional. dtype of dataset. If not specified, uses dtype of inpyt array\n        \"\"\"\n        if attrs is None:\n            attrs = {}\n        length_local = vector.shape[0]\n        length_p = np.array(self._file._comm.allgather(length_local))\n        length = np.sum(length_p)\n        dim = vector.shape[1:]\n        vec_shape = length, *dim\n\n        ranks = np.array([i for i in range(self._file._comm.size)])\n        idx_start = np.sum(length_p[ranks < self._file._comm.rank])\n        idx_end = idx_start + length_local\n\n        with self._file(\"a\", driver=\"mpio\"):\n            dataset = self.obj.require_dataset(\n                name, shape=vec_shape, dtype=dtype if dtype else vector.dtype\n            )\n            dataset[idx_start:idx_end] = vector\n            for key, item in attrs.items():\n                dataset.attrs[key] = item\n\n        log.info(f\"Written {name} as userdata to {self._file.file_name}...\")\n",
                    "lines": [
                      223,
                      256
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "require_group": {
                  "docstring": "Add a new group to the current group. If exists, return existing.\n",
                  "signature": "(self, name: str) -> bamboost.common.hdf_pointer.MutableGroup",
                  "returns": {
                    "annotation": "<class 'bamboost.common.hdf_pointer.MutableGroup'>",
                    "description": ":class:`~bamboost.hdf_pointer.Group`"
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "name": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def require_group(self, name: str) -> MutableGroup:\n        \"\"\"Add a new group to the current group. If exists, return existing.\n\n        Returns:\n            :class:`~bamboost.hdf_pointer.Group`\n        \"\"\"\n        return MutableGroup(self._file, f\"{self.path_to_data}/{name}\")\n",
                    "lines": [
                      258,
                      264
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {},
              "inherits_from": {
                "Group": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "function",
                      "keys"
                    ],
                    [
                      "function",
                      "groups"
                    ],
                    [
                      "function",
                      "datasets"
                    ]
                  ]
                },
                "BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ],
                    [
                      "variable",
                      "attrs"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                    "description": null
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n        super().__init__(file_handler, path_to_data)\n        # Create group if it doesn't exist\n        with self._file(\"a\", driver=\"mpio\"):\n            self._file.file_object.require_group(path_to_data)\n",
                  "lines": [
                    171,
                    175
                  ]
                }
              }
            },
            "Dataset": {
              "name": "Dataset",
              "short_description": "Pointer to a location in an hdf5 file. The constructor takes a",
              "docstring": "Pointer to a location in an hdf5 file. The constructor takes a\n:class:`~.file_handler.FileHandler` and the in-file path to the object.\nThe base class represents a generic group in the file",
              "methods": {
                "__getitem__": {
                  "docstring": "",
                  "signature": "(self, slice)",
                  "returns": {
                    "annotation": "<class 'inspect._empty'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "slice": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_file_open(\"r\")\n    def __getitem__(self, slice):\n        return self.obj[slice]\n",
                    "lines": [
                      271,
                      273
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {
                "attrs": {
                  "annotation": "",
                  "description": null
                },
                "shape": {
                  "annotation": "",
                  "description": null
                },
                "dtype": {
                  "annotation": "",
                  "description": null
                }
              },
              "inherits_from": {
                "BasePointer": {
                  "module": "bamboost.common.hdf_pointer",
                  "members": [
                    [
                      "function",
                      "new_pointer"
                    ],
                    [
                      "variable",
                      "path_to_data"
                    ],
                    [
                      "variable",
                      "obj"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    file_handler: bamboost.common.file_handler.FileHandler,\n    path_to_data: str\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "file_handler": {
                    "default": null,
                    "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                    "description": "file this belongs to"
                  },
                  "path_to_data": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": "infile path to object"
                  }
                },
                "source": {
                  "code": "    def __init__(self, file_handler: FileHandler, path_to_data: str) -> None:\n        super().__init__(file_handler, path_to_data)\n",
                  "lines": [
                    268,
                    269
                  ]
                }
              }
            }
          },
          "functions": {},
          "submodules": {}
        },
        "mpi": {
          "name": "bamboost.common.mpi",
          "docstring": "",
          "classes": {},
          "functions": {},
          "submodules": {}
        }
      }
    },
    "extensions": {
      "name": "bamboost.extensions",
      "docstring": "",
      "classes": {
        "ExtensionsLazyLoader": {
          "name": "ExtensionsLazyLoader",
          "short_description": "",
          "docstring": "",
          "methods": {},
          "variables": {
            "FenicsWriter": {
              "annotation": "",
              "description": null
            },
            "Remote": {
              "annotation": "",
              "description": null
            },
            "RemoteManager": {
              "annotation": "",
              "description": null
            },
            "install_slurm": {
              "annotation": "",
              "description": null
            }
          },
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "()",
            "arguments": {},
            "source": {
              "code": "",
              "lines": null
            }
          }
        }
      },
      "functions": {},
      "submodules": {
        "fenics": {
          "name": "bamboost.extensions.fenics",
          "docstring": "",
          "classes": {
            "FenicsWriter": {
              "name": "FenicsWriter",
              "short_description": "Helper writer for input from FEniCS directly.",
              "docstring": "Helper writer for input from FEniCS directly.\n",
              "methods": {
                "add_field": {
                  "docstring": "Add a dataset to the file. The data is stored at `data/`.\n",
                  "signature": "(\n    self,\n    name: str,\n    func: <fenics.Function>,\n    time: float = None,\n    mesh: str = None,\n    dtype: str = None,\n    center: str = 'Node'\n) -> None",
                  "returns": {
                    "annotation": "None",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "name": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": "Name for the dataset"
                    },
                    "func": {
                      "default": null,
                      "annotation": "<fenics.Function>",
                      "description": "FEniCS function to store"
                    },
                    "time": {
                      "default": "None",
                      "annotation": "<class 'float'>",
                      "description": "Optional. time"
                    },
                    "mesh": {
                      "default": "None",
                      "annotation": "<class 'str'>",
                      "description": "Optional. Linked mesh for this data"
                    },
                    "dtype": {
                      "default": "None",
                      "annotation": "<class 'str'>",
                      "description": "Optional. Numpy style datatype, see h5py documentation, defaults to the dtype of the vector"
                    },
                    "center": {
                      "default": "Node",
                      "annotation": "<class 'str'>",
                      "description": "Optional. Center of the data. Can be 'Node' or 'Cell'. Default is 'Node'."
                    }
                  },
                  "source": {
                    "code": "    def add_field(\n        self,\n        name: str,\n        func: fe.Function,\n        time: float = None,\n        mesh: str = None,\n        dtype: str = None,\n        center: str = \"Node\",\n    ) -> None:\n        \"\"\"Add a dataset to the file. The data is stored at `data/`.\n\n        Args:\n            name: Name for the dataset\n            func: FEniCS function to store\n            time: Optional. time\n            mesh: Optional. Linked mesh for this data\n            dtype: Optional. Numpy style datatype, see h5py documentation,\n                defaults to the dtype of the vector\n            center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n                Default is 'Node'.\n        \"\"\"\n        mesh = mesh if mesh is not None else self._default_mesh\n        time = time if time is not None else self.step\n\n        # get global dofs ordering and vector\n        if center == \"Node\":\n            data = self._get_global_dofs(func)\n        elif center == \"Cell\":\n            data = self._get_global_dofs_cell_data(func)\n        else:\n            raise ValueError(\"Center must be 'Node' or 'Cell'.\")\n        vector = data[\"vector\"]\n        global_map = data[\"global_map\"]\n        global_size = data[\"global_size\"]\n\n        dim = data[\"vector\"].shape[1:] if data[\"vector\"].ndim > 1 else None\n\n        # Write vector to file\n        with self._file(\"a\", driver=\"mpio\", comm=self._comm) as f:\n            data = f.require_group(\"data\")\n            grp = data.require_group(name)\n            vec = grp.require_dataset(\n                str(self.step),\n                shape=(global_size, *dim) if dim else (global_size,),\n                dtype=dtype if dtype else vector.dtype,\n            )\n            vec[global_map] = vector\n\n        if self._prank == 0:\n            with self._file(\"a\"):\n                vec = self._file[\"data\"][name][str(self.step)]\n                vec.attrs[\"t\"] = time  # add time as attribute to dataset\n                vec.attrs[\"mesh\"] = mesh  # add link to mesh as attribute\n                vec.attrs[\"center\"] = center\n",
                    "lines": [
                      46,
                      99
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "add_mesh": {
                  "docstring": "Add the mesh to file using fe.HDF5File. I can't figure out how to\nextract the local mesh data in correct order when running in parallel.",
                  "signature": "(self, mesh: <fenics.Mesh>, mesh_name: str = None) -> None",
                  "returns": {
                    "annotation": "None",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "mesh": {
                      "default": null,
                      "annotation": "<fenics.Mesh>",
                      "description": "FEniCS mesh object"
                    },
                    "mesh_name": {
                      "default": "None",
                      "annotation": "<class 'str'>",
                      "description": "name for mesh (default = `mesh`)"
                    }
                  },
                  "source": {
                    "code": "    def add_mesh(self, mesh: fe.Mesh, mesh_name: str = None) -> None:\n        \"\"\"\n        Add the mesh to file using fe.HDF5File. I can't figure out how to\n        extract the local mesh data in correct order when running in parallel.\n\n        Args:\n            mesh: FEniCS mesh object\n            mesh_name: name for mesh (default = `mesh`)\n        \"\"\"\n        mesh_name = mesh_name if mesh_name is not None else self._default_mesh\n        mesh_location = f\"{self._mesh_location}/{mesh_name}/\"\n\n        assert not self._file.file_object, \"File is open -> Quitting\"\n\n        @contextmanager\n        def temporary_close_file():\n            was_open = False\n            if self._file.file_object:\n                self._file.file_object.close()\n                was_open = True\n            try:\n                yield\n            finally:\n                if was_open:\n                    self._file.file_object = open_h5file(\n                        self._file.file_name,\n                        self._file.mode,\n                        self._file.driver,\n                        self._file.comm,\n                    )\n\n        with temporary_close_file():\n            with fe.HDF5File(self._comm, self.h5file, \"a\") as f:\n                f.write(mesh, mesh_location)\n",
                    "lines": [
                      184,
                      217
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {},
              "inherits_from": {
                "SimulationWriter": {
                  "module": "bamboost.simulation_writer",
                  "members": [
                    [
                      "variable",
                      "step"
                    ],
                    [
                      "function",
                      "initialize"
                    ],
                    [
                      "function",
                      "add_metadata"
                    ],
                    [
                      "function",
                      "add_parameters"
                    ],
                    [
                      "function",
                      "add_fields"
                    ],
                    [
                      "function",
                      "add_global_field"
                    ],
                    [
                      "function",
                      "add_global_fields"
                    ],
                    [
                      "function",
                      "add_additional"
                    ],
                    [
                      "function",
                      "finish_step"
                    ],
                    [
                      "function",
                      "finish_sim"
                    ],
                    [
                      "function",
                      "register_git_attributes"
                    ],
                    [
                      "function",
                      "copy_executable"
                    ],
                    [
                      "function",
                      "copy_file"
                    ]
                  ]
                },
                "Simulation": {
                  "module": "bamboost.simulation",
                  "members": [
                    [
                      "variable",
                      "uid"
                    ],
                    [
                      "variable",
                      "path_database"
                    ],
                    [
                      "variable",
                      "database_id"
                    ],
                    [
                      "variable",
                      "path"
                    ],
                    [
                      "variable",
                      "h5file"
                    ],
                    [
                      "variable",
                      "xdmffile"
                    ],
                    [
                      "variable",
                      "meshes"
                    ],
                    [
                      "variable",
                      "data"
                    ],
                    [
                      "variable",
                      "globals"
                    ],
                    [
                      "variable",
                      "userdata"
                    ],
                    [
                      "variable",
                      "links"
                    ],
                    [
                      "function",
                      "fromUID"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "parameters"
                    ],
                    [
                      "variable",
                      "metadata"
                    ],
                    [
                      "function",
                      "files"
                    ],
                    [
                      "function",
                      "show_files"
                    ],
                    [
                      "function",
                      "open_in_file_explorer"
                    ],
                    [
                      "function",
                      "open_in_paraview"
                    ],
                    [
                      "function",
                      "get_full_uid"
                    ],
                    [
                      "function",
                      "change_status"
                    ],
                    [
                      "function",
                      "update_metadata"
                    ],
                    [
                      "function",
                      "update_parameters"
                    ],
                    [
                      "function",
                      "create_xdmf_file"
                    ],
                    [
                      "function",
                      "create_run_script"
                    ],
                    [
                      "function",
                      "create_batch_script"
                    ],
                    [
                      "function",
                      "submit"
                    ],
                    [
                      "function",
                      "change_note"
                    ],
                    [
                      "function",
                      "open"
                    ],
                    [
                      "variable",
                      "mesh"
                    ],
                    [
                      "function",
                      "get_mesh"
                    ],
                    [
                      "variable",
                      "data_info"
                    ],
                    [
                      "variable",
                      "git"
                    ],
                    [
                      "function",
                      "get_data_interpolator"
                    ],
                    [
                      "function",
                      "show_h5tree"
                    ],
                    [
                      "function",
                      "enter_path"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    uid: str,\n    path: str,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>,\n    create_if_not_exists: bool = False\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "uid": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": "Unique identifier for the simulation"
                  },
                  "path": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": "Path to database"
                  },
                  "comm": {
                    "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x743de48d8890>",
                    "annotation": "<class 'bamboost.common._mock_mpi.MockMPI.Comm'>",
                    "description": "MPI communicator"
                  },
                  "create_if_not_exists": {
                    "default": "False",
                    "annotation": "<class 'bool'>",
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __init__(\n        self,\n        uid: str,\n        path: str,\n        comm: MPI.Comm = MPI.COMM_WORLD,\n        create_if_not_exists: bool = False,\n    ):\n        super().__init__(uid, path, comm)\n",
                  "lines": [
                    37,
                    44
                  ]
                }
              }
            }
          },
          "functions": {},
          "submodules": {}
        },
        "remote_manager": {
          "name": "bamboost.extensions.remote_manager",
          "docstring": "",
          "classes": {
            "Remote": {
              "name": "Remote",
              "short_description": "Access bamboost database of a remote server. The index is fetched using",
              "docstring": "Access bamboost database of a remote server. The index is fetched using\nrsync over ssh. The `remote_name` can be a hostname or an IP address. Make\nsure that ssh keys are set and working, as there is no user authentication.\nThe `skip_update` flag can be set to avoid fetching the index from the\nremote server.",
              "methods": {
                "list": {
                  "docstring": "List all remote servers.",
                  "signature": "(cls) -> <classmethod(<function Remote.list at 0x743de432b740>)>",
                  "returns": {
                    "annotation": "<classmethod(<function Remote.list at 0x743de432b740>)>",
                    "description": null
                  },
                  "arguments": {
                    "cls": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @classmethod\n    def list(cls) -> list:\n        \"\"\"List all remote servers.\"\"\"\n        return [\n            name\n            for name in os.listdir(CACHE_DIR)\n            if os.path.isdir(os.path.join(CACHE_DIR, name))\n        ]\n",
                    "lines": [
                      142,
                      149
                    ]
                  },
                  "props": {
                    "isClassMethod": true
                  },
                  "examples": []
                },
                "__getitem__": {
                  "docstring": "Return a `RemoteManager` for the given id.",
                  "signature": "(self, id: str) -> bamboost.extensions.remote_manager.RemoteManager",
                  "returns": {
                    "annotation": "<class 'bamboost.extensions.remote_manager.RemoteManager'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "id": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def __getitem__(self, id: str) -> RemoteManager:\n        \"\"\"Return a `RemoteManager` for the given id.\"\"\"\n        id = id.split(\" - \")[0]\n        return RemoteManager(id, remote=self)\n",
                    "lines": [
                      158,
                      161
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "fetch_index": {
                  "docstring": "Fetch the index from the remote server.",
                  "signature": "(self) -> subprocess.Popen",
                  "returns": {
                    "annotation": "<class 'subprocess.Popen'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def fetch_index(self) -> subprocess.Popen:\n        \"\"\"Fetch the index from the remote server.\"\"\"\n        return subprocess.Popen(\n            [\"rsync\", \"-av\", f\"{self.remote_name}:{REMOTE_INDEX}\", self.file],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n        )\n",
                    "lines": [
                      163,
                      170
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "get_manager": {
                  "docstring": "",
                  "signature": "(\n    self,\n    id: str,\n    skip_update: bool = False\n) -> bamboost.extensions.remote_manager.RemoteManager",
                  "returns": {
                    "annotation": "<class 'bamboost.extensions.remote_manager.RemoteManager'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "id": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": null
                    },
                    "skip_update": {
                      "default": "False",
                      "annotation": "<class 'bool'>",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def get_manager(self, id: str, skip_update: bool = False) -> RemoteManager:\n        return RemoteManager(id, remote=self, skip_update=skip_update)\n",
                    "lines": [
                      172,
                      173
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "get_path": {
                  "docstring": "Get the path of a database from its ID.\n",
                  "signature": "(self, id: str) -> str",
                  "returns": {
                    "annotation": "<class 'str'>",
                    "description": "path of the database"
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "id": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": "ID of the database"
                    }
                  },
                  "source": {
                    "code": "    @with_connection\n    def get_path(self, id: str) -> str:\n        self._cursor.execute(\"SELECT path FROM dbindex WHERE id=?\", (id,))\n        fetch = self._cursor.fetchone()\n        if fetch is None:\n            raise KeyError(f\"No database found with id: {id}\")\n        else:\n            return fetch[0]\n",
                    "lines": [
                      175,
                      182
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "insert_local_path": {
                  "docstring": "",
                  "signature": "(self, id: str, path: str) -> None",
                  "returns": {
                    "annotation": "None",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "id": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": null
                    },
                    "path": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    @with_connection\n    def insert_local_path(self, id: str, path: str) -> None:\n        try:\n            self._cursor.execute(\n                \"UPDATE dbindex SET local_path=? WHERE id=?\", (path, id)\n            )\n        except sqlite3.OperationalError:\n            self._cursor.execute(\n                \"ALTER TABLE dbindex ADD COLUMN local_path TEXT DEFAULT NULL\"\n            )\n            self._cursor.execute(\n                \"UPDATE dbindex SET local_path=? WHERE id=?\", (path, id)\n            )\n",
                    "lines": [
                      184,
                      196
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {
                "remote_name": {
                  "annotation": "",
                  "description": null
                },
                "local_path": {
                  "annotation": "",
                  "description": null
                },
                "file": {
                  "annotation": "",
                  "description": null
                }
              },
              "inherits_from": {
                "IndexAPI": {
                  "module": "bamboost.index",
                  "members": [
                    [
                      "function",
                      "ThreadSafe"
                    ],
                    [
                      "function",
                      "create_index_table"
                    ],
                    [
                      "function",
                      "get_database_table"
                    ],
                    [
                      "function",
                      "read_table"
                    ],
                    [
                      "function",
                      "fetch"
                    ],
                    [
                      "function",
                      "insert_path"
                    ],
                    [
                      "function",
                      "get_id"
                    ],
                    [
                      "function",
                      "scan_known_paths"
                    ],
                    [
                      "function",
                      "commit_once"
                    ],
                    [
                      "function",
                      "clean"
                    ],
                    [
                      "function",
                      "drop_path"
                    ],
                    [
                      "function",
                      "check_path"
                    ]
                  ]
                },
                "SQLiteHandler": {
                  "module": "bamboost._sqlite_database",
                  "members": [
                    [
                      "function",
                      "connect"
                    ],
                    [
                      "function",
                      "close"
                    ],
                    [
                      "function",
                      "commit"
                    ],
                    [
                      "function",
                      "open"
                    ]
                  ]
                }
              },
              "examples": [
                ">>> remote = Remote(\"euler\")\n>>> remote.read_table()\nreturns a pandas DataFrame of the remote index.\n>>> remote[\"<id>\"]\nreturns a RemoteManager object for the given id."
              ],
              "constructor": {
                "signature": "(*args, **kwargs)",
                "arguments": {
                  "cls": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "args": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "kwargs": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __new__(cls, *args, **kwargs):\n        \"\"\"Override the __new__ method to avoid the singleton pattern of IndexAPI.\"\"\"\n        return object.__new__(cls)\n",
                  "lines": [
                    123,
                    125
                  ]
                }
              }
            },
            "RemoteManager": {
              "name": "RemoteManager",
              "short_description": "Manager class with remote functionality. Constructor takes an existing ID",
              "docstring": "Manager class with remote functionality. Constructor takes an existing ID\nof a database on a remote server. The ssh connection must be set up to work\nwithout explicit user authentication. Data is lazily transferred using\nrsync.",
              "methods": {
                "get_view": {
                  "docstring": "View of the database and its parametric space. Read from the sql\ndatabase. If `include_linked_sims` is True, the individual h5 files are\nscanned.",
                  "signature": "(self, include_linked_sims: bool = False) -> pandas.core.frame.DataFrame",
                  "returns": {
                    "annotation": "<class 'pandas.core.frame.DataFrame'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "include_linked_sims": {
                      "default": "False",
                      "annotation": "<class 'bool'>",
                      "description": "if True, include the parameters of linked sims"
                    }
                  },
                  "source": {
                    "code": "    def get_view(self, include_linked_sims: bool = False) -> pd.DataFrame:\n        df = super().get_view(include_linked_sims)\n        df.insert(1, \"cached\", False)\n        for id in os.listdir(self.path):\n            if id in df[\"id\"].values:\n                df.loc[df[\"id\"] == id, \"cached\"] = True\n\n        opts = config.get(\"options\", {})\n        if \"sort_table_key\" in opts:\n            df.sort_values(\n                opts.get(\"sort_table_key\", \"id\"),\n                ascending=opts.get(\"sort_table_order\", \"asc\") == \"asc\",\n                inplace=True,\n            )\n        return df\n",
                    "lines": [
                      274,
                      288
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": [
                    ">>> db.get_view()\n>>> db.get_view(include_linked_sims=True)"
                  ]
                },
                "sim": {
                  "docstring": "Return simulation object.\n",
                  "signature": "(self, uid, return_writer: bool = False)",
                  "returns": {
                    "annotation": "<class 'inspect._empty'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "uid": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "return_writer": {
                      "default": "False",
                      "annotation": "<class 'bool'>",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def sim(self, uid, return_writer: bool = False):\n        \"\"\"Return simulation object.\n\n        Args:\n            - uid (str): the unique id of the sim to be transferred.\n            - return_writer (bool): Flag to indicate whether to return a writer\n              object. Default is False.\n\n        This method checks if the data for the given uid is already in the\n        local cache. If not, it transfers the data from a remote location using\n        rsync. The method then calls the superclass method to perform further\n        operations on the transferred data.\n        \"\"\"\n        # Check if data is already in cache\n        if os.path.exists(f\"{self.path}/{uid}\"):\n            log.info(f\"Data for {uid} already in cache\")\n            return RemoteSimulation(uid, self)\n\n        # Transfer data using rsync\n        log.info(f\"Data not in cache. Transferring data for {uid} from {self.remote}\")\n        self.rsync(uid)\n\n        return RemoteSimulation(uid, self)\n",
                    "lines": [
                      290,
                      312
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "rsync": {
                  "docstring": "Transfer data using rsync.",
                  "signature": "(self, uid: str) -> None",
                  "returns": {
                    "annotation": "None",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    },
                    "uid": {
                      "default": null,
                      "annotation": "<class 'str'>",
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def rsync(self, uid: str) -> None:\n        \"\"\"Transfer data using rsync.\"\"\"\n        subprocess.call(\n            [\n                \"rsync\",\n                \"-r\",\n                f\"{self.remote.remote_name}:{self.remote_path_db}/{uid}\",\n                f\"{self.path}\",\n            ],\n            stdout=subprocess.PIPE,\n        )\n        log.info(f\"Data for {uid} synced with {self.path}\")\n",
                    "lines": [
                      314,
                      325
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {
                "UID": {
                  "annotation": "",
                  "description": null
                },
                "remote": {
                  "annotation": "",
                  "description": null
                },
                "comm": {
                  "annotation": "",
                  "description": null
                },
                "path": {
                  "annotation": "",
                  "description": null
                },
                "remote_path_db": {
                  "annotation": "",
                  "description": null
                }
              },
              "inherits_from": {
                "Manager": {
                  "module": "bamboost.manager",
                  "members": [
                    [
                      "variable",
                      "FIX_DF"
                    ],
                    [
                      "variable",
                      "fromUID"
                    ],
                    [
                      "variable",
                      "fromName"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "function",
                      "__len__"
                    ],
                    [
                      "function",
                      "__iter__"
                    ],
                    [
                      "variable",
                      "all_uids"
                    ],
                    [
                      "variable",
                      "df"
                    ],
                    [
                      "function",
                      "get_view_from_hdf_files"
                    ],
                    [
                      "variable",
                      "data_info"
                    ],
                    [
                      "function",
                      "sims"
                    ],
                    [
                      "function",
                      "create_simulation"
                    ],
                    [
                      "function",
                      "remove"
                    ],
                    [
                      "function",
                      "find"
                    ],
                    [
                      "function",
                      "global_fields_in_all"
                    ],
                    [
                      "function",
                      "get_parameters"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(\n    id: str,\n    remote: bamboost.extensions.remote_manager.Remote,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>\n)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "id": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": null
                  },
                  "remote": {
                    "default": null,
                    "annotation": "<class 'bamboost.extensions.remote_manager.Remote'>",
                    "description": null
                  },
                  "comm": {
                    "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x743de48d8890>",
                    "annotation": "<class 'bamboost.common._mock_mpi.MockMPI.Comm'>",
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __init__(\n        self,\n        id: str,\n        remote: Remote,\n        comm: MPI.Comm = MPI.COMM_WORLD,\n    ) -> None:\n        \"\"\"\n        params\n        skip_update: if True, does not lookup the new database on the remote:\n        \"\"\"\n        self.UID = id\n        self.remote = remote\n        self.comm = comm\n        self.path = os.path.join(self.remote.local_path, self.UID)\n        log.info(f\"Creating cache directory at {self.path}\")\n        os.makedirs(self.path, exist_ok=True)\n\n        self.remote_path_db = self._index.get_path(self.UID)\n\n        # check if path exists\n        if not os.path.isdir(self.path):\n            os.makedirs(self.path)\n\n        # Write the database ID file if it does not exist\n        if not os.path.exists(f\"{self.path}/.BAMBOOST-{self.UID}\"):\n            with open(f\"{self.path}/.BAMBOOST-{self.UID}\", \"w\") as f:\n                f.write(self.UID)\n\n        self.UID = id\n        self._index.insert_local_path(self.UID, self.path)\n\n        # Update the SQL table for the database\n        with self._index.open():\n            self._table.create_database_table()\n            # self._table.sync()\n",
                  "lines": [
                    216,
                    250
                  ]
                }
              }
            },
            "RemoteSimulation": {
              "name": "RemoteSimulation",
              "short_description": "A single dataset/simulation. Used to write to it, read from it or append.",
              "docstring": "A single dataset/simulation. Used to write to it, read from it or append.\n",
              "methods": {
                "sync": {
                  "docstring": "Sync the simulation data with the remote server.",
                  "signature": "(self) -> bamboost.extensions.remote_manager.RemoteSimulation",
                  "returns": {
                    "annotation": "<class 'bamboost.extensions.remote_manager.RemoteSimulation'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def sync(self) -> RemoteSimulation:\n        \"\"\"Sync the simulation data with the remote server.\"\"\"\n        self.manager.rsync(self.uid)\n        return self\n",
                    "lines": [
                      333,
                      336
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                },
                "get_full_uid": {
                  "docstring": "Returns the full uid of the simulation (including the one of the database)",
                  "signature": "(self) -> str",
                  "returns": {
                    "annotation": "<class 'str'>",
                    "description": null
                  },
                  "arguments": {
                    "self": {
                      "default": null,
                      "annotation": null,
                      "description": null
                    }
                  },
                  "source": {
                    "code": "    def get_full_uid(self) -> str:\n        return f\"ssh://{self.manager.remote.remote_name}/{self.manager.UID}:{self.uid}\"\n",
                    "lines": [
                      338,
                      339
                    ]
                  },
                  "props": {
                    "isClassMethod": false
                  },
                  "examples": []
                }
              },
              "variables": {
                "manager": {
                  "annotation": "",
                  "description": null
                }
              },
              "inherits_from": {
                "Simulation": {
                  "module": "bamboost.simulation",
                  "members": [
                    [
                      "variable",
                      "uid"
                    ],
                    [
                      "variable",
                      "path_database"
                    ],
                    [
                      "variable",
                      "database_id"
                    ],
                    [
                      "variable",
                      "path"
                    ],
                    [
                      "variable",
                      "h5file"
                    ],
                    [
                      "variable",
                      "xdmffile"
                    ],
                    [
                      "variable",
                      "meshes"
                    ],
                    [
                      "variable",
                      "data"
                    ],
                    [
                      "variable",
                      "globals"
                    ],
                    [
                      "variable",
                      "userdata"
                    ],
                    [
                      "variable",
                      "links"
                    ],
                    [
                      "function",
                      "fromUID"
                    ],
                    [
                      "function",
                      "__getitem__"
                    ],
                    [
                      "variable",
                      "parameters"
                    ],
                    [
                      "variable",
                      "metadata"
                    ],
                    [
                      "function",
                      "files"
                    ],
                    [
                      "function",
                      "show_files"
                    ],
                    [
                      "function",
                      "open_in_file_explorer"
                    ],
                    [
                      "function",
                      "open_in_paraview"
                    ],
                    [
                      "function",
                      "change_status"
                    ],
                    [
                      "function",
                      "update_metadata"
                    ],
                    [
                      "function",
                      "update_parameters"
                    ],
                    [
                      "function",
                      "create_xdmf_file"
                    ],
                    [
                      "function",
                      "create_run_script"
                    ],
                    [
                      "function",
                      "create_batch_script"
                    ],
                    [
                      "function",
                      "submit"
                    ],
                    [
                      "function",
                      "change_note"
                    ],
                    [
                      "function",
                      "open"
                    ],
                    [
                      "variable",
                      "mesh"
                    ],
                    [
                      "function",
                      "get_mesh"
                    ],
                    [
                      "variable",
                      "data_info"
                    ],
                    [
                      "variable",
                      "git"
                    ],
                    [
                      "function",
                      "get_data_interpolator"
                    ],
                    [
                      "function",
                      "show_h5tree"
                    ],
                    [
                      "function",
                      "enter_path"
                    ]
                  ]
                }
              },
              "examples": [],
              "constructor": {
                "signature": "(uid: str, manager: bamboost.extensions.remote_manager.RemoteManager)",
                "arguments": {
                  "self": {
                    "default": null,
                    "annotation": null,
                    "description": null
                  },
                  "uid": {
                    "default": null,
                    "annotation": "<class 'str'>",
                    "description": "unique identifier"
                  },
                  "manager": {
                    "default": null,
                    "annotation": "<class 'bamboost.extensions.remote_manager.RemoteManager'>",
                    "description": null
                  }
                },
                "source": {
                  "code": "    def __init__(self, uid: str, manager: RemoteManager) -> None:\n        super().__init__(uid, manager.path, _db_id=manager.UID)\n        self.manager = manager\n",
                  "lines": [
                    329,
                    331
                  ]
                }
              }
            }
          },
          "functions": {},
          "submodules": {}
        },
        "slurm": {
          "name": "bamboost.extensions.slurm",
          "docstring": "",
          "classes": {},
          "functions": {
            "install": {
              "docstring": "Install the slurm extension to the SimulationWriter class. Extends the\n__exit__ method to add slurm metadata.",
              "signature": "()",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {},
              "source": {
                "code": "def install():\n    \"\"\"Install the slurm extension to the SimulationWriter class. Extends the\n    __exit__ method to add slurm metadata.\n    \"\"\"\n    SimulationWriter.__exit__ = _extend_exit_slurm_info(SimulationWriter.__exit__)\n    SimulationWriter.__enter__ = _extend_enter_slurm_info(SimulationWriter.__enter__)\n",
                "lines": [
                  67,
                  72
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "submodules": {}
        }
      }
    },
    "index": {
      "name": "bamboost.index",
      "docstring": "Module to manage the database index and its ID's.",
      "classes": {
        "Null": {
          "name": "Null",
          "short_description": "Null object to replace API classes for off-root processes.",
          "docstring": "Null object to replace API classes for off-root processes.",
          "methods": {
            "__getitem__": {
              "docstring": "",
              "signature": "(self, _)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "_": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def __getitem__(self, _):\n        return self\n",
                "lines": [
                  78,
                  79
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {},
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "()",
            "arguments": {},
            "source": {
              "code": "",
              "lines": null
            }
          }
        },
        "IndexAPI": {
          "name": "IndexAPI",
          "short_description": "SQLite database to store database ID, path lookup. As well as the table for",
          "docstring": "SQLite database to store database ID, path lookup. As well as the table for\neach database. Location: ~/.local/share/bamboost\nSingleton pattern.",
          "methods": {
            "ThreadSafe": {
              "docstring": "",
              "signature": "(cls, *, _file: str = None) -> bamboost.index.IndexAPI",
              "returns": {
                "annotation": "<class 'bamboost.index.IndexAPI'>",
                "description": null
              },
              "arguments": {
                "cls": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "_file": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    @classmethod\n    def ThreadSafe(cls, *, _file: str = None) -> IndexAPI:\n        instance = super().__new__(cls)\n        instance.__init__(_file=_file)\n        return instance\n",
                "lines": [
                  119,
                  123
                ]
              },
              "props": {
                "isClassMethod": true
              },
              "examples": []
            },
            "__getitem__": {
              "docstring": "",
              "signature": "(self, id: str) -> bamboost.index.DatabaseTable",
              "returns": {
                "annotation": "<class 'bamboost.index.DatabaseTable'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def __getitem__(self, id: str) -> DatabaseTable:\n        return DatabaseTable(id, _index=self)\n",
                "lines": [
                  131,
                  132
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_index_table": {
              "docstring": "Create the index table if it does not exist.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def create_index_table(self) -> None:\n        \"\"\"Create the index table if it does not exist.\"\"\"\n        self._cursor.execute(\n            \"\"\"CREATE TABLE IF NOT EXISTS dbindex (id TEXT PRIMARY KEY, path TEXT)\"\"\"\n        )\n",
                "lines": [
                  137,
                  142
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_database_table": {
              "docstring": "Get the table of a database.\n",
              "signature": "(self, id: str) -> bamboost.index.DatabaseTable",
              "returns": {
                "annotation": "<class 'bamboost.index.DatabaseTable'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def get_database_table(self, id: str) -> DatabaseTable:\n        \"\"\"Get the table of a database.\n\n        Args:\n            - id (str): ID of the database\n        \"\"\"\n        return DatabaseTable(id, _index=self)\n",
                "lines": [
                  144,
                  150
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "read_table": {
              "docstring": "Read the index table.\n",
              "signature": "(self, *args, **kwargs) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "<class 'pandas.core.frame.DataFrame'>",
                "description": "index table"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "args": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "kwargs": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def read_table(self, *args, **kwargs) -> pd.DataFrame:\n        \"\"\"Read the index table.\n\n        Returns:\n            pd.DataFrame: index table\n        \"\"\"\n        return pd.read_sql_query(\"SELECT * FROM dbindex\", self._conn, *args, **kwargs)\n",
                "lines": [
                  152,
                  159
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "fetch": {
              "docstring": "Query the index table.\n",
              "signature": "(self, query: str, *args, **kwargs) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "<class 'pandas.core.frame.DataFrame'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "query": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "query string"
                },
                "args": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "kwargs": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def fetch(self, query: str, *args, **kwargs) -> pd.DataFrame:\n        \"\"\"Query the index table.\n\n        Args:\n            query (str): query string\n        \"\"\"\n        self._cursor.execute(query, *args, **kwargs)\n        return self._cursor.fetchall()\n",
                "lines": [
                  161,
                  169
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_path": {
              "docstring": "Get the path of a database from its ID.\n",
              "signature": "(self, id: str) -> str",
              "returns": {
                "annotation": "<class 'str'>",
                "description": "path of the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "ID of the database"
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def get_path(self, id: str) -> str:\n        \"\"\"Get the path of a database from its ID.\n\n        Args:\n            id (str): ID of the database\n\n        Returns:\n            str: path of the database\n        \"\"\"\n        self._cursor.execute(\"SELECT path FROM dbindex WHERE id=?\", (id,))\n        path_db = self._cursor.fetchone()\n        if path_db and _check_path(id, path_db[0]):\n            return path_db[0]\n\n        # if path is wrong, try to find it\n        for root_dir in get_known_paths():\n            res = find(id, root_dir)\n            if res:\n                path = os.path.dirname(res[0])\n                self.insert_path(id, path)\n                return path\n\n        # last resort, check home\n        res = find(id, paths[\"HOME\"])\n        if res:\n            path = os.path.dirname(res[0])\n            self.insert_path(id, path)\n            return path\n\n        raise FileNotFoundError(f\"Database {id} not found on system.\")\n",
                "lines": [
                  171,
                  201
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "insert_path": {
              "docstring": "Insert a database path into the index.\n",
              "signature": "(self, id: str, path: str) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "ID of the database"
                },
                "path": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "path of the database"
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def insert_path(self, id: str, path: str) -> None:\n        \"\"\"Insert a database path into the index.\n\n        Args:\n            id (str): ID of the database\n            path (str): path of the database\n        \"\"\"\n        path = os.path.abspath(path)\n        self._cursor.execute(\"INSERT OR REPLACE INTO dbindex VALUES (?, ?)\", (id, path))\n",
                "lines": [
                  203,
                  212
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_id": {
              "docstring": "Get the ID of a database from its path.\n",
              "signature": "(self, path: str) -> str",
              "returns": {
                "annotation": "<class 'str'>",
                "description": "ID of the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "path": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "path of the database"
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def get_id(self, path: str) -> str:\n        \"\"\"Get the ID of a database from its path.\n\n        Args:\n            path (str): path of the database\n\n        Returns:\n            str: ID of the database\n\n        Raises:\n            DatabaseNotFoundError: if the database is not found in the index\n        \"\"\"\n        path = os.path.abspath(path)\n        self._cursor.execute(\"SELECT id FROM dbindex WHERE path=?\", (path,))\n        fetched = self._cursor.fetchone()\n        if fetched is None:\n            raise DatabaseNotFoundError(f\"Database at {path} not found in index.\")\n        return fetched[0]\n",
                "lines": [
                  214,
                  232
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "scan_known_paths": {
              "docstring": "Scan known paths for databases and update the index.",
              "signature": "(self) -> dict",
              "returns": {
                "annotation": "<class 'dict'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def scan_known_paths(self) -> dict:\n        \"\"\"Scan known paths for databases and update the index.\"\"\"\n        for path in get_known_paths():\n            completed_process = subprocess.run(\n                [\"find\", path, \"-iname\", f\"{PREFIX}*\", \"-not\", \"-path\", r\"*/\\.git/*\"],\n                capture_output=True,\n            )\n            databases_found = completed_process.stdout.decode(\"utf-8\").splitlines()\n            for database in databases_found:\n                name = os.path.basename(database)\n                id = name.split(\"-\")[1]\n                self.insert_path(id, os.path.dirname(database))\n",
                "lines": [
                  234,
                  246
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "commit_once": {
              "docstring": "Decorator to bundle changes to a single commit.\n",
              "signature": "(self, func) -> Callable",
              "returns": {
                "annotation": "typing.Callable",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "func": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def commit_once(self, func) -> Callable:\n        \"\"\"Decorator to bundle changes to a single commit.\n\n        Example:\n            >>> @Index.commit_once\n            >>> def create_a_bunch_of_simulations():\n            >>>     for i in range(1000):\n            >>>         db.create_simulation(parameters={...})\n            >>>\n            >>> create_a_bunch_of_simulations()\n        \"\"\"\n\n        def wrapper(*args, **kwargs):\n            with self.open(ensure_commit=True):\n                return func(*args, **kwargs)\n\n        return wrapper\n",
                "lines": [
                  248,
                  264
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> @Index.commit_once\n>>> def create_a_bunch_of_simulations():\n>>>     for i in range(1000):\n>>>         db.create_simulation(parameters={...})\n>>>\n>>> create_a_bunch_of_simulations()"
              ]
            },
            "clean": {
              "docstring": "Clean the index from wrong paths.\n",
              "signature": "(self, purge: bool = False) -> bamboost.index.IndexAPI",
              "returns": {
                "annotation": "<class 'bamboost.index.IndexAPI'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "purge": {
                  "default": "False",
                  "annotation": "<class 'bool'>",
                  "description": "Also deletes the table of unmatching uid/path pairs. Defaults to False."
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def clean(self, purge: bool = False) -> IndexAPI:\n        \"\"\"Clean the index from wrong paths.\n\n        Args:\n            purge (bool, optional): Also deletes the table of unmatching uid/path pairs. Defaults to False.\n        \"\"\"\n        index = self._cursor.execute(\"SELECT id, path FROM dbindex\").fetchall()\n        for id, path in index:\n            if not _check_path(id, path):\n                self._cursor.execute(\"DELETE FROM dbindex WHERE id=?\", (id,))\n\n        if purge:\n            # all tables starting with db_ are tables of databases\n            all_tables = self._cursor.execute(\n                \"SELECT name FROM sqlite_master WHERE type='table'\"\n            ).fetchall()\n            id_list_tables = {\n                i[0].split(\"_\")[1] for i in all_tables if i[0].startswith(\"db_\")\n            }\n            id_list = self._cursor.execute(\"SELECT id FROM dbindex\").fetchall()\n\n            for id in id_list_tables:\n                if id not in id_list:\n                    self._cursor.execute(f\"DROP TABLE db_{id}\")\n                    self._cursor.execute(f\"DROP TABLE db_{id}_t\")\n\n        return self\n",
                "lines": [
                  266,
                  293
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "drop_path": {
              "docstring": "Drop a path from the index.\n",
              "signature": "(self, id: str) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "ID of the database"
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def drop_path(self, id: str) -> None:\n        \"\"\"Drop a path from the index.\n\n        Args:\n            id (str): ID of the database\n        \"\"\"\n        self._cursor.execute(\"DELETE FROM dbindex WHERE id=?\", (id,))\n",
                "lines": [
                  295,
                  302
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "check_path": {
              "docstring": "Check if path is going to the correct database.",
              "signature": "(self, id: str, path: str) -> bool",
              "returns": {
                "annotation": "<class 'bool'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "id": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                },
                "path": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def check_path(self, id: str, path: str) -> bool:\n        \"\"\"Check if path is going to the correct database.\"\"\"\n        return _check_path(id, path)\n",
                "lines": [
                  304,
                  306
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {},
          "inherits_from": {
            "SQLiteHandler": {
              "module": "bamboost._sqlite_database",
              "members": [
                [
                  "variable",
                  "file"
                ],
                [
                  "function",
                  "connect"
                ],
                [
                  "function",
                  "close"
                ],
                [
                  "function",
                  "commit"
                ],
                [
                  "function",
                  "open"
                ]
              ]
            }
          },
          "examples": [],
          "constructor": {
            "signature": "(*, _file: str = None)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "_file": {
                "default": "None",
                "annotation": "<class 'str'>",
                "description": null
              }
            },
            "source": {
              "code": "    def __init__(self, *, _file: str = None):\n        if hasattr(self, \"_initialized\"):\n            return\n        _file = _file or paths[\"DATABASE_FILE\"]\n        super().__init__(file=_file)\n        self.create_index_table()\n        self.clean()\n        self._initialized = True\n",
              "lines": [
                110,
                117
              ]
            }
          }
        },
        "DatabaseTable": {
          "name": "DatabaseTable",
          "short_description": "Class to manage the table of a database. Multiton pattern. One table per",
          "docstring": "Class to manage the table of a database. Multiton pattern. One table per\ndatabase.",
          "methods": {
            "read_table": {
              "docstring": "Read the table of the database.\n",
              "signature": "(self) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "<class 'pandas.core.frame.DataFrame'>",
                "description": "table of the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def read_table(self) -> pd.DataFrame:\n        \"\"\"Read the table of the database.\n\n        Returns:\n            pd.DataFrame: table of the database\n        \"\"\"\n        df = pd.read_sql_query(f\"SELECT * FROM {self.tablename_db}\", self._conn)\n        # drop \"hidden\" columns which start with _\n        df = df.loc[:, ~df.columns.str.startswith(\"_\")]\n        df.rename(columns=lambda x: x.replace(DOT_REPLACEMENT, \".\"), inplace=True)\n        return df\n",
                "lines": [
                  354,
                  365
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "read_entry": {
              "docstring": "Read an entry from the database.\n",
              "signature": "(self, entry_id: str) -> pandas.core.series.Series",
              "returns": {
                "annotation": "<class 'pandas.core.series.Series'>",
                "description": "entry from the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "entry_id": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "ID of the entry"
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def read_entry(self, entry_id: str) -> pd.Series:\n        \"\"\"Read an entry from the database.\n\n        Args:\n            entry_id (str): ID of the entry\n\n        Returns:\n            pd.Series: entry from the database\n        \"\"\"\n        self._cursor.execute(\n            f\"SELECT * FROM {self.tablename_db} WHERE id=?\", (entry_id,)\n        )\n        series = pd.Series(*self._cursor.fetchall())\n        series.index = [description[0] for description in self._cursor.description]\n        series.rename(index=lambda x: x.replace(DOT_REPLACEMENT, \".\"), inplace=True)\n        return series\n",
                "lines": [
                  367,
                  383
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "read_column": {
              "docstring": "Read columns from the database.\n",
              "signature": "(self, *columns: str) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "<class 'pandas.core.frame.DataFrame'>",
                "description": "columns from the database"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "columns": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def read_column(self, *columns: str) -> pd.DataFrame:\n        \"\"\"Read columns from the database.\n\n        Args:\n            *columns (list): columns to read\n\n        Returns:\n            pd.DataFrame: columns from the database\n        \"\"\"\n        self._cursor.execute(f\"SELECT {', '.join(columns)} FROM {self.tablename_db}\")\n        df = pd.DataFrame.from_records(self._cursor.fetchall(), columns=columns)\n        df.rename(columns=lambda x: x.replace(DOT_REPLACEMENT, \".\"), inplace=True)\n        return df\n",
                "lines": [
                  385,
                  398
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "drop_table": {
              "docstring": "Drop the table of the database.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def drop_table(self) -> None:\n        \"\"\"Drop the table of the database.\"\"\"\n        self._cursor.execute(f\"DROP TABLE {self.tablename_db}\")\n        self._cursor.execute(f\"DROP TABLE {self.tablename_update_times}\")\n",
                "lines": [
                  400,
                  404
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_database_table": {
              "docstring": "Create a table for a database.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def create_database_table(self) -> None:\n        \"\"\"Create a table for a database.\"\"\"\n        self._cursor.execute(\n            f\"\"\"CREATE TABLE IF NOT EXISTS {self.tablename_db} \n                (id TEXT PRIMARY KEY NOT NULL, time_stamp DATETIME, notes TEXT, processors INTEGER)\n            \"\"\"\n        )\n        self._cursor.execute(\n            f\"\"\"CREATE TABLE IF NOT EXISTS {self.tablename_update_times} (id TEXT PRIMARY KEY,\n                update_time DATETIME)\n            \"\"\"\n        )\n",
                "lines": [
                  406,
                  418
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "update_entry": {
              "docstring": "Update an entry in the database.\n",
              "signature": "(self, entry_id: str, data: dict) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "entry_id": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "ID of the entry"
                },
                "data": {
                  "default": null,
                  "annotation": "<class 'dict'>",
                  "description": "data to update"
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def update_entry(self, entry_id: str, data: dict) -> None:\n        \"\"\"Update an entry in the database.\n\n        Args:\n            entry_id (str): ID of the entry\n            data (dict): data to update\n        \"\"\"\n        # return if data is empty\n        if not data:\n            return\n\n        # get columns of table\n        self._cursor.execute(f\"PRAGMA table_info({self.tablename_db})\")\n        cols = self._cursor.fetchall()\n\n        # replace dots in keys\n        for key in list(data.keys()):\n            new_key = key.replace(\".\", DOT_REPLACEMENT)\n            new_key = _remove_illegal_column_characters(new_key)\n            if new_key != key:\n                data[new_key] = data.pop(key)\n\n        # check if columns exist\n        for key, val in data.items():\n            # key = key.replace(\".\", DOT_REPLACEMENT)\n            # key = _remove_illegal_column_characters(key)\n            if any(key == column[1] for column in cols):\n                continue\n            dtype = sql.get_sqlite_column_type(val)\n            self._cursor.execute(\n                f\"ALTER TABLE {self.tablename_db} ADD COLUMN [{key}] {dtype}\"\n            )\n\n        # insert data into table\n        data.pop(\"id\", None)\n\n        keys = \", \".join([f\"[{key}]\" for key in data.keys()])\n        values = \", \".join([f\":{key}\" for key in data.keys()])\n        updates = \", \".join([f\"[{key}] = excluded.[{key}]\" for key in data.keys()])\n\n        query = f\"\"\"\n        INSERT INTO {self.tablename_db} (id, {keys})\n        VALUES (:id, {values})\n        ON CONFLICT(id) DO UPDATE SET\n        {updates}\n        \"\"\"\n        data[\"id\"] = entry_id\n        self._cursor.execute(query, data)\n\n        # update update time\n        self._cursor.execute(\n            f\"INSERT OR REPLACE INTO {self.tablename_update_times} VALUES (?, ?)\",\n            (entry_id, time()),\n        )\n",
                "lines": [
                  420,
                  474
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "sync": {
              "docstring": "Sync the table with the file system.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def sync(self) -> None:\n        \"\"\"Sync the table with the file system.\"\"\"\n        all_ids_fs = set(\n            [\n                i\n                for i in os.listdir(self.path)\n                if os.path.isdir(os.path.join(self.path, i))\n            ]\n        )\n\n        self._cursor.execute(\n            f\"SELECT id, update_time FROM {self.tablename_update_times}\"\n        )\n\n        for id, last_up_time in self._cursor.fetchall():\n            # remove entries that do not exist on the file system\n            if id not in all_ids_fs:\n                self._cursor.execute(\n                    f\"DELETE FROM {self.tablename_db} WHERE id=?\", (id,)\n                )\n                self._cursor.execute(\n                    f\"DELETE FROM {self.tablename_update_times} WHERE id=?\", (id,)\n                )\n                continue\n\n            # update entries that have been modified\n            all_ids_fs.remove(id)\n            if self.entry(id).mtime > last_up_time:\n                self.update_entry(id, self.entry(id).get_all_metadata())\n\n        # add new entries\n        for id in all_ids_fs:\n            self.update_entry(id, self.entry(id).get_all_metadata())\n",
                "lines": [
                  476,
                  509
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "entry": {
              "docstring": "Get the Entry object of an entry.\nMultiton pattern. One Entry per entry.",
              "signature": "(self, entry_id: str) -> bamboost.index.Entry",
              "returns": {
                "annotation": "<class 'bamboost.index.Entry'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "entry_id": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    @sql.with_connection\n    def entry(self, entry_id: str) -> Entry:\n        \"\"\"Get the Entry object of an entry.\n        Multiton pattern. One Entry per entry.\n        \"\"\"\n        if entry_id not in self._entries:\n            self._entries[entry_id] = Entry(entry_id, self.path)\n        return self._entries[entry_id]\n",
                "lines": [
                  511,
                  518
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {
            "id": {
              "annotation": "",
              "description": null
            },
            "path": {
              "annotation": "",
              "description": null
            },
            "tablename_db": {
              "annotation": "",
              "description": null
            },
            "tablename_update_times": {
              "annotation": "",
              "description": null
            }
          },
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(id: str, *, _index: bamboost.index.IndexAPI = None)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "id": {
                "default": null,
                "annotation": "<class 'str'>",
                "description": null
              },
              "_index": {
                "default": "None",
                "annotation": "<class 'bamboost.index.IndexAPI'>",
                "description": null
              }
            },
            "source": {
              "code": "    def __init__(self, id: str, *, _index: IndexAPI = None):\n        if hasattr(self, \"_initialized\"):\n            return\n\n        self.id = id\n        self._entries = {}\n        self._initialized = True\n        self._index = _index if _index is not None else IndexAPI()\n        self.path = self._index.get_path(self.id)\n        self.tablename_db = f\"db_{self.id}\"\n        self.tablename_update_times = f\"db_{self.id}_t\"\n        self.create_database_table()\n",
              "lines": [
                325,
                336
              ]
            }
          }
        },
        "Entry": {
          "name": "Entry",
          "short_description": "Simulation entry in a database.",
          "docstring": "Simulation entry in a database.\nSimplified version of the Simulation class in the simulation module.",
          "methods": {
            "get_all_metadata": {
              "docstring": "Get all metadata of the entry.",
              "signature": "(self) -> dict",
              "returns": {
                "annotation": "<class 'dict'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def get_all_metadata(self) -> dict:\n        \"\"\"Get all metadata of the entry.\"\"\"\n        return {**self.metadata, **self.parameters}\n",
                "lines": [
                  552,
                  554
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {
            "id": {
              "annotation": "",
              "description": null
            },
            "path": {
              "annotation": "",
              "description": null
            },
            "h5file": {
              "annotation": "",
              "description": null
            },
            "metadata": {
              "annotation": ": dict",
              "description": "Get the metadata of the entry."
            },
            "parameters": {
              "annotation": ": dict",
              "description": "Get the parameters of the entry."
            },
            "mtime": {
              "annotation": ": float",
              "description": "Get the modification time of the entry."
            }
          },
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(id: str, path: str)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "id": {
                "default": null,
                "annotation": "<class 'str'>",
                "description": null
              },
              "path": {
                "default": null,
                "annotation": "<class 'str'>",
                "description": null
              }
            },
            "source": {
              "code": "    def __init__(self, id: str, path: str) -> None:\n        self.id = id\n        self.path = path\n        self.h5file = os.path.join(self.path, self.id, f\"{self.id}.h5\")\n",
              "lines": [
                527,
                530
              ]
            }
          }
        }
      },
      "functions": {
        "find": {
          "docstring": "Find the database with UID under given root_dir.\n",
          "signature": "(uid, root_dir) -> list",
          "returns": {
            "annotation": "<class 'list'>",
            "description": null
          },
          "arguments": {
            "uid": {
              "default": null,
              "annotation": null,
              "description": "UID to search for"
            },
            "root_dir": {
              "default": null,
              "annotation": null,
              "description": "root directory for search"
            }
          },
          "source": {
            "code": "def find(uid, root_dir) -> list:\n    \"\"\"Find the database with UID under given root_dir.\n\n    Args:\n        uid: UID to search for\n        root_dir: root directory for search\n    \"\"\"\n    if os.name == \"posix\":\n        paths = _find_posix(uid, root_dir)\n    else:\n        paths = _find_python(uid, root_dir)\n    if len(paths) > 1:\n        log.warning(f\"Multiple paths found for UID {uid}:\\n{paths}\")\n    return paths\n",
            "lines": [
              567,
              580
            ]
          },
          "props": {
            "isClassMethod": false
          },
          "examples": []
        },
        "get_uid_from_path": {
          "docstring": "Returns the UID found in the specified path.",
          "signature": "(path: str) -> str",
          "returns": {
            "annotation": "<class 'str'>",
            "description": null
          },
          "arguments": {
            "path": {
              "default": null,
              "annotation": "<class 'str'>",
              "description": null
            }
          },
          "source": {
            "code": "def get_uid_from_path(path: str) -> str:\n    \"\"\"Returns the UID found in the specified path.\"\"\"\n    for file in os.listdir(path):\n        if file.startswith(\".BAMBOOST\"):\n            return file.split(\"-\")[1]\n    raise FileNotFoundError(\"No UID file found at specified path.\")\n",
            "lines": [
              583,
              588
            ]
          },
          "props": {
            "isClassMethod": false
          },
          "examples": []
        },
        "get_known_paths": {
          "docstring": "",
          "signature": "() -> list",
          "returns": {
            "annotation": "<class 'list'>",
            "description": null
          },
          "arguments": {},
          "source": {
            "code": "def get_known_paths() -> list:\n    return config[\"index\"].get(\"paths\", [])\n",
            "lines": [
              591,
              592
            ]
          },
          "props": {
            "isClassMethod": false
          },
          "examples": []
        }
      },
      "submodules": {}
    },
    "manager": {
      "name": "bamboost.manager",
      "docstring": "",
      "classes": {
        "Manager": {
          "name": "Manager",
          "short_description": "View of database.",
          "docstring": "View of database.\n",
          "methods": {
            "__getitem__": {
              "docstring": "Returns the simulation in the specified row of the dataframe.\n",
              "signature": "(self, key: Union[str, int]) -> bamboost.simulation.Simulation",
              "returns": {
                "annotation": "<class 'bamboost.simulation.Simulation'>",
                "description": "The selected simulation object."
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": "typing.Union[str, int]",
                  "description": "The simulation identifier (`str`) or the row index (`int`)."
                }
              },
              "source": {
                "code": "    def __getitem__(self, key: Union[str, int]) -> Simulation:\n        \"\"\"Returns the simulation in the specified row of the dataframe.\n\n        Args:\n            key: The simulation identifier (`str`) or the row index (`int`).\n        Returns:\n            The selected simulation object.\n        \"\"\"\n        if isinstance(key, str):\n            return self.sim(key)\n        else:\n            return self.sim(self.df.loc[key, \"id\"])\n",
                "lines": [
                  136,
                  147
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "__len__": {
              "docstring": "",
              "signature": "(self) -> int",
              "returns": {
                "annotation": "<class 'int'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def __len__(self) -> int:\n        return len(self.all_uids)\n",
                "lines": [
                  162,
                  163
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "__iter__": {
              "docstring": "",
              "signature": "(self) -> Generator[bamboost.simulation.Simulation, NoneType, NoneType]",
              "returns": {
                "annotation": "typing.Generator[bamboost.simulation.Simulation, NoneType, NoneType]",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def __iter__(self) -> Generator[Simulation, None, None]:\n        for sim in self.sims():\n            yield sim\n",
                "lines": [
                  165,
                  167
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_view": {
              "docstring": "View of the database and its parametric space. Read from the sql\ndatabase. If `include_linked_sims` is True, the individual h5 files are\nscanned.",
              "signature": "(self, include_linked_sims: bool = False) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "<class 'pandas.core.frame.DataFrame'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "include_linked_sims": {
                  "default": "False",
                  "annotation": "<class 'bool'>",
                  "description": "if True, include the parameters of linked sims"
                }
              },
              "source": {
                "code": "    def get_view(self, include_linked_sims: bool = False) -> pd.DataFrame:\n        \"\"\"View of the database and its parametric space. Read from the sql\n        database. If `include_linked_sims` is True, the individual h5 files are\n        scanned.\n\n        Args:\n            include_linked_sims: if True, include the parameters of linked sims\n\n        Examples:\n            >>> db.get_view()\n            >>> db.get_view(include_linked_sims=True)\n        \"\"\"\n        if include_linked_sims:\n            return self.get_view_from_hdf_files(include_linked_sims=include_linked_sims)\n\n        try:\n            with self._table.open():\n                self._table.sync()\n                df = self._table.read_table()\n        except index.Error as e:\n            log.warning(f\"index error: {e}\")\n            return self.get_view_from_hdf_files(include_linked_sims=include_linked_sims)\n\n        if df.empty:\n            return df\n        df[\"time_stamp\"] = pd.to_datetime(df[\"time_stamp\"])\n\n        # Sort dataframe columns\n        columns_start = [\"id\", \"notes\", \"status\", \"time_stamp\"]\n        columns_start = [col for col in columns_start if col in df.columns]\n        self._dataframe = df[[*columns_start, *df.columns.difference(columns_start)]]\n\n        opts = config.get(\"options\", {})\n        if \"sort_table_key\" in opts:\n            self._dataframe.sort_values(\n                opts.get(\"sort_table_key\", \"id\"),\n                ascending=opts.get(\"sort_table_order\", \"asc\") == \"asc\",\n                inplace=True,\n            )\n        return self._dataframe\n",
                "lines": [
                  273,
                  312
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> db.get_view()\n>>> db.get_view(include_linked_sims=True)"
              ]
            },
            "get_view_from_hdf_files": {
              "docstring": "View of the database and its parametric space. Read from the h5\nfiles metadata.",
              "signature": "(self, include_linked_sims: bool = False) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "<class 'pandas.core.frame.DataFrame'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "include_linked_sims": {
                  "default": "False",
                  "annotation": "<class 'bool'>",
                  "description": "if True, include the parameters of linked sims"
                }
              },
              "source": {
                "code": "    def get_view_from_hdf_files(\n        self, include_linked_sims: bool = False\n    ) -> pd.DataFrame:\n        \"\"\"View of the database and its parametric space. Read from the h5\n        files metadata.\n\n        Args:\n            include_linked_sims: if True, include the parameters of linked sims\n        \"\"\"\n        all_uids = self._get_uids()\n        data = list()\n\n        for uid in all_uids:\n            tmp_dict = self._get_parameters_for_uid(\n                uid, include_linked_sims=include_linked_sims\n            )\n            data.append(tmp_dict)\n\n        df = pd.DataFrame.from_records(data)\n        if df.empty:\n            return df\n        df[\"time_stamp\"] = pd.to_datetime(df[\"time_stamp\"])\n\n        # Sort dataframe columns\n        columns_start = [\"id\", \"notes\", \"status\", \"time_stamp\"]\n        columns_start = [col for col in columns_start if col in df.columns]\n        self._dataframe = df[[*columns_start, *df.columns.difference(columns_start)]]\n        return self._dataframe\n",
                "lines": [
                  314,
                  341
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "sim": {
              "docstring": "Get an existing simulation with uid. Same as accessing with `db[uid]` directly.\n",
              "signature": "(\n    self,\n    uid: str,\n    return_writer: bool = False,\n    writer_type: bamboost.simulation_writer.SimulationWriter = <class 'bamboost.simulation_writer.SimulationWriter'>\n) -> bamboost.simulation.Simulation",
              "returns": {
                "annotation": "<class 'bamboost.simulation.Simulation'>",
                "description": ":class:`~bamboost.simulation.Simulation`"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "uid": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "unique identifier"
                },
                "return_writer": {
                  "default": "False",
                  "annotation": "<class 'bool'>",
                  "description": "if true, return `SimulationWriter`, otherwise return `Simulation`"
                },
                "writer_type": {
                  "default": "<class 'bamboost.simulation_writer.SimulationWriter'>",
                  "annotation": "<class 'bamboost.simulation_writer.SimulationWriter'>",
                  "description": "Optionally, you can specify a custom writer type to return."
                }
              },
              "source": {
                "code": "    def sim(\n        self,\n        uid: str,\n        return_writer: bool = False,\n        writer_type: SimulationWriter = SimulationWriter,\n    ) -> Simulation:\n        \"\"\"Get an existing simulation with uid. Same as accessing with `db[uid]` directly.\n\n        Args:\n            uid (`str`): unique identifier\n            return_writer: if true, return `SimulationWriter`, otherwise\n                return `Simulation`\n            writer_type: Optionally, you can specify a custom writer type to return.\n\n        Returns:\n            :class:`~bamboost.simulation.Simulation`\n        \"\"\"\n        if return_writer:\n            return writer_type(uid, self.path, self.comm)\n        return Simulation(uid, self.path, self.comm, _db_id=self.UID)\n",
                "lines": [
                  369,
                  388
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "sims": {
              "docstring": "Get all simulations in a list. Optionally, get all simulations matching the\ngiven selection using pandas.",
              "signature": "(\n    self,\n    select: pandas.core.series.Series | pandas.core.frame.DataFrame = None,\n    sort: str = None,\n    reverse: bool = False,\n    exclude: set = None,\n    return_writer: bool = False\n) -> list",
              "returns": {
                "annotation": "<class 'list'>",
                "description": "A list of `:class:~bamboost.simulation.Simulation` objects"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "select": {
                  "default": "None",
                  "annotation": "pandas.core.series.Series | pandas.core.frame.DataFrame",
                  "description": "pandas boolean series or pandas DataFrame (being a subset of the full dataframe)"
                },
                "sort": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": "Optionally sort the list with this keyword"
                },
                "reverse": {
                  "default": "False",
                  "annotation": "<class 'bool'>",
                  "description": "swap sort direction"
                },
                "exclude": {
                  "default": "None",
                  "annotation": "<class 'set'>",
                  "description": "sims to exclude"
                },
                "return_writer": {
                  "default": "False",
                  "annotation": "<class 'bool'>",
                  "description": "if true, return `SimulationWriter`, otherwise return `Simulation`"
                }
              },
              "source": {
                "code": "    def sims(\n        self,\n        select: pd.Series | pd.DataFrame = None,\n        sort: str = None,\n        reverse: bool = False,\n        exclude: set = None,\n        return_writer: bool = False,\n    ) -> list:\n        \"\"\"Get all simulations in a list. Optionally, get all simulations matching the\n        given selection using pandas.\n\n        Args:\n            select (`pd.Series`): pandas boolean series or pandas DataFrame\n                (being a subset of the full dataframe)\n            sort (`str`): Optionally sort the list with this keyword\n            reverse (`bool`): swap sort direction\n            exclude (`list[str]`): sims to exclude\n            return_writer: if true, return `SimulationWriter`, otherwise\n                return `Simulation`\n\n        Returns:\n            A list of `:class:~bamboost.simulation.Simulation` objects\n\n        Examples:\n            >>> db.sims(select=db.df[\"status\"] == \"finished\", sort=\"time_stamp\")\n        \"\"\"\n        if select is None:\n            id_list = self.all_uids\n        elif isinstance(select, pd.DataFrame):\n            id_list = select[\"id\"].values\n        elif isinstance(select, pd.Series):\n            id_list = self.df[select][\"id\"].values\n        else:\n            raise ArgumentError('Invalid argument for argument \"select\"')\n\n        if exclude is not None:\n            exclude = list([exclude]) if isinstance(exclude, str) else exclude\n            id_list = [id for id in id_list if id not in exclude]\n\n        existing_sims = [self.sim(uid, return_writer) for uid in id_list]\n\n        if sort is None:\n            return existing_sims\n        else:\n            return sorted(\n                existing_sims, key=lambda s: s.parameters[sort], reverse=reverse\n            )\n",
                "lines": [
                  390,
                  436
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> db.sims(select=db.df[\"status\"] == \"finished\", sort=\"time_stamp\")"
              ]
            },
            "create_simulation": {
              "docstring": "Get a writer object for a new simulation. This is written for paralell use\nas it is likely that this may be used in an executable, creating multiple runs\nfor a parametric space, which may be run in paralell.",
              "signature": "(\n    self,\n    uid: str = None,\n    parameters: dict = None,\n    skip_duplicate_check: bool = False,\n    prefix: str = None,\n    duplicate_action: str = 'prompt'\n) -> bamboost.simulation_writer.SimulationWriter",
              "returns": {
                "annotation": "<class 'bamboost.simulation_writer.SimulationWriter'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "uid": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": "The name/uid for the simulation. If not specified, a random id will be assigned."
                },
                "parameters": {
                  "default": "None",
                  "annotation": "<class 'dict'>",
                  "description": "Parameter dictionary. If provided, the parameters will be checked against the existing sims for duplication. Otherwise, they may be specified later with :func:`~bamboost.simulation_writer.SimulationWriter.add_parameters`."
                },
                "skip_duplicate_check": {
                  "default": "False",
                  "annotation": "<class 'bool'>",
                  "description": "if True, the duplicate check is skipped."
                },
                "prefix": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": "Prefix for the uid. If not specified, no prefix is used."
                },
                "duplicate_action": {
                  "default": "prompt",
                  "annotation": "<class 'str'>",
                  "description": "how to deal with duplicates. `Replace first duplicate ('r'), Create with altered uid (`c`), Create new with new id (`n`), Abort (`a`) default \"prompt\" for each duplicate on a case by case basis."
                }
              },
              "source": {
                "code": "    def create_simulation(\n        self,\n        uid: str = None,\n        parameters: dict = None,\n        skip_duplicate_check: bool = False,\n        prefix: str = None,\n        duplicate_action: str = \"prompt\",\n    ) -> SimulationWriter:\n        \"\"\"Get a writer object for a new simulation. This is written for paralell use\n        as it is likely that this may be used in an executable, creating multiple runs\n        for a parametric space, which may be run in paralell.\n\n        Args:\n            uid (`str`): The name/uid for the simulation. If not specified, a random id\n                will be assigned.\n            parameters (`dict`): Parameter dictionary. If provided, the parameters will be\n                checked against the existing sims for duplication. Otherwise, they may be\n                specified later with :func:`~bamboost.simulation_writer.SimulationWriter.add_parameters`.\n            skip_duplicate_check (`bool`): if True, the duplicate check is skipped.\n            prefix (`str`): Prefix for the uid. If not specified, no prefix is used.\n            duplicate_action (`str`): how to deal with duplicates.\n                `Replace first duplicate ('r'), Create with altered uid (`c`), Create new with new id (`n`), Abort (`a`)\n                 default \"prompt\" for each duplicate on a case by case basis.\n\n        Examples:\n            >>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})\n\n            >>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")\n        \"\"\"\n        if parameters and not skip_duplicate_check:\n            go_on, uid = self._check_duplicate(\n                parameters, uid, duplicate_action=duplicate_action\n            )\n            if not go_on:\n                print(\"Aborting by user desire...\")\n                return None\n\n        if self.comm.rank == 0:\n            if not uid:\n                uid = uuid.uuid4().hex[:8]  # Assign random unique identifier\n            if isinstance(prefix, str) and prefix != \"\":\n                uid = \"_\".join([prefix, uid])\n        uid = self.comm.bcast(uid, root=0)\n\n        # Create directory and h5 file\n        if self.comm.rank == 0:\n            os.makedirs(os.path.join(self.path, uid), exist_ok=True)\n            path_to_h5_file = os.path.join(self.path, uid, f\"{uid}.h5\")\n            if os.path.exists(path_to_h5_file):\n                os.remove(path_to_h5_file)\n            h5py.File(path_to_h5_file, \"a\").close()  # create file\n\n        new_sim = SimulationWriter(uid, self.path, self.comm)\n        new_sim.initialize()  # sets metadata and status\n        # add the id to the (fixed) _all_uids list\n        if hasattr(self, \"_all_uids\"):\n            self._all_uids.append(new_sim.uid)\n        if parameters:\n            new_sim.add_parameters(parameters)\n        return new_sim\n",
                "lines": [
                  438,
                  497
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> db.create_simulation(parameters={\"a\": 1, \"b\": 2})",
                ">>> db.create_simulation(uid=\"my_sim\", parameters={\"a\": 1, \"b\": 2}, prefix=\"test\")"
              ]
            },
            "remove": {
              "docstring": "CAUTION, DELETING DATA. Remove the data of a simulation.\n",
              "signature": "(self, uid: str) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "uid": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "uid"
                }
              },
              "source": {
                "code": "    def remove(self, uid: str) -> None:\n        \"\"\"CAUTION, DELETING DATA. Remove the data of a simulation.\n\n        Args:\n            uid (`str`): uid\n        \"\"\"\n        shutil.rmtree(os.path.join(self.path, uid))\n",
                "lines": [
                  499,
                  505
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "find": {
              "docstring": "Find simulations with the given parameters.\n\nThe dictionary can contain callables to filter inequalities or other\nfilters.",
              "signature": "(\n    self,\n    parameter_selection: dict[str, typing.Any]\n) -> pandas.core.frame.DataFrame",
              "returns": {
                "annotation": "<class 'pandas.core.frame.DataFrame'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "parameter_selection": {
                  "default": null,
                  "annotation": "dict[str, typing.Any]",
                  "description": "parameter selection dictionary"
                }
              },
              "source": {
                "code": "    def find(self, parameter_selection: dict[str, Any]) -> pd.DataFrame:\n        \"\"\"Find simulations with the given parameters.\n\n        The dictionary can contain callables to filter inequalities or other\n        filters.\n\n        Examples:\n            >>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n            >>> db.find({\"a\": 1, \"b\": 2})\n\n        Args:\n            parameter_selection (dict): parameter selection dictionary\n        \"\"\"\n        parameter_selection = flatten_dict(parameter_selection)\n        params = {}\n        filters = {}\n        for key, val in parameter_selection.items():\n            if callable(val):\n                filters[key] = val\n            else:\n                params[key] = val\n\n        df = self._table.read_table()\n        matches = self._list_duplicates(params)\n        matches = df[df.id.isin(matches)]\n        if len(matches) == 0:\n            return matches\n\n        for key, func in filters.items():\n            matches = matches[func(matches[key])]\n\n        return matches\n",
                "lines": [
                  507,
                  538
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": [
                ">>> db.find({\"a\": 1, \"b\": lambda x: x > 2})\n>>> db.find({\"a\": 1, \"b\": 2})"
              ]
            },
            "global_fields_in_all": {
              "docstring": "Get a list of all global fields in all simulations.\n",
              "signature": "(self) -> list",
              "returns": {
                "annotation": "<class 'list'>",
                "description": "List of global fields"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def global_fields_in_all(self) -> list:\n        \"\"\"Get a list of all global fields in all simulations.\n\n        Returns:\n            List of global fields\n        \"\"\"\n        fields = set()\n        for sim in self:\n            try:\n                fields.update(sim.globals.columns)\n            except KeyError:\n                continue\n\n        return fields\n",
                "lines": [
                  634,
                  647
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_parameters": {
              "docstring": "Get the parameters used in this database.\n",
              "signature": "(self) -> dict",
              "returns": {
                "annotation": "<class 'dict'>",
                "description": "Dictionary of parameters with it's count, range, and type. Sorted by count."
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def get_parameters(self) -> dict:\n        \"\"\"Get the parameters used in this database.\n\n        Returns:\n            Dictionary of parameters with it's count, range, and type. Sorted by count.\n        \"\"\"\n        parameters = dict()\n        for sim in self:\n            for key, val in sim.parameters.items():\n                if key not in parameters:\n                    range = (val, val) if isinstance(val, numbers.Number) else None\n                    parameters[key] = {\"range\": range, \"count\": 1, \"type\": type(val)}\n                else:\n                    if isinstance(val, numbers.Number):\n                        parameters[key][\"range\"] = (\n                            min(parameters[key][\"range\"][0], val),\n                            max(parameters[key][\"range\"][1], val),\n                        )\n                    parameters[key][\"count\"] += 1\n                    parameters[key][\"type\"] = type(val)\n        return dict(\n            sorted(parameters.items(), key=lambda x: x[1][\"count\"], reverse=True)\n        )\n",
                "lines": [
                  649,
                  671
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {
            "FIX_DF": {
              "annotation": "",
              "description": null
            },
            "fromUID": {
              "annotation": ": bamboost.manager.ManagerFromUID",
              "description": null
            },
            "fromName": {
              "annotation": ": bamboost.manager.ManagerFromName",
              "description": null
            },
            "all_uids": {
              "annotation": ": list",
              "description": null
            },
            "df": {
              "annotation": ": pandas.core.frame.DataFrame",
              "description": "View of the database and its parametric space. "
            },
            "data_info": {
              "annotation": ": pandas.core.frame.DataFrame",
              "description": "Return view of stored data for all simulations "
            }
          },
          "inherits_from": {},
          "examples": [
            ">>> db = Manager(\"path/to/db\")\n>>> db.df # DataFrame of the database"
          ],
          "constructor": {
            "signature": "(\n    path: str = None,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>,\n    uid: str = None,\n    create_if_not_exist: bool = True\n)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "path": {
                "default": "None",
                "annotation": "<class 'str'>",
                "description": "path to the directory of the database. If doesn't exist, a new database will be created."
              },
              "comm": {
                "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x743de48d8890>",
                "annotation": "<class 'bamboost.common._mock_mpi.MockMPI.Comm'>",
                "description": "MPI communicator"
              },
              "uid": {
                "default": "None",
                "annotation": "<class 'str'>",
                "description": "UID of the database"
              },
              "create_if_not_exist": {
                "default": "True",
                "annotation": "<class 'bool'>",
                "description": null
              }
            },
            "source": {
              "code": "    def __init__(\n        self,\n        path: str = None,\n        comm: MPI.Comm = MPI.COMM_WORLD,\n        uid: str = None,\n        create_if_not_exist: bool = True,\n    ):\n        # provided uid has precedence\n        if uid is not None:\n            path = self._index.get_path(uid.upper())\n            path = comm.bcast(path, root=0)\n        self.path = path\n        self.comm = comm\n\n        # check if path exists\n        if not os.path.isdir(path):\n            if not create_if_not_exist:\n                raise NotADirectoryError(\"Specified path is not a valid path.\")\n            log.info(f\"Created new database ({path})\")\n            self._make_new(path)\n\n        # retrieve the UID of the database from the id file\n        # if not found, a new one is generated\n        self.UID = uid or self._retrieve_uid()\n\n        # Update the SQL table for the database\n        try:\n            with self._index.open():\n                self._index.insert_path(self.UID, self.path)\n                self._table.create_database_table()\n                self._table.sync()\n        except index.Error as e:\n            log.warning(f\"index error: {e}\")\n",
              "lines": [
                102,
                134
              ]
            }
          }
        },
        "ManagerFromUID": {
          "name": "ManagerFromUID",
          "short_description": "Get a database by its UID. This is used for autocompletion in ipython.",
          "docstring": "Get a database by its UID. This is used for autocompletion in ipython.",
          "methods": {
            "__getitem__": {
              "docstring": "",
              "signature": "(self, key) -> bamboost.manager.Manager",
              "returns": {
                "annotation": "<class 'bamboost.manager.Manager'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def __getitem__(self, key) -> Manager:\n        key = key.split()[0]  # take only uid\n        return Manager(uid=key, create_if_not_exist=False)\n",
                "lines": [
                  59,
                  61
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {
            "completion_keys": {
              "annotation": "",
              "description": null
            }
          },
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "()",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              }
            },
            "source": {
              "code": "    def __init__(self) -> None:\n        # or [] to circumvent Null type (MPI)\n        ids = IndexAPI().fetch(f\"SELECT id, path FROM dbindex\") or []\n        self.completion_keys = tuple(\n            [f'{key} - {\"...\"+val[-25:] if len(val)>=25 else val}' for key, val in ids]\n        )\n",
              "lines": [
                49,
                54
              ]
            }
          }
        },
        "ManagerFromName": {
          "name": "ManagerFromName",
          "short_description": "Get a database by its path/name. This is used for autocompletion in ipython.",
          "docstring": "Get a database by its path/name. This is used for autocompletion in ipython.",
          "methods": {
            "__getitem__": {
              "docstring": "",
              "signature": "(self, key) -> bamboost.manager.Manager",
              "returns": {
                "annotation": "<class 'bamboost.manager.Manager'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def __getitem__(self, key) -> Manager:\n        return Manager(key, create_if_not_exist=False)\n",
                "lines": [
                  74,
                  75
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {
            "completion_keys": {
              "annotation": "",
              "description": null
            }
          },
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "()",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              }
            },
            "source": {
              "code": "    def __init__(self) -> None:\n        paths = IndexAPI().fetch(\"SELECT path FROM dbindex\") or []\n        self.completion_keys = tuple(paths)\n",
              "lines": [
                67,
                69
              ]
            }
          }
        }
      },
      "functions": {},
      "submodules": {}
    },
    "simulation": {
      "name": "bamboost.simulation",
      "docstring": "",
      "classes": {
        "Simulation": {
          "name": "Simulation",
          "short_description": "A single dataset/simulation. Used to write to it, read from it or append.",
          "docstring": "A single dataset/simulation. Used to write to it, read from it or append.\n",
          "methods": {
            "fromUID": {
              "docstring": "Return the `Simulation` with given UID.\n",
              "signature": "(full_uid: str, *, index_database: bamboost.index.IndexAPI = None) -> Self",
              "returns": {
                "annotation": "typing.Self",
                "description": null
              },
              "arguments": {
                "full_uid": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "the full id (Database uid : simulation uid)"
                },
                "index_database": {
                  "default": "None",
                  "annotation": "<class 'bamboost.index.IndexAPI'>",
                  "description": null
                }
              },
              "source": {
                "code": "    @classmethod\n    def fromUID(cls, full_uid: str, *, index_database: index.IndexAPI = None) -> Self:\n        \"\"\"Return the `Simulation` with given UID.\n\n        Args:\n            full_uid: the full id (Database uid : simulation uid)\n        \"\"\"\n        if index_database is None:\n            index_database = index.IndexAPI()\n        db_uid, sim_uid = full_uid.split(\":\")\n        db_path = index_database.get_path(db_uid)\n        return cls(sim_uid, db_path, create_if_not_exists=False)\n",
                "lines": [
                  138,
                  149
                ]
              },
              "props": {
                "isClassMethod": true
              },
              "examples": []
            },
            "__getitem__": {
              "docstring": "Direct access to HDF5 file.\n",
              "signature": "(self, key) -> bamboost.common.hdf_pointer.BasePointer",
              "returns": {
                "annotation": "<class 'bamboost.common.hdf_pointer.BasePointer'>",
                "description": ":class:`~bamboost.common.file_handler.BasePointer`"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @with_file_open()\n    def __getitem__(self, key) -> hdf_pointer.BasePointer:\n        \"\"\"Direct access to HDF5 file.\n\n        Returns:\n            :class:`~bamboost.common.file_handler.BasePointer`\n        \"\"\"\n        return hdf_pointer.BasePointer.new_pointer(self._file, key)\n",
                "lines": [
                  151,
                  158
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "files": {
              "docstring": "Get the path to the file.\n",
              "signature": "(self, filename: str) -> str",
              "returns": {
                "annotation": "<class 'str'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "filename": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "name of the file"
                }
              },
              "source": {
                "code": "    def files(self, filename: str) -> str:\n        \"\"\"Get the path to the file.\n\n        Args:\n            filename: name of the file\n        \"\"\"\n        return os.path.join(self.path, filename)\n",
                "lines": [
                  256,
                  262
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "show_files": {
              "docstring": "Show the file tree of the simulation directory.\n",
              "signature": "(\n    self,\n    level=-1,\n    limit_to_directories=False,\n    length_limit=1000,\n    printit=True\n) -> str",
              "returns": {
                "annotation": "<class 'str'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "level": {
                  "default": "-1",
                  "annotation": null,
                  "description": "how deep to print the tree"
                },
                "limit_to_directories": {
                  "default": "False",
                  "annotation": null,
                  "description": "only print directories"
                },
                "length_limit": {
                  "default": "1000",
                  "annotation": null,
                  "description": "cutoff"
                },
                "printit": {
                  "default": "True",
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def show_files(\n        self, level=-1, limit_to_directories=False, length_limit=1000, printit=True\n    ) -> str:\n        \"\"\"Show the file tree of the simulation directory.\n\n        Args:\n            level: how deep to print the tree\n            limit_to_directories: only print directories\n            length_limit: cutoff\n        \"\"\"\n        tree_string = utilities.tree(\n            self.path, level, limit_to_directories, length_limit\n        )\n        if printit:\n            print(tree_string)\n        else:\n            return tree_string\n",
                "lines": [
                  264,
                  280
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "open_in_file_explorer": {
              "docstring": "Open the simulation directory. Uses `xdg-open` on linux systems.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def open_in_file_explorer(self) -> None:\n        \"\"\"Open the simulation directory. Uses `xdg-open` on linux systems.\"\"\"\n        if os.name == \"nt\":  # should work on Windows\n            os.startfile(self.path)\n        else:\n            subprocess.run([\"xdg-open\", self.path])\n",
                "lines": [
                  282,
                  287
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "open_in_paraview": {
              "docstring": "Open the xdmf file in paraview.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def open_in_paraview(self) -> None:\n        \"\"\"Open the xdmf file in paraview.\"\"\"\n        subprocess.Popen([\"paraview\", self.xdmffile])\n",
                "lines": [
                  289,
                  291
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_full_uid": {
              "docstring": "Returns the full uid of the simulation (including the one of the database)",
              "signature": "(self) -> str",
              "returns": {
                "annotation": "<class 'str'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def get_full_uid(self) -> str:\n        \"\"\"Returns the full uid of the simulation (including the one of the database)\"\"\"\n        database_uid = index.get_uid_from_path(self.path_database)\n        return f\"{database_uid}:{self.uid}\"\n",
                "lines": [
                  293,
                  296
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "change_status": {
              "docstring": "Change status of simulation.\n",
              "signature": "(self, status: str) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "status": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "new status"
                }
              },
              "source": {
                "code": "    def change_status(self, status: str) -> None:\n        \"\"\"Change status of simulation.\n\n        Args:\n            status (str): new status\n        \"\"\"\n        if self._prank == 0:\n            self._file.open(\"a\")\n            self._file.attrs[\"status\"] = status\n            self._file.close()\n\n        self._push_update_to_sqlite({\"status\": status})\n",
                "lines": [
                  298,
                  309
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "update_metadata": {
              "docstring": "Update the metadata attributes.\n",
              "signature": "(self, update_dict: dict) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "update_dict": {
                  "default": null,
                  "annotation": "<class 'dict'>",
                  "description": "dictionary to push"
                }
              },
              "source": {
                "code": "    def update_metadata(self, update_dict: dict) -> None:\n        \"\"\"Update the metadata attributes.\n\n        Args:\n            update_dict: dictionary to push\n        \"\"\"\n        if self._prank == 0:\n            update_dict = utilities.flatten_dict(update_dict)\n            with self._file(\"a\") as file:\n                file.attrs.update(update_dict)\n\n            self._push_update_to_sqlite(update_dict)\n",
                "lines": [
                  311,
                  322
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "update_parameters": {
              "docstring": "Update the parameters dictionary.\n",
              "signature": "(self, update_dict: dict) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "update_dict": {
                  "default": null,
                  "annotation": "<class 'dict'>",
                  "description": "dictionary to push"
                }
              },
              "source": {
                "code": "    def update_parameters(self, update_dict: dict) -> None:\n        \"\"\"Update the parameters dictionary.\n\n        Args:\n            update_dict: dictionary to push\n        \"\"\"\n        if self._prank == 0:\n            update_dict = utilities.flatten_dict(update_dict)\n            with self._file(\"a\") as file:\n                file[\"parameters\"].attrs.update(update_dict)\n\n            self._push_update_to_sqlite(update_dict)\n",
                "lines": [
                  324,
                  335
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_xdmf_file": {
              "docstring": "Create the xdmf file to read in paraview.\n",
              "signature": "(self, fields: list = None, nb_steps: int = None) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "fields": {
                  "default": "None",
                  "annotation": "<class 'list'>",
                  "description": "fields for which to write timeseries information, if not specified, all fields in data are written."
                },
                "nb_steps": {
                  "default": "None",
                  "annotation": "<class 'int'>",
                  "description": "number of steps the simulation has"
                }
              },
              "source": {
                "code": "    def create_xdmf_file(self, fields: list = None, nb_steps: int = None) -> None:\n        \"\"\"Create the xdmf file to read in paraview.\n\n        Args:\n            fields (list[str]): fields for which to write timeseries information,\n                if not specified, all fields in data are written.\n            nb_steps (int): number of steps the simulation has\n        \"\"\"\n\n        if self._prank == 0:\n            with self._file(\"r\") as f:\n                if \"data\" not in f.keys():\n                    fields, nb_steps = [], 0\n                if fields is None:\n                    fields = list(f[\"data\"].keys())\n\n                if nb_steps is None:\n                    grp_name = list(f[\"data\"].keys())[0]\n                    nb_steps = list(f[f\"data/{grp_name}\"].keys())\n                    nb_steps = max(\n                        [int(step) for step in nb_steps if not step.startswith(\"__\")]\n                    )\n\n                # temporary fix to load coordinates/geometry\n                coords_name = (\n                    \"geometry\"\n                    if \"geometry\"\n                    in f[f\"{self._mesh_location}/{self._default_mesh}\"].keys()\n                    else \"coordinates\"\n                )\n\n            xdmf_writer = XDMFWriter(self.xdmffile, self.h5file)\n            xdmf_writer.write_points_cells(\n                f\"{self._mesh_location}/{self._default_mesh}/{coords_name}\",\n                f\"{self._mesh_location}/{self._default_mesh}/topology\",\n            )\n\n            if fields:\n                xdmf_writer.add_timeseries(nb_steps + 1, fields)\n            xdmf_writer.write_file()\n",
                "lines": [
                  337,
                  376
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_run_script": {
              "docstring": "Create a batch job and put it into the folder.\n",
              "signature": "(\n    self,\n    commands: list = None,\n    nnodes: int = 1,\n    ntasks: int = 4,\n    ncpus: int = 1,\n    time: str = '04:00:00',\n    mem_per_cpu: int = 2048,\n    tmp=None,\n    euler: bool = True,\n    sbatch_kwargs: list = None\n) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "commands": {
                  "default": "None",
                  "annotation": "<class 'list'>",
                  "description": "A list of strings being the user defined commands to run"
                },
                "nnodes": {
                  "default": "1",
                  "annotation": "<class 'int'>",
                  "description": "nb of nodes (default=1)"
                },
                "ntasks": {
                  "default": "4",
                  "annotation": "<class 'int'>",
                  "description": "nb of tasks (default=4)"
                },
                "ncpus": {
                  "default": "1",
                  "annotation": "<class 'int'>",
                  "description": "nb of cpus per task (default=1)"
                },
                "time": {
                  "default": "04:00:00",
                  "annotation": "<class 'str'>",
                  "description": "requested time, format \"HH:MM:SS\" (default=4 hours)"
                },
                "mem_per_cpu": {
                  "default": "2048",
                  "annotation": "<class 'int'>",
                  "description": "memory (default=2048)"
                },
                "tmp": {
                  "default": "None",
                  "annotation": null,
                  "description": "temporary storage, set None to exclude option (default=8000)"
                },
                "euler": {
                  "default": "True",
                  "annotation": "<class 'bool'>",
                  "description": "If false, a local bash script will be written"
                },
                "sbatch_kwargs": {
                  "default": "None",
                  "annotation": "<class 'list'>",
                  "description": "Additional sbatch arguments. allow to provide additional sbatch arguments. in the format [\"--mail=BEGIN,END,FAIL\", ...]."
                }
              },
              "source": {
                "code": "    def create_run_script(\n        self,\n        commands: list = None,\n        nnodes: int = 1,\n        ntasks: int = 4,\n        ncpus: int = 1,\n        time: str = \"04:00:00\",\n        mem_per_cpu: int = 2048,\n        tmp=None,\n        euler: bool = True,\n        sbatch_kwargs: list = None,\n    ) -> None:\n        \"\"\"Create a batch job and put it into the folder.\n\n        Args:\n            commands: A list of strings being the user defined commands to run\n            nnodes: nb of nodes (default=1)\n            ntasks: nb of tasks (default=4)\n            ncpus: nb of cpus per task (default=1)\n            time: requested time, format \"HH:MM:SS\" (default=4 hours)\n            mem_per_cpu: memory (default=2048)\n            tmp: temporary storage, set None to exclude option (default=8000)\n            euler: If false, a local bash script will be written\n            sbatch_kwargs: Additional sbatch arguments. allow to provide\n                additional sbatch arguments. in the format [\"--mail=BEGIN,END,FAIL\", ...].\n        \"\"\"\n        job = Job()\n\n        if euler:\n            job.create_sbatch_script(\n                commands,\n                path=os.path.abspath(self.path_database),\n                uid=self.uid,\n                db_id=self.database_id,\n                nnodes=nnodes,\n                ntasks=ntasks,\n                ncpus=ncpus,\n                time=time,\n                mem_per_cpu=mem_per_cpu,\n                tmp=tmp,\n                sbatch_kwargs=sbatch_kwargs,\n            )\n        else:\n            job.create_bash_script_local(\n                commands,\n                path=os.path.abspath(self.path_database),\n                uid=self.uid,\n                db_id=self.database_id,\n                ntasks=ntasks,\n            )\n        with self._file(\"a\") as file:\n            file.attrs.update({\"submitted\": False})\n",
                "lines": [
                  378,
                  429
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "create_batch_script": {
              "docstring": "",
              "signature": "(self, *args, **kwargs)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "args": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "kwargs": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @deprecated(\"use `create_run_script` instead\")\n    def create_batch_script(self, *args, **kwargs):\n        return self.create_run_script(*args, **kwargs)\n",
                "lines": [
                  431,
                  433
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "submit": {
              "docstring": "Submit the job for this simulation.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def submit(self) -> None:\n        \"\"\"Submit the job for this simulation.\"\"\"\n        if f\"sbatch_{self.uid}.sh\" in os.listdir(self.path):\n            batch_script = os.path.abspath(\n                os.path.join(self.path, f\"sbatch_{self.uid}.sh\")\n            )\n            env = os.environ.copy()\n            _ = env.pop(\"BAMBOOST_MPI\", None)\n            subprocess.run([\"sbatch\", f\"{batch_script}\"], env=env)\n        elif f\"{self.uid}.sh\" in os.listdir(self.path):\n            bash_script = os.path.abspath(os.path.join(self.path, f\"{self.uid}.sh\"))\n            env = os.environ.copy()\n            _ = env.pop(\"BAMBOOST_MPI\", None)\n            subprocess.run([\"bash\", f\"{bash_script}\"], env=env)\n        else:\n            raise FileNotFoundError(\n                f\"Could not find a batch script for simulation {self.uid}.\"\n            )\n\n        log.info(f\"Simulation {self.uid} submitted!\")\n\n        with self._file(\"a\") as file:\n            file.attrs.update({\"submitted\": True})\n\n        self._push_update_to_sqlite({\"submitted\": True})\n",
                "lines": [
                  435,
                  459
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "change_note": {
              "docstring": "",
              "signature": "(self, note) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "note": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @with_file_open(\"a\")\n    def change_note(self, note) -> None:\n        if self._prank == 0:\n            self._file.attrs[\"notes\"] = note\n            self._push_update_to_sqlite({\"notes\": note})\n",
                "lines": [
                  461,
                  465
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "open": {
              "docstring": "Use this as a context manager in a `with` statement.\nPurpose: keeping the file open to directly access/edit something in the\nHDF5 file of this simulation.",
              "signature": "(\n    self,\n    mode: str = 'r',\n    driver=None,\n    comm=None\n) -> bamboost.common.file_handler.FileHandler",
              "returns": {
                "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "mode": {
                  "default": "r",
                  "annotation": "<class 'str'>",
                  "description": "file mode (see h5py docs)"
                },
                "driver": {
                  "default": "None",
                  "annotation": null,
                  "description": "file driver (see h5py docs)"
                },
                "comm": {
                  "default": "None",
                  "annotation": null,
                  "description": "mpi communicator"
                }
              },
              "source": {
                "code": "    def open(self, mode: str = \"r\", driver=None, comm=None) -> FileHandler:\n        \"\"\"Use this as a context manager in a `with` statement.\n        Purpose: keeping the file open to directly access/edit something in the\n        HDF5 file of this simulation.\n\n        Args:\n            mode (`str`): file mode (see h5py docs)\n            driver (`str`): file driver (see h5py docs)\n            comm (`str`): mpi communicator\n        \"\"\"\n        return self._file(mode, driver, comm)\n",
                "lines": [
                  470,
                  480
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_mesh": {
              "docstring": "Return coordinates and connectivity. Currently returns numpy arrays.\n",
              "signature": "(self, mesh_name: str = None) -> Tuple[numpy.ndarray, numpy.ndarray]",
              "returns": {
                "annotation": "typing.Tuple[numpy.ndarray, numpy.ndarray]",
                "description": "Tuple of np.arrays (coordinates, connectivity)"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "mesh_name": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": "optional, name of mesh to read (default = mesh)"
                }
              },
              "source": {
                "code": "    @with_file_open(\"r\")\n    def get_mesh(self, mesh_name: str = None) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Return coordinates and connectivity. Currently returns numpy arrays.\n\n        Args:\n            mesh_name (`str`): optional, name of mesh to read (default = mesh)\n        Returns:\n            Tuple of np.arrays (coordinates, connectivity)\n        \"\"\"\n        if mesh_name is None:\n            mesh_name = self._default_mesh\n\n        # Raise an error if the mesh is not found\n        if (self._mesh_location.split(\"/\")[0] not in self._file.keys()) or (\n            mesh_name not in self._file[self._mesh_location].keys()\n        ):\n            raise KeyError(f\"Mesh location {self._mesh_location} not found in file.\")\n\n        mesh = self.meshes[mesh_name]\n        return mesh.coordinates, mesh.connectivity\n",
                "lines": [
                  491,
                  510
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "get_data_interpolator": {
              "docstring": "Get Linear interpolator for data field at step. Uses the linked mesh.\n",
              "signature": "(self, field: str, step: int)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": ":class:`scipy.interpolate.LinearNDInterpolator`"
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "field": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                },
                "step": {
                  "default": null,
                  "annotation": "<class 'int'>",
                  "description": "step"
                }
              },
              "source": {
                "code": "    def get_data_interpolator(self, field: str, step: int):\n        \"\"\"Get Linear interpolator for data field at step. Uses the linked mesh.\n\n        Args:\n            name (`str`): name of the data field\n            step (`int`): step\n        Returns:\n            :class:`scipy.interpolate.LinearNDInterpolator`\n        \"\"\"\n        from scipy.interpolate import LinearNDInterpolator\n\n        return LinearNDInterpolator(\n            self.data[field].mesh.coordinates, self.data[field].at_step(step)\n        )\n",
                "lines": [
                  549,
                  562
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "show_h5tree": {
              "docstring": "Print the tree inside the h5 file.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @with_file_open()\n    def show_h5tree(self) -> None:\n        \"\"\"Print the tree inside the h5 file.\"\"\"\n        # print('\\U00002B57 ' + os.path.basename(self.h5file))\n        print(\"\\U0001f43c \" + os.path.basename(self.h5file))\n        utilities.h5_tree(self._file.file_object)\n",
                "lines": [
                  564,
                  569
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "enter_path": {
              "docstring": "A context manager for changing the working directory to this simulations' path.\n\n>>> with sim.working_directory():\n>>>     ...",
              "signature": "(self)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @contextmanager\n    def enter_path(self):\n        \"\"\"A context manager for changing the working directory to this simulations' path.\n\n        >>> with sim.working_directory():\n        >>>     ...\n        \"\"\"\n\n        current_dir = os.getcwd()\n        try:\n            os.chdir(self.path)\n            yield\n        finally:\n            os.chdir(current_dir)\n",
                "lines": [
                  571,
                  584
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {
            "uid": {
              "annotation": ": str",
              "description": null
            },
            "path_database": {
              "annotation": ": str",
              "description": null
            },
            "database_id": {
              "annotation": "",
              "description": null
            },
            "path": {
              "annotation": ": str",
              "description": null
            },
            "h5file": {
              "annotation": ": str",
              "description": null
            },
            "xdmffile": {
              "annotation": ": str",
              "description": null
            },
            "meshes": {
              "annotation": ": bamboost.accessors.meshes.MeshGroup",
              "description": null
            },
            "data": {
              "annotation": ": bamboost.accessors.fielddata.DataGroup",
              "description": null
            },
            "globals": {
              "annotation": ": bamboost.accessors.globals.GlobalGroup",
              "description": null
            },
            "userdata": {
              "annotation": ": bamboost.common.hdf_pointer.MutableGroup",
              "description": null
            },
            "links": {
              "annotation": ": bamboost.simulation.Links",
              "description": null
            },
            "parameters": {
              "annotation": ": dict",
              "description": null
            },
            "metadata": {
              "annotation": ": dict",
              "description": null
            },
            "mesh": {
              "annotation": ": Tuple[numpy.ndarray, numpy.ndarray]",
              "description": "Return coordinates and connectivity of default mesh. "
            },
            "data_info": {
              "annotation": ": pandas.core.frame.DataFrame",
              "description": "View the data stored. "
            },
            "git": {
              "annotation": ": dict",
              "description": "Get Git information. "
            }
          },
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(\n    uid: str,\n    path: str,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>,\n    create_if_not_exists: bool = False,\n    *,\n    _db_id: str = None\n)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "uid": {
                "default": null,
                "annotation": "<class 'str'>",
                "description": "unique identifier"
              },
              "path": {
                "default": null,
                "annotation": "<class 'str'>",
                "description": "path to parent/database folder"
              },
              "comm": {
                "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x743de48d8890>",
                "annotation": "<class 'bamboost.common._mock_mpi.MockMPI.Comm'>",
                "description": "MPI communicator (default=MPI.COMM_WORLD)"
              },
              "create_if_not_exists": {
                "default": "False",
                "annotation": "<class 'bool'>",
                "description": null
              },
              "_db_id": {
                "default": "None",
                "annotation": "<class 'str'>",
                "description": null
              }
            },
            "source": {
              "code": "    def __init__(\n        self,\n        uid: str,\n        path: str,\n        comm: MPI.Comm = MPI.COMM_WORLD,\n        create_if_not_exists: bool = False,\n        *,\n        _db_id: str = None,\n    ):\n        self.uid: str = uid\n        path = comm.bcast(path, root=0)\n        self.path_database: str = os.path.abspath(path)\n        self.database_id = _db_id or index.get_uid_from_path(self.path_database)\n        self.path: str = os.path.abspath(os.path.join(path, uid))\n        self.h5file: str = os.path.join(self.path, f\"{self.uid}.h5\")\n        self.xdmffile: str = os.path.join(self.path, f\"{self.uid}.xdmf\")\n\n        if not os.path.exists(self.h5file) and not create_if_not_exists:\n            raise FileNotFoundError(\n                f\"Simulation {self.uid} does not exist in {self.path}.\"\n            )\n\n        os.makedirs(self.path, exist_ok=True)\n\n        # MPI information\n        self._comm = comm\n        self._psize = self._comm.size\n        self._prank = self._comm.rank\n        self._ranks = np.array([i for i in range(self._psize)])\n\n        self._file = FileHandler(self.h5file)\n\n        # Initialize groups to meshes, data and userdata. Create groups.\n        self.meshes: MeshGroup = MeshGroup(self._file)\n        self.data: DataGroup = DataGroup(self._file, self.meshes)\n        self.globals: GlobalGroup = GlobalGroup(self._file, \"/globals\")\n        self.userdata: hdf_pointer.MutableGroup = hdf_pointer.MutableGroup(\n            self._file, \"/userdata\"\n        )\n        self.links: Links = Links(self._file)\n",
              "lines": [
                97,
                136
              ]
            }
          }
        },
        "Links": {
          "name": "Links",
          "short_description": "Link group. Used to create and access links.",
          "docstring": "Link group. Used to create and access links.\n\nI don't know how to distribute this to its own file in the accessors\ndirectory, due to circular imports.",
          "methods": {
            "__getitem__": {
              "docstring": "Returns the linked simulation object.",
              "signature": "(self, key) -> bamboost.simulation.Simulation",
              "returns": {
                "annotation": "<class 'bamboost.simulation.Simulation'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @with_file_open(\"r\", driver=\"mpio\")\n    def __getitem__(self, key) -> Simulation:\n        \"\"\"Returns the linked simulation object.\"\"\"\n        return Simulation.fromUID(self.obj.attrs[key])\n",
                "lines": [
                  54,
                  57
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "__setitem__": {
              "docstring": "Creates the link.",
              "signature": "(self, key, newvalue)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "key": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "newvalue": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def __setitem__(self, key, newvalue):\n        \"\"\"Creates the link.\"\"\"\n        return self.update_attrs({key: newvalue})\n",
                "lines": [
                  59,
                  61
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "all_links": {
              "docstring": "",
              "signature": "(self) -> dict",
              "returns": {
                "annotation": "<class 'dict'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    @with_file_open(\"r\")\n    def all_links(self) -> dict:\n        return dict(self.obj.attrs)\n",
                "lines": [
                  80,
                  82
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {},
          "inherits_from": {
            "MutableGroup": {
              "module": "bamboost.common.hdf_pointer",
              "members": [
                [
                  "function",
                  "update_attrs"
                ],
                [
                  "function",
                  "add_dataset"
                ],
                [
                  "function",
                  "require_group"
                ]
              ]
            },
            "Group": {
              "module": "bamboost.common.hdf_pointer",
              "members": [
                [
                  "function",
                  "__iter__"
                ],
                [
                  "function",
                  "keys"
                ],
                [
                  "function",
                  "groups"
                ],
                [
                  "function",
                  "datasets"
                ]
              ]
            },
            "BasePointer": {
              "module": "bamboost.common.hdf_pointer",
              "members": [
                [
                  "function",
                  "new_pointer"
                ],
                [
                  "variable",
                  "path_to_data"
                ],
                [
                  "variable",
                  "obj"
                ],
                [
                  "variable",
                  "attrs"
                ]
              ]
            }
          },
          "examples": [],
          "constructor": {
            "signature": "(file_handler: bamboost.common.file_handler.FileHandler)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "file_handler": {
                "default": null,
                "annotation": "<class 'bamboost.common.file_handler.FileHandler'>",
                "description": null
              }
            },
            "source": {
              "code": "    def __init__(self, file_handler: FileHandler) -> None:\n        super().__init__(file_handler, path_to_data=\"links\")\n",
              "lines": [
                48,
                49
              ]
            }
          }
        }
      },
      "functions": {},
      "submodules": {}
    },
    "simulation_writer": {
      "name": "bamboost.simulation_writer",
      "docstring": "",
      "classes": {
        "SimulationWriter": {
          "name": "SimulationWriter",
          "short_description": "The SimulationWriter is the writer object for a single simulation. It inherits",
          "docstring": "The SimulationWriter is the writer object for a single simulation. It inherits\nall reading methods from :class:`Simulation`.\n\nThis class can be used as a context manager. When entering the context, the status\nof the simulation is changed to \"Started\". When an exception is raised inside the\ncontext, the status is changed to \"Failed [Exception]\".",
          "methods": {
            "initialize": {
              "docstring": "Create a new file for this simlation.\nThis deletes an existing h5 file of the simulation and creates an empty new one",
              "signature": "(self) -> bamboost.simulation_writer.SimulationWriter",
              "returns": {
                "annotation": "<class 'bamboost.simulation_writer.SimulationWriter'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def initialize(self) -> SimulationWriter:\n        \"\"\"Create a new file for this simlation.\n        This deletes an existing h5 file of the simulation and creates an empty new one\n        \"\"\"\n        self.step = 0\n        self.add_metadata()\n        self.change_status(\"Initiated\")\n\n        return self\n",
                "lines": [
                  65,
                  73
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_metadata": {
              "docstring": "Add metadata to h5 file.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def add_metadata(self) -> None:\n        \"\"\"Add metadata to h5 file.\"\"\"\n        nb_proc = self._comm.Get_size()\n        if self._prank == 0:\n            with self._file(\"a\"):\n                data = {\n                    \"time_stamp\": str(datetime.datetime.now().replace(microsecond=0)),\n                    \"id\": self.uid,\n                    \"processors\": nb_proc,\n                    \"notes\": self._file.attrs.get(\"notes\", \"\"),\n                }\n                self._file.attrs.update(data)\n            self._push_update_to_sqlite(data)\n",
                "lines": [
                  75,
                  87
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_parameters": {
              "docstring": "Add parameters to simulation.\n",
              "signature": "(self, parameters: dict) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "parameters": {
                  "default": null,
                  "annotation": "<class 'dict'>",
                  "description": "Dictionary with parameters."
                }
              },
              "source": {
                "code": "    def add_parameters(self, parameters: dict) -> None:\n        \"\"\"Add parameters to simulation.\n\n        Args:\n            parameters: Dictionary with parameters.\n        \"\"\"\n        if self._prank == 0:\n            with self._file(\"a\"):\n                # flatten parameters\n                parameters = flatten_dict(parameters)\n\n                if \"parameters\" in self._file.keys():\n                    del self._file[\"parameters\"]\n                grp = self._file.create_group(\"/parameters\")\n                for key, val in parameters.items():\n                    if isinstance(val, np.ndarray):\n                        grp.create_dataset(key, data=val)\n                    elif val is not None:\n                        grp.attrs[key] = val\n            self._push_update_to_sqlite(parameters)\n",
                "lines": [
                  89,
                  108
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_mesh": {
              "docstring": "Add the mesh to file. Currently only 2d meshes.\n",
              "signature": "(\n    self,\n    coordinates: numpy.ndarray,\n    connectivity: numpy.ndarray,\n    mesh_name: str = None\n) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "coordinates": {
                  "default": null,
                  "annotation": "<class 'numpy.ndarray'>",
                  "description": "Coordinates as array (nb_nodes, dim)"
                },
                "connectivity": {
                  "default": null,
                  "annotation": "<class 'numpy.ndarray'>",
                  "description": "Connectivity matrix (nb_cells, nb nodes per cell)"
                },
                "mesh_name": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": "name for mesh (default = `mesh`)"
                }
              },
              "source": {
                "code": "    def add_mesh(\n        self, coordinates: np.ndarray, connectivity: np.ndarray, mesh_name: str = None\n    ) -> None:\n        \"\"\"Add the mesh to file. Currently only 2d meshes.\n\n        Args:\n            coordinates: Coordinates as array (nb_nodes, dim)\n            connectivity: Connectivity matrix (nb_cells, nb nodes per cell)\n            mesh_name: name for mesh (default = `mesh`)\n        \"\"\"\n        if mesh_name is None:\n            mesh_name = self._default_mesh\n        # self._mesh_location = 'Mesh/0/mesh/'\n        mesh_location = f\"{self._mesh_location}/{mesh_name}/\"\n\n        nb_nodes_local = coordinates.shape[0]\n        nb_cells_local = connectivity.shape[0]\n\n        # gather total mesh\n        nb_nodes_p = np.array(self._comm.allgather(nb_nodes_local))\n        nb_cells_p = np.array(self._comm.allgather(nb_cells_local))\n        nb_nodes, nb_cells = np.sum(nb_nodes_p), np.sum(nb_cells_p)\n\n        # shape of datasets\n        coord_shape = (\n            (nb_nodes, coordinates.shape[1]) if coordinates.ndim > 1 else (nb_nodes,)\n        )\n        conn_shape = (\n            (nb_cells, connectivity.shape[1]) if connectivity.ndim > 1 else (nb_cells,)\n        )\n\n        # global indices nodes\n        idx_start = np.sum(nb_nodes_p[self._ranks < self._prank])\n        idx_end = idx_start + nb_nodes_local\n\n        # global indices cells\n        idx_start_cells = np.sum(nb_cells_p[self._ranks < self._prank])\n        idx_end_cells = idx_start_cells + nb_cells_local\n        connectivity = connectivity + idx_start\n\n        with self._file(\"a\", driver=\"mpio\", comm=self._comm) as f:\n            if mesh_location in self._file.file_object:\n                del self._file.file_object[mesh_location]\n            grp = f.require_group(mesh_location)\n            coord = grp.require_dataset(\n                \"geometry\", shape=coord_shape, dtype=coordinates.dtype\n            )\n            conn = grp.require_dataset(\n                \"topology\", shape=conn_shape, dtype=connectivity.dtype\n            )\n\n            coord[idx_start:idx_end] = coordinates\n            conn[idx_start_cells:idx_end_cells] = connectivity\n",
                "lines": [
                  110,
                  162
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_field": {
              "docstring": "Add a dataset to the file. The data is stored at `data/`.\n",
              "signature": "(\n    self,\n    name: str,\n    vector: <built-in function array>,\n    time: float = None,\n    mesh: str = None,\n    dtype: str = None,\n    center: str = 'Node'\n) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "name": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "Name for the dataset"
                },
                "vector": {
                  "default": null,
                  "annotation": "<built-in function array>",
                  "description": "Dataset"
                },
                "time": {
                  "default": "None",
                  "annotation": "<class 'float'>",
                  "description": "Optional. time"
                },
                "mesh": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": "Optional. Linked mesh for this data"
                },
                "dtype": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": "Optional. Numpy style datatype, see h5py documentation, defaults to the dtype of the vector."
                },
                "center": {
                  "default": "Node",
                  "annotation": "<class 'str'>",
                  "description": "Optional. Center of the data. Can be 'Node' or 'Cell'. Default is 'Node'."
                }
              },
              "source": {
                "code": "    def add_field(\n        self,\n        name: str,\n        vector: np.array,\n        time: float = None,\n        mesh: str = None,\n        dtype: str = None,\n        center: str = \"Node\",\n    ) -> None:\n        \"\"\"Add a dataset to the file. The data is stored at `data/`.\n\n        Args:\n            name: Name for the dataset\n            vector: Dataset\n            time: Optional. time\n            mesh: Optional. Linked mesh for this data\n            dtype: Optional. Numpy style datatype, see h5py documentation,\n                defaults to the dtype of the vector.\n            center: Optional. Center of the data. Can be 'Node' or 'Cell'.\n                Default is 'Node'.\n        \"\"\"\n        if mesh is None:\n            mesh = self._default_mesh\n\n        dim = vector.shape[1:] if vector.ndim > 1 else None\n\n        if time is None:\n            time = self.step\n\n        length_local = vector.shape[0]\n        length_p = np.array(self._comm.allgather(length_local))\n\n        length = np.sum(length_p)\n\n        # global indices\n        idx_start = np.sum(length_p[self._ranks < self._prank])\n        idx_end = idx_start + length_local\n\n        # open file\n        with self._file(\"a\", driver=\"mpio\", comm=self._comm) as f:\n            data = f.require_group(\n                \"data\"\n            )  # Require group data to store all point data in\n            grp = data.require_group(name)\n            vec = grp.require_dataset(\n                str(self.step),\n                shape=(length, *dim) if dim else (length,),\n                dtype=dtype if dtype else vector.dtype,\n            )\n            vec[idx_start:idx_end] = vector\n\n        if self._prank == 0:\n            with self._file(\"a\"):\n                vec = self._file[\"data\"][name][str(self.step)]\n                vec.attrs[\"t\"] = time  # add time as attribute to dataset\n                vec.attrs[\"mesh\"] = mesh  # add link to mesh as attribute\n                vec.attrs[\"center\"] = center\n",
                "lines": [
                  164,
                  220
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_fields": {
              "docstring": "Add multiple fields at once.\n",
              "signature": "(\n    self,\n    fields: Dict[str, <built-in function array>],\n    time: float = None,\n    mesh: str = None\n) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "fields": {
                  "default": null,
                  "annotation": "typing.Dict[str, <built-in function array>]",
                  "description": "Dictionary with fields"
                },
                "time": {
                  "default": "None",
                  "annotation": "<class 'float'>",
                  "description": "Optional. time"
                },
                "mesh": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def add_fields(\n        self,\n        fields: Dict[str, np.array],\n        time: float = None,\n        mesh: str = None,\n    ) -> None:\n        \"\"\"Add multiple fields at once.\n\n        Args:\n            fields: Dictionary with fields\n            time: Optional. time\n        \"\"\"\n        for name, vector in fields.items():\n            self.add_field(name, vector, time, mesh)\n",
                "lines": [
                  222,
                  235
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_global_field": {
              "docstring": "Add a gobal field. These are stored at `globals/` as an array in a\nsingle dataset.",
              "signature": "(self, name: str, value: Any, dtype: str = None) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "name": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "Name for the data"
                },
                "value": {
                  "default": null,
                  "annotation": "typing.Any",
                  "description": "Data. Can be a numpy array or a single value."
                },
                "dtype": {
                  "default": "None",
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def add_global_field(self, name: str, value: Any, dtype: str = None) -> None:\n        \"\"\"Add a gobal field. These are stored at `globals/` as an array in a\n        single dataset.\n\n        Args:\n            name: Name for the data\n            value: Data. Can be a numpy array or a single value.\n        \"\"\"\n        if isinstance(value, np.ndarray):\n            shape = (self.step + 1, *value.shape)\n        else:\n            shape = (self.step + 1,)\n\n        if self._prank == 0:\n            with self._file(\"a\") as f:\n                grp = f.require_group(\"globals\")\n                if name not in grp.keys():\n                    vec = grp.create_dataset(\n                        name,\n                        shape=shape,\n                        dtype=dtype if dtype else np.array(value).dtype,\n                        chunks=True,\n                        maxshape=(None, *shape[1:]) if len(shape) > 1 else (None,),\n                        fillvalue=np.nan,\n                    )\n                    vec[-1] = value\n                else:\n                    vec = grp[name]\n                    vec.resize(shape)\n                    vec[-1] = value\n",
                "lines": [
                  237,
                  266
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_global_fields": {
              "docstring": "Add multiple global fields at once.\n",
              "signature": "(self, fields: Dict[str, Any]) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "fields": {
                  "default": null,
                  "annotation": "typing.Dict[str, typing.Any]",
                  "description": "Dictionary with fields"
                }
              },
              "source": {
                "code": "    def add_global_fields(self, fields: Dict[str, Any]) -> None:\n        \"\"\"Add multiple global fields at once.\n\n        Args:\n            fields: Dictionary with fields\n        \"\"\"\n        for name, value in fields.items():\n            self.add_global_field(name, value)\n",
                "lines": [
                  268,
                  275
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_additional": {
              "docstring": "Add an additional file stored elsewhere or in database directory.\n",
              "signature": "(self, name: str, file: str) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "name": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "Name of data"
                },
                "file": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "filename of file"
                }
              },
              "source": {
                "code": "    @deprecated(\"Use `copy_file` instead.\")\n    def add_additional(self, name: str, file: str) -> None:\n        \"\"\"Add an additional file stored elsewhere or in database directory.\n\n        Args:\n            name: Name of data\n            file: filename of file\n        \"\"\"\n        if self._prank == 0:\n            with self._file(\"a\") as f:\n                grp = f.require_group(\"additionals\")\n                grp.attrs.update({name: file})\n",
                "lines": [
                  277,
                  288
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "finish_step": {
              "docstring": "Finish step. Adds 1 to the step counter.",
              "signature": "(self) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def finish_step(self) -> None:\n        \"\"\"Finish step. Adds 1 to the step counter.\"\"\"\n        self.step += 1\n",
                "lines": [
                  290,
                  292
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "finish_sim": {
              "docstring": "",
              "signature": "(self, status: str = 'Finished') -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "status": {
                  "default": "Finished",
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def finish_sim(self, status: str = \"Finished\") -> None:\n        if self._prank == 0:\n            self.change_status(status)\n",
                "lines": [
                  294,
                  296
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "register_git_attributes": {
              "docstring": "Register git information for given repo.\n",
              "signature": "(self, repo_path: str = './') -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "repo_path": {
                  "default": "./",
                  "annotation": "<class 'str'>",
                  "description": "path to git repository"
                }
              },
              "source": {
                "code": "    def register_git_attributes(self, repo_path: str = \"./\") -> None:\n        \"\"\"Register git information for given repo.\n\n        Args:\n            repo_path (`str`): path to git repository\n        \"\"\"\n        if self._prank == 0:\n            repo_path = os.path.abspath(repo_path)\n            # store current working directory\n            cwd = os.getcwd()\n\n            # switch directory to git repo\n            os.chdir(repo_path)\n            git_string = GitStateGetter().create_git_string()\n\n            # switch working directory back\n            os.chdir(cwd)\n\n            with self._file(\"a\") as f:\n                grp = f.require_group(\"git\")\n                repo_name = os.path.split(repo_path)[1]\n                log.info(f\"Adding repo {repo_name}\")\n                if repo_name in grp.keys():\n                    del grp[repo_name]\n                grp.create_dataset(repo_name, data=git_string)\n",
                "lines": [
                  298,
                  322
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "copy_executable": {
              "docstring": "WILL BE REMOVED. USE COPY_FILE.\nCopy an executable to directory for reproducability.",
              "signature": "(self, script_path: str) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "script_path": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": "path to script"
                }
              },
              "source": {
                "code": "    def copy_executable(self, script_path: str) -> None:\n        \"\"\"WILL BE REMOVED. USE COPY_FILE.\n        Copy an executable to directory for reproducability.\n\n        Args:\n            script_path: path to script\n        \"\"\"\n        shutil.copy(script_path, self.path)\n        self.executable = os.path.split(script_path)[1]\n",
                "lines": [
                  324,
                  332
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "copy_file": {
              "docstring": "Copy a file to the datafolder.\n",
              "signature": "(self, source: Union[str, list], destination: str = '') -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "source": {
                  "default": null,
                  "annotation": "typing.Union[str, list]",
                  "description": "path to file, or list of files"
                },
                "destination": {
                  "default": "",
                  "annotation": "<class 'str'>",
                  "description": "destination (will create intermediatory directories)"
                }
              },
              "source": {
                "code": "    def copy_file(self, source: Union[str, list], destination: str = \"\") -> None:\n        \"\"\"Copy a file to the datafolder.\n\n        Args:\n            source: path to file, or list of files\n            destination: destination (will create intermediatory directories)\n        \"\"\"\n        if self._prank != 0:\n            return\n\n        if isinstance(source, list):\n            for item in source:\n                self.copy_file(item, destination)\n            return\n\n        destination = os.path.join(self.path, destination)\n\n        if os.path.isdir(source):\n            shutil.copytree(\n                source,\n                os.path.join(destination, os.path.basename(source)),\n                dirs_exist_ok=True,\n            )\n        elif os.path.isfile(source):\n            os.makedirs(destination, exist_ok=True)\n            shutil.copy(source, destination)\n        else:\n            raise FileNotFoundError\n",
                "lines": [
                  334,
                  361
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {
            "step": {
              "annotation": ": int",
              "description": null
            }
          },
          "inherits_from": {
            "Simulation": {
              "module": "bamboost.simulation",
              "members": [
                [
                  "variable",
                  "uid"
                ],
                [
                  "variable",
                  "path_database"
                ],
                [
                  "variable",
                  "database_id"
                ],
                [
                  "variable",
                  "path"
                ],
                [
                  "variable",
                  "h5file"
                ],
                [
                  "variable",
                  "xdmffile"
                ],
                [
                  "variable",
                  "meshes"
                ],
                [
                  "variable",
                  "data"
                ],
                [
                  "variable",
                  "globals"
                ],
                [
                  "variable",
                  "userdata"
                ],
                [
                  "variable",
                  "links"
                ],
                [
                  "function",
                  "fromUID"
                ],
                [
                  "function",
                  "__getitem__"
                ],
                [
                  "variable",
                  "parameters"
                ],
                [
                  "variable",
                  "metadata"
                ],
                [
                  "function",
                  "files"
                ],
                [
                  "function",
                  "show_files"
                ],
                [
                  "function",
                  "open_in_file_explorer"
                ],
                [
                  "function",
                  "open_in_paraview"
                ],
                [
                  "function",
                  "get_full_uid"
                ],
                [
                  "function",
                  "change_status"
                ],
                [
                  "function",
                  "update_metadata"
                ],
                [
                  "function",
                  "update_parameters"
                ],
                [
                  "function",
                  "create_xdmf_file"
                ],
                [
                  "function",
                  "create_run_script"
                ],
                [
                  "function",
                  "create_batch_script"
                ],
                [
                  "function",
                  "submit"
                ],
                [
                  "function",
                  "change_note"
                ],
                [
                  "function",
                  "open"
                ],
                [
                  "variable",
                  "mesh"
                ],
                [
                  "function",
                  "get_mesh"
                ],
                [
                  "variable",
                  "data_info"
                ],
                [
                  "variable",
                  "git"
                ],
                [
                  "function",
                  "get_data_interpolator"
                ],
                [
                  "function",
                  "show_h5tree"
                ],
                [
                  "function",
                  "enter_path"
                ]
              ]
            }
          },
          "examples": [],
          "constructor": {
            "signature": "(\n    uid: str,\n    path: str,\n    comm: bamboost.common._mock_mpi.MockMPI.Comm = <bamboost.common._mock_mpi.MockMPI.Comm object>,\n    create_if_not_exists: bool = True\n)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "uid": {
                "default": null,
                "annotation": "<class 'str'>",
                "description": "The identifier of the simulation"
              },
              "path": {
                "default": null,
                "annotation": "<class 'str'>",
                "description": "The (parent) database path"
              },
              "comm": {
                "default": "<bamboost.common._mock_mpi.MockMPI.Comm object at 0x743de48d8890>",
                "annotation": "<class 'bamboost.common._mock_mpi.MockMPI.Comm'>",
                "description": "An MPI communicator (Default: `MPI.COMM_WORLD`)"
              },
              "create_if_not_exists": {
                "default": "True",
                "annotation": "<class 'bool'>",
                "description": null
              }
            },
            "source": {
              "code": "    def __init__(\n        self,\n        uid: str,\n        path: str,\n        comm: MPI.Comm = MPI.COMM_WORLD,\n        create_if_not_exists: bool = True,\n    ):\n        super().__init__(uid, path, comm, create_if_not_exists)\n        self.step: int = 0\n",
              "lines": [
                45,
                53
              ]
            }
          }
        }
      },
      "functions": {},
      "submodules": {}
    },
    "xdmf": {
      "name": "bamboost.xdmf",
      "docstring": "",
      "classes": {
        "XDMFWriter": {
          "name": "XDMFWriter",
          "short_description": "Write xdmf file for a subset of the stored data in the H5 file.",
          "docstring": "Write xdmf file for a subset of the stored data in the H5 file.\n",
          "methods": {
            "write_file": {
              "docstring": "",
              "signature": "(self)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                }
              },
              "source": {
                "code": "    def write_file(self):\n        tree = ET.ElementTree(self.xdmf_file)\n        self._pretty_print(tree.getroot())\n        tree.write(self.filename)\n",
                "lines": [
                  48,
                  51
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "write_points_cells": {
              "docstring": "Write the mesh to the xdmf file.\n",
              "signature": "(self, points_location: str, cells_location: str)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "points_location": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                },
                "cells_location": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def write_points_cells(self, points_location: str, cells_location: str):\n        \"\"\"Write the mesh to the xdmf file.\n\n        Args:\n            points (str): String to geometry/nodes in h5 file\n            cells (str): String to topology/cells in h5 file\n        \"\"\"\n        grid = ET.SubElement(\n            self.domain, \"Grid\", Name=self.mesh_name, GridType=\"Uniform\"\n        )\n        self._points(grid, points_location)\n        self._cells(grid, cells_location)\n",
                "lines": [
                  68,
                  79
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "add_timeseries": {
              "docstring": "",
              "signature": "(self, steps: int, fields: list)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "steps": {
                  "default": null,
                  "annotation": "<class 'int'>",
                  "description": null
                },
                "fields": {
                  "default": null,
                  "annotation": "<class 'list'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def add_timeseries(self, steps: int, fields: list):\n        collection = ET.SubElement(\n            self.domain,\n            \"Grid\",\n            Name=\"TimeSeries\",\n            GridType=\"Collection\",\n            CollectionType=\"Temporal\",\n        )\n\n        for i in range(steps):\n            self.write_step(collection, fields, i)\n",
                "lines": [
                  122,
                  132
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "write_step": {
              "docstring": "Write the data array for time t.\n",
              "signature": "(\n    self,\n    collection: xml.etree.ElementTree.Element,\n    fields: list,\n    step: int\n)",
              "returns": {
                "annotation": "<class 'inspect._empty'>",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "collection": {
                  "default": null,
                  "annotation": "<class 'xml.etree.ElementTree.Element'>",
                  "description": null
                },
                "fields": {
                  "default": null,
                  "annotation": "<class 'list'>",
                  "description": null
                },
                "step": {
                  "default": null,
                  "annotation": "<class 'int'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def write_step(self, collection: ET.Element, fields: list, step: int):\n        \"\"\"Write the data array for time t.\n\n        Args:\n            t (float): time\n            data_location (str): String to data in h5 file\n            name (str): Name for the field in the Xdmf file\n        \"\"\"\n        with h5py.File(self.h5file, \"r\") as f:\n            grid = ET.SubElement(collection, \"Grid\")\n            ptr = f'xpointer(//Grid[@Name=\"{self.mesh_name}\"]/*[self::Topology or self::Geometry])'\n\n            ET.SubElement(\n                grid, \"{http://www.w3.org/2003/XInclude}include\", xpointer=ptr\n            )\n\n            t = f[f\"data/{fields[0]}/{step}\"].attrs.get(\"t\", step)\n            ET.SubElement(grid, \"Time\", Value=str(t))\n\n            for name in fields:\n                self.write_attribute(grid, name, name, step)\n",
                "lines": [
                  134,
                  154
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            },
            "write_attribute": {
              "docstring": "Write an attribute/field.",
              "signature": "(\n    self,\n    grid: xml.etree.ElementTree.Element,\n    field_name: str,\n    name: str,\n    step: int\n) -> None",
              "returns": {
                "annotation": "None",
                "description": null
              },
              "arguments": {
                "self": {
                  "default": null,
                  "annotation": null,
                  "description": null
                },
                "grid": {
                  "default": null,
                  "annotation": "<class 'xml.etree.ElementTree.Element'>",
                  "description": null
                },
                "field_name": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                },
                "name": {
                  "default": null,
                  "annotation": "<class 'str'>",
                  "description": null
                },
                "step": {
                  "default": null,
                  "annotation": "<class 'int'>",
                  "description": null
                }
              },
              "source": {
                "code": "    def write_attribute(\n        self, grid: ET.Element, field_name: str, name: str, step: int\n    ) -> None:\n        \"\"\"Write an attribute/field.\"\"\"\n        with h5py.File(self.h5file, \"r\") as f:\n            data = f[f\"data/{field_name}/{step}\"]\n\n            if data.ndim == 1 or data.shape[1] <= 1:\n                att_type = \"Scalar\"\n            elif data.ndim == 2:\n                att_type = \"Vector\"\n            elif data.ndim == 3 and len(set(data.shape[1:])) == 1:\n                # Square shape -> Tensor\n                att_type = \"Tensor\"\n            else:\n                att_type = \"Matrix\"\n\n            # Cell or Node data\n            center = data.attrs.get(\"center\", \"Node\")\n\n            att = ET.SubElement(\n                grid,\n                \"Attribute\",\n                Name=name,\n                AttributeType=att_type,\n                Center=center,\n            )\n\n            dt, prec = numpy_to_xdmf_dtype[data.dtype.name]\n            dim = \" \".join([str(i) for i in data.shape])\n\n            data_item = ET.SubElement(\n                att,\n                \"DataItem\",\n                DataType=dt,\n                Dimensions=dim,\n                Format=\"HDF\",\n                Precision=prec,\n            )\n            h5file_name = os.path.split(self.h5file)[1]\n            data_item.text = f\"{h5file_name}:/data/{field_name}/{step}\"\n",
                "lines": [
                  156,
                  196
                ]
              },
              "props": {
                "isClassMethod": false
              },
              "examples": []
            }
          },
          "variables": {
            "filename": {
              "annotation": "",
              "description": null
            },
            "h5file": {
              "annotation": "",
              "description": null
            },
            "xdmf_file": {
              "annotation": "",
              "description": null
            },
            "domain": {
              "annotation": "",
              "description": null
            },
            "mesh_name": {
              "annotation": "",
              "description": null
            }
          },
          "inherits_from": {},
          "examples": [],
          "constructor": {
            "signature": "(filename: str, h5file: str)",
            "arguments": {
              "self": {
                "default": null,
                "annotation": null,
                "description": null
              },
              "filename": {
                "default": null,
                "annotation": "<class 'str'>",
                "description": "xdmf file path"
              },
              "h5file": {
                "default": null,
                "annotation": "<class 'str'>",
                "description": "h5 file path"
              }
            },
            "source": {
              "code": "    def __init__(self, filename: str, h5file: str):\n        self.filename = filename\n        self.h5file = h5file\n        self.xdmf_file = ET.Element(\"Xdmf\", Version=\"3.0\")\n        self.domain = ET.SubElement(self.xdmf_file, \"Domain\")\n        ET.register_namespace(\"xi\", \"https://www.w3.org/2001/XInclude/\")\n        self.mesh_name = \"mesh\"\n",
              "lines": [
                40,
                46
              ]
            }
          }
        }
      },
      "functions": {},
      "submodules": {}
    }
  }
}